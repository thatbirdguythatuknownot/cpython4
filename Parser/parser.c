// @generated by pegen from python.gram
#include "pegen.h"

#if defined(Py_DEBUG) && defined(Py_BUILD_CORE)
#  define D(x) if (p->debug) { x; }
#else
#  define D(x)
#endif

#ifdef __wasi__
#  define MAXSTACK 4000
#else
#  define MAXSTACK 6000
#endif
static const int n_keyword_lists = 9;
static KeywordToken *reserved_keywords[] = {
    (KeywordToken[]) {{NULL, -1}},
    (KeywordToken[]) {{NULL, -1}},
    (KeywordToken[]) {
        {"if", 772},
        {"as", 770},
        {"in", 783},
        {"is", 690},
        {"or", 677},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"del", 717},
        {"for", 782},
        {"try", 751},
        {"and", 678},
        {"not", 689},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"from", 722},
        {"pass", 565},
        {"goto", 574},
        {"with", 733},
        {"None", 715},
        {"True", 714},
        {"elif", 774},
        {"else", 775},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"raise", 566},
        {"yield", 676},
        {"break", 545},
        {"async", 784},
        {"class", 786},
        {"while", 777},
        {"False", 716},
        {"await", 691},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"return", 567},
        {"import", 721},
        {"assert", 573},
        {"global", 555},
        {"except", 767},
        {"lambda", 713},
        {"unless", 671},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"finally", 763},
        {NULL, -1},
    },
    (KeywordToken[]) {
        {"continue", 547},
        {"nonlocal", 562},
        {NULL, -1},
    },
};
static char *soft_keywords[] = {
    "_",
    "block",
    "case",
    "def",
    "label",
    "match",
    "switch",
    "type",
    "where",
    NULL,
};
#define file_type 1000
#define interactive_type 1001
#define eval_type 1002
#define func_type_type 1003
#define fstring_type 1004
#define statements_type 1005
#define statement_type 1006
#define statement_newline_type 1007
#define simple_stmts_type 1008
#define simple_stmt_complex_type 1009
#define simple_stmt_type 1010
#define compound_stmt_type 1011
#define statements_nonewline_type 1012
#define parenthesized_stmt_nonewline_type 1013
#define statement_nonewline_type 1014
#define simple_stmts_nonewline_type 1015
#define compound_stmt_nonewline_type 1016
#define assignment_type 1017
#define top_rhs_type 1018
#define augassign_type 1019
#define unarassign_type 1020
#define return_stmt_type 1021
#define raise_stmt_type 1022
#define global_stmt_type 1023
#define nonlocal_stmt_type 1024
#define del_kw_stmt_type 1025
#define del_stmt_type 1026
#define yield_stmt_type 1027
#define assert_stmt_type 1028
#define goto_stmt_type 1029
#define label_stmt_type 1030
#define import_stmt_type 1031
#define import_name_type 1032
#define import_from_type 1033
#define import_from_targets_type 1034
#define import_from_as_names_type 1035
#define import_from_as_name_type 1036
#define dotted_as_names_type 1037
#define dotted_as_name_type 1038
#define dotted_name_type 1039  // Left-recursive
#define assignment_block_type 1040
#define assignment_block_nonewline_type 1041
#define block_entry_type 1042
#define block_entry_nonewline_type 1043
#define braced_block_type 1044
#define block_type 1045
#define block_nonewline_type 1046
#define decorators_type 1047
#define class_def_type 1048
#define class_def_raw_type 1049
#define class_def_nonewline_type 1050
#define class_def_raw_nonewline_type 1051
#define function_def_type 1052
#define function_def_raw_type 1053
#define function_def_nonewline_type 1054
#define function_def_raw_nonewline_type 1055
#define params_type 1056
#define parameters_type 1057
#define slash_no_default_type 1058
#define slash_with_default_type 1059
#define star_etc_type 1060
#define kwds_type 1061
#define param_no_default_type 1062
#define param_no_default_star_annotation_type 1063
#define param_with_default_type 1064
#define param_maybe_default_type 1065
#define param_type 1066
#define param_star_annotation_type 1067
#define annotation_type 1068
#define star_annotation_type 1069
#define default_type 1070
#define if_stmt_type 1071
#define elif_stmt_type 1072
#define else_block_type 1073
#define if_stmt_nonewline_type 1074
#define elif_stmt_nonewline_type 1075
#define else_block_nonewline_type 1076
#define while_stmt_type 1077
#define while_stmt_nonewline_type 1078
#define for_stmt_type 1079
#define for_stmt_nonewline_type 1080
#define with_stmt_type 1081
#define with_stmt_nonewline_type 1082
#define with_item_type 1083
#define try_stmt_type 1084
#define try_stmt_nonewline_type 1085
#define except_block_type 1086
#define except_star_block_type 1087
#define finally_block_type 1088
#define except_block_nonewline_type 1089
#define except_star_block_nonewline_type 1090
#define finally_block_nonewline_type 1091
#define switch_stmt_type 1092
#define switchcase_block_type 1093
#define switch_stmt_nonewline_type 1094
#define switchcase_block_nonewline_type 1095
#define bitwiseor_pattern_type 1096  // Left-recursive
#define bitwisexor_pattern_type 1097  // Left-recursive
#define bitwiseand_pattern_type 1098  // Left-recursive
#define shift_pattern_type 1099  // Left-recursive
#define sum_pattern_type 1100  // Left-recursive
#define term_pattern_type 1101  // Left-recursive
#define factor_pattern_type 1102
#define power_pattern_type 1103
#define number_pattern_type 1104
#define match_stmt_type 1105
#define match_stmt_nonewline_type 1106
#define subject_expr_type 1107
#define case_block_type 1108
#define case_block_nonewline_type 1109
#define guard_type 1110
#define patterns_type 1111
#define pattern_type 1112
#define as_pattern_type 1113
#define or_pattern_type 1114
#define closed_pattern_type 1115
#define literal_pattern_type 1116
#define literal_expr_type 1117
#define complex_number_type 1118
#define signed_number_type 1119
#define signed_real_number_type 1120
#define real_number_type 1121
#define imaginary_number_type 1122
#define capture_pattern_type 1123
#define pattern_capture_target_type 1124
#define wildcard_pattern_type 1125
#define value_pattern_type 1126
#define attr_type 1127  // Left-recursive
#define name_or_attr_type 1128  // Left-recursive
#define group_pattern_type 1129
#define sequence_pattern_type 1130
#define open_sequence_pattern_type 1131
#define maybe_sequence_pattern_type 1132
#define maybe_star_pattern_type 1133
#define star_pattern_type 1134
#define mapping_pattern_type 1135
#define items_pattern_type 1136
#define key_value_pattern_type 1137
#define double_star_pattern_type 1138
#define class_pattern_type 1139
#define positional_patterns_type 1140
#define keyword_patterns_type 1141
#define keyword_pattern_type 1142
#define unless_stmt_type 1143
#define unless_stmt_nonewline_type 1144
#define type_alias_type 1145
#define type_params_type 1146
#define type_param_seq_type 1147
#define type_param_type 1148
#define type_param_bound_type 1149
#define expressions_type 1150
#define expression_type 1151
#define yield_expr_type 1152
#define block_expr_type 1153
#define block_expr_nonewline_type 1154
#define star_expressions_type 1155
#define star_expression_type 1156
#define star_sum_type 1157
#define star_named_expressions_type 1158
#define star_named_expression_type 1159
#define star_assignment_expression_type 1160
#define assignment_expression_type 1161
#define named_expression_type 1162
#define disjunction_type 1163
#define conjunction_type 1164
#define inversion_type 1165
#define comparison_type 1166
#define compare_op_composition_pair_type 1167
#define eq_composition_type 1168
#define noteq_composition_type 1169
#define lte_composition_type 1170
#define lt_composition_type 1171
#define gte_composition_type 1172
#define gt_composition_type 1173
#define notin_composition_type 1174
#define in_composition_type 1175
#define isnotin_composition_type 1176
#define isin_composition_type 1177
#define isnot_composition_type 1178
#define is_composition_type 1179
#define composition_type 1180  // Left-recursive
#define bitwise_or_type 1181  // Left-recursive
#define bitwise_xor_type 1182  // Left-recursive
#define bitwise_and_type 1183  // Left-recursive
#define shift_expr_type 1184  // Left-recursive
#define sum_type 1185  // Left-recursive
#define term_type 1186  // Left-recursive
#define factor_type 1187
#define coalesce_type 1188
#define power_type 1189
#define await_primary_type 1190
#define primary_type 1191  // Left-recursive
#define slices_type 1192
#define slice_type 1193
#define simple_slice_type 1194
#define atom_type 1195
#define group_type 1196
#define compound_expr_type 1197
#define lambdef_type 1198
#define lambda_params_type 1199
#define lambda_sum_params_type 1200
#define lambda_parameters_type 1201
#define lambda_slash_no_default_type 1202
#define lambda_slash_with_default_type 1203
#define lambda_star_etc_type 1204
#define lambda_kwds_type 1205
#define lambda_param_no_default_type 1206
#define lambda_param_with_default_type 1207
#define lambda_param_maybe_default_type 1208
#define lambda_param_type 1209
#define lambda_sum_parameters_type 1210
#define lambda_sum_slash_no_default_type 1211
#define lambda_sum_slash_with_default_type 1212
#define lambda_sum_star_etc_type 1213
#define lambda_sum_kwds_type 1214
#define lambda_sum_param_no_default_type 1215
#define lambda_sum_param_no_default_star_annotation_type 1216
#define lambda_sum_param_with_default_type 1217
#define lambda_sum_param_maybe_default_type 1218
#define sum_param_type 1219
#define sum_param_star_annotation_type 1220
#define sum_annotation_type 1221
#define star_sum_annotation_type 1222
#define sum_default_type 1223
#define fstring_middle_type 1224
#define fstring_replacement_field_type 1225
#define fstring_conversion_type 1226
#define fstring_full_format_spec_type 1227
#define fstring_format_spec_type 1228
#define string_type 1229
#define strings_type 1230
#define list_type 1231
#define tuple_type 1232
#define set_type 1233
#define dict_type 1234
#define double_starred_kvpairs_type 1235
#define double_starred_kvpair_type 1236
#define kvpair_type 1237
#define for_if_clauses_type 1238
#define for_if_clause_type 1239
#define listcomp_type 1240
#define tuplecomp_type 1241
#define setcomp_type 1242
#define genexp_type 1243
#define dictcomp_type 1244
#define arguments_type 1245
#define args_type 1246
#define kwargs_type 1247
#define starred_expression_type 1248
#define kwarg_or_starred_type 1249
#define kwarg_or_double_starred_type 1250
#define star_targets_type 1251
#define star_targets_list_seq_type 1252
#define star_targets_tuple_seq_type 1253
#define star_target_type 1254
#define target_with_star_atom_type 1255
#define star_atom_type 1256
#define single_target_type 1257
#define single_subscript_attribute_target_type 1258
#define t_primary_type 1259  // Left-recursive
#define t_lookahead_type 1260
#define t_lookmain_type 1261
#define del_targets_type 1262
#define del_target_type 1263
#define del_t_atom_type 1264
#define type_expressions_type 1265
#define func_type_comment_type 1266
#define invalid_arguments_type 1267
#define invalid_kwarg_type 1268
#define expression_without_invalid_type 1269
#define invalid_legacy_expression_type 1270
#define invalid_expression_type 1271
#define invalid_named_expression_type 1272
#define invalid_assignment_type 1273
#define invalid_ann_assign_target_type 1274
#define invalid_del_stmt_type 1275
#define invalid_block_type 1276
#define invalid_comprehension_type 1277
#define invalid_dict_comprehension_type 1278
#define invalid_parameters_type 1279
#define invalid_default_type 1280
#define invalid_sum_default_type 1281
#define invalid_star_etc_type 1282
#define invalid_kwds_type 1283
#define invalid_parameters_helper_type 1284
#define invalid_lambda_parameters_type 1285
#define invalid_lambda_parameters_helper_type 1286
#define invalid_lambda_star_etc_type 1287
#define invalid_lambda_kwds_type 1288
#define invalid_lambda_sum_parameters_type 1289
#define invalid_lambda_sum_parameters_helper_type 1290
#define invalid_lambda_sum_star_etc_type 1291
#define invalid_double_type_comments_type 1292
#define invalid_with_item_type 1293
#define invalid_for_target_type 1294
#define invalid_group_type 1295
#define invalid_import_type 1296
#define invalid_import_from_targets_type 1297
#define invalid_with_stmt_type 1298
#define invalid_with_stmt_indent_type 1299
#define invalid_try_stmt_type 1300
#define invalid_try_stmt_nonewline_type 1301
#define invalid_except_stmt_type 1302
#define invalid_except_stmt_nonewline_type 1303
#define invalid_finally_stmt_type 1304
#define invalid_except_stmt_indent_type 1305
#define invalid_except_star_stmt_indent_type 1306
#define invalid_match_stmt_type 1307
#define invalid_case_block_type 1308
#define invalid_as_pattern_type 1309
#define invalid_class_pattern_type 1310
#define invalid_class_argument_pattern_type 1311
#define invalid_if_stmt_type 1312
#define invalid_elif_stmt_type 1313
#define invalid_else_stmt_type 1314
#define invalid_while_stmt_type 1315
#define invalid_for_stmt_type 1316
#define invalid_def_raw_type 1317
#define invalid_class_def_raw_nonewline_type 1318
#define invalid_class_def_raw_type 1319
#define invalid_double_starred_kvpairs_type 1320
#define invalid_kvpair_type 1321
#define invalid_starred_expression_type 1322
#define invalid_replacement_field_type 1323
#define invalid_conversion_character_type 1324
#define _loop0_1_type 1325
#define _loop0_2_type 1326
#define _loop0_3_type 1327
#define _loop1_4_type 1328
#define _tmp_5_type 1329
#define _tmp_6_type 1330
#define _tmp_7_type 1331
#define _tmp_8_type 1332
#define _tmp_9_type 1333
#define _tmp_10_type 1334
#define _tmp_11_type 1335
#define _loop1_12_type 1336
#define _loop0_14_type 1337
#define _gather_13_type 1338
#define _tmp_15_type 1339
#define _tmp_16_type 1340
#define _tmp_17_type 1341
#define _tmp_18_type 1342
#define _tmp_19_type 1343
#define _loop1_20_type 1344
#define _tmp_21_type 1345
#define _tmp_22_type 1346
#define _tmp_23_type 1347
#define _tmp_24_type 1348
#define _tmp_25_type 1349
#define _tmp_26_type 1350
#define _tmp_27_type 1351
#define _loop0_29_type 1352
#define _gather_28_type 1353
#define _loop0_31_type 1354
#define _gather_30_type 1355
#define _tmp_32_type 1356
#define _tmp_33_type 1357
#define _tmp_34_type 1358
#define _loop0_36_type 1359
#define _gather_35_type 1360
#define _loop0_37_type 1361
#define _loop1_38_type 1362
#define _loop0_40_type 1363
#define _gather_39_type 1364
#define _tmp_41_type 1365
#define _loop0_43_type 1366
#define _gather_42_type 1367
#define _tmp_44_type 1368
#define _tmp_45_type 1369
#define _tmp_46_type 1370
#define _tmp_47_type 1371
#define _loop1_48_type 1372
#define _tmp_49_type 1373
#define _tmp_50_type 1374
#define _tmp_51_type 1375
#define _tmp_52_type 1376
#define _tmp_53_type 1377
#define _loop1_54_type 1378
#define _tmp_55_type 1379
#define _tmp_56_type 1380
#define _tmp_57_type 1381
#define _loop1_58_type 1382
#define _tmp_59_type 1383
#define _tmp_60_type 1384
#define _tmp_61_type 1385
#define _tmp_62_type 1386
#define _tmp_63_type 1387
#define _tmp_64_type 1388
#define _tmp_65_type 1389
#define _tmp_66_type 1390
#define _tmp_67_type 1391
#define _tmp_68_type 1392
#define _loop0_69_type 1393
#define _loop0_70_type 1394
#define _loop0_71_type 1395
#define _loop1_72_type 1396
#define _loop0_73_type 1397
#define _loop1_74_type 1398
#define _loop1_75_type 1399
#define _loop1_76_type 1400
#define _loop0_77_type 1401
#define _loop1_78_type 1402
#define _loop0_79_type 1403
#define _loop1_80_type 1404
#define _loop0_81_type 1405
#define _loop0_82_type 1406
#define _loop1_83_type 1407
#define _tmp_84_type 1408
#define _tmp_85_type 1409
#define _loop0_87_type 1410
#define _gather_86_type 1411
#define _loop0_89_type 1412
#define _gather_88_type 1413
#define _loop0_91_type 1414
#define _gather_90_type 1415
#define _loop0_93_type 1416
#define _gather_92_type 1417
#define _loop0_95_type 1418
#define _gather_94_type 1419
#define _loop0_97_type 1420
#define _gather_96_type 1421
#define _loop0_99_type 1422
#define _gather_98_type 1423
#define _loop0_101_type 1424
#define _gather_100_type 1425
#define _loop0_103_type 1426
#define _gather_102_type 1427
#define _loop0_105_type 1428
#define _gather_104_type 1429
#define _loop0_107_type 1430
#define _gather_106_type 1431
#define _loop0_109_type 1432
#define _gather_108_type 1433
#define _tmp_110_type 1434
#define _tmp_111_type 1435
#define _tmp_112_type 1436
#define _loop1_113_type 1437
#define _tmp_114_type 1438
#define _loop1_115_type 1439
#define _tmp_116_type 1440
#define _tmp_117_type 1441
#define _loop1_118_type 1442
#define _tmp_119_type 1443
#define _loop1_120_type 1444
#define _tmp_121_type 1445
#define _tmp_122_type 1446
#define _tmp_123_type 1447
#define _tmp_124_type 1448
#define _tmp_125_type 1449
#define _tmp_126_type 1450
#define _loop1_127_type 1451
#define _loop1_128_type 1452
#define _loop0_130_type 1453
#define _gather_129_type 1454
#define _loop1_131_type 1455
#define _loop1_132_type 1456
#define _loop0_134_type 1457
#define _gather_133_type 1458
#define _loop1_135_type 1459
#define _loop1_136_type 1460
#define _loop1_137_type 1461
#define _loop1_138_type 1462
#define _loop0_140_type 1463
#define _gather_139_type 1464
#define _tmp_141_type 1465
#define _tmp_142_type 1466
#define _tmp_143_type 1467
#define _tmp_144_type 1468
#define _loop0_146_type 1469
#define _gather_145_type 1470
#define _loop0_148_type 1471
#define _gather_147_type 1472
#define _tmp_149_type 1473
#define _loop0_151_type 1474
#define _gather_150_type 1475
#define _loop0_153_type 1476
#define _gather_152_type 1477
#define _tmp_154_type 1478
#define _loop0_156_type 1479
#define _gather_155_type 1480
#define _loop1_157_type 1481
#define _loop1_158_type 1482
#define _loop0_160_type 1483
#define _gather_159_type 1484
#define _loop1_161_type 1485
#define _loop1_162_type 1486
#define _loop1_163_type 1487
#define _tmp_164_type 1488
#define _tmp_165_type 1489
#define _tmp_166_type 1490
#define _tmp_167_type 1491
#define _loop0_169_type 1492
#define _gather_168_type 1493
#define _tmp_170_type 1494
#define _tmp_171_type 1495
#define _tmp_172_type 1496
#define _tmp_173_type 1497
#define _tmp_174_type 1498
#define _tmp_175_type 1499
#define _tmp_176_type 1500
#define _loop0_177_type 1501
#define _loop0_178_type 1502
#define _loop0_179_type 1503
#define _loop1_180_type 1504
#define _loop0_181_type 1505
#define _loop1_182_type 1506
#define _loop1_183_type 1507
#define _loop1_184_type 1508
#define _loop0_185_type 1509
#define _loop1_186_type 1510
#define _loop0_187_type 1511
#define _loop1_188_type 1512
#define _loop0_189_type 1513
#define _loop1_190_type 1514
#define _loop0_191_type 1515
#define _loop0_192_type 1516
#define _loop0_193_type 1517
#define _loop1_194_type 1518
#define _loop0_195_type 1519
#define _loop1_196_type 1520
#define _loop1_197_type 1521
#define _loop1_198_type 1522
#define _loop0_199_type 1523
#define _loop1_200_type 1524
#define _loop0_201_type 1525
#define _loop1_202_type 1526
#define _loop0_203_type 1527
#define _loop0_204_type 1528
#define _loop1_205_type 1529
#define _loop0_206_type 1530
#define _loop1_207_type 1531
#define _tmp_208_type 1532
#define _loop0_210_type 1533
#define _gather_209_type 1534
#define _loop1_211_type 1535
#define _loop0_212_type 1536
#define _loop0_213_type 1537
#define _loop0_214_type 1538
#define _tmp_215_type 1539
#define _tmp_216_type 1540
#define _loop0_218_type 1541
#define _gather_217_type 1542
#define _tmp_219_type 1543
#define _loop0_221_type 1544
#define _gather_220_type 1545
#define _loop0_223_type 1546
#define _gather_222_type 1547
#define _loop0_225_type 1548
#define _gather_224_type 1549
#define _loop0_227_type 1550
#define _gather_226_type 1551
#define _tmp_228_type 1552
#define _tmp_229_type 1553
#define _loop0_230_type 1554
#define _loop0_232_type 1555
#define _gather_231_type 1556
#define _loop1_233_type 1557
#define _tmp_234_type 1558
#define _tmp_235_type 1559
#define _loop0_237_type 1560
#define _gather_236_type 1561
#define _loop0_239_type 1562
#define _gather_238_type 1563
#define _loop0_241_type 1564
#define _gather_240_type 1565
#define _loop0_243_type 1566
#define _gather_242_type 1567
#define _loop0_245_type 1568
#define _gather_244_type 1569
#define _tmp_246_type 1570
#define _tmp_247_type 1571
#define _tmp_248_type 1572
#define _tmp_249_type 1573
#define _tmp_250_type 1574
#define _tmp_251_type 1575
#define _tmp_252_type 1576
#define _tmp_253_type 1577
#define _tmp_254_type 1578
#define _tmp_255_type 1579
#define _tmp_256_type 1580
#define _tmp_257_type 1581
#define _loop0_258_type 1582
#define _loop0_259_type 1583
#define _loop0_260_type 1584
#define _tmp_261_type 1585
#define _tmp_262_type 1586
#define _tmp_263_type 1587
#define _tmp_264_type 1588
#define _tmp_265_type 1589
#define _loop0_266_type 1590
#define _loop0_267_type 1591
#define _loop0_268_type 1592
#define _loop1_269_type 1593
#define _tmp_270_type 1594
#define _loop0_271_type 1595
#define _tmp_272_type 1596
#define _loop0_273_type 1597
#define _loop1_274_type 1598
#define _tmp_275_type 1599
#define _tmp_276_type 1600
#define _tmp_277_type 1601
#define _tmp_278_type 1602
#define _loop0_279_type 1603
#define _tmp_280_type 1604
#define _tmp_281_type 1605
#define _loop1_282_type 1606
#define _tmp_283_type 1607
#define _loop0_284_type 1608
#define _loop0_285_type 1609
#define _loop0_286_type 1610
#define _loop0_288_type 1611
#define _gather_287_type 1612
#define _tmp_289_type 1613
#define _loop0_290_type 1614
#define _tmp_291_type 1615
#define _loop0_292_type 1616
#define _loop1_293_type 1617
#define _loop1_294_type 1618
#define _tmp_295_type 1619
#define _tmp_296_type 1620
#define _loop0_297_type 1621
#define _tmp_298_type 1622
#define _tmp_299_type 1623
#define _tmp_300_type 1624
#define _loop0_301_type 1625
#define _loop0_302_type 1626
#define _loop0_303_type 1627
#define _loop0_305_type 1628
#define _gather_304_type 1629
#define _tmp_306_type 1630
#define _loop0_307_type 1631
#define _tmp_308_type 1632
#define _loop0_309_type 1633
#define _loop1_310_type 1634
#define _loop1_311_type 1635
#define _tmp_312_type 1636
#define _tmp_313_type 1637
#define _loop0_314_type 1638
#define _tmp_315_type 1639
#define _tmp_316_type 1640
#define _loop0_318_type 1641
#define _gather_317_type 1642
#define _loop0_320_type 1643
#define _gather_319_type 1644
#define _loop0_322_type 1645
#define _gather_321_type 1646
#define _loop0_324_type 1647
#define _gather_323_type 1648
#define _loop0_326_type 1649
#define _gather_325_type 1650
#define _tmp_327_type 1651
#define _loop0_328_type 1652
#define _loop1_329_type 1653
#define _tmp_330_type 1654
#define _loop0_331_type 1655
#define _loop1_332_type 1656
#define _tmp_333_type 1657
#define _tmp_334_type 1658
#define _loop0_335_type 1659
#define _loop1_336_type 1660
#define _tmp_337_type 1661
#define _loop0_338_type 1662
#define _loop1_339_type 1663
#define _tmp_340_type 1664
#define _tmp_341_type 1665
#define _tmp_342_type 1666
#define _tmp_343_type 1667
#define _tmp_344_type 1668
#define _tmp_345_type 1669
#define _tmp_346_type 1670
#define _tmp_347_type 1671
#define _tmp_348_type 1672
#define _tmp_349_type 1673
#define _tmp_350_type 1674
#define _loop0_352_type 1675
#define _gather_351_type 1676
#define _tmp_353_type 1677
#define _tmp_354_type 1678
#define _tmp_355_type 1679
#define _tmp_356_type 1680
#define _tmp_357_type 1681
#define _tmp_358_type 1682
#define _tmp_359_type 1683
#define _loop0_360_type 1684
#define _tmp_361_type 1685
#define _tmp_362_type 1686
#define _tmp_363_type 1687
#define _tmp_364_type 1688
#define _tmp_365_type 1689
#define _tmp_366_type 1690
#define _tmp_367_type 1691
#define _tmp_368_type 1692
#define _tmp_369_type 1693
#define _tmp_370_type 1694
#define _tmp_371_type 1695
#define _loop0_373_type 1696
#define _gather_372_type 1697
#define _tmp_374_type 1698
#define _tmp_375_type 1699
#define _tmp_376_type 1700
#define _tmp_377_type 1701
#define _tmp_378_type 1702
#define _tmp_379_type 1703
#define _tmp_380_type 1704
#define _tmp_381_type 1705
#define _tmp_382_type 1706
#define _tmp_383_type 1707
#define _tmp_384_type 1708
#define _tmp_385_type 1709
#define _tmp_386_type 1710
#define _tmp_387_type 1711
#define _tmp_388_type 1712
#define _tmp_389_type 1713
#define _tmp_390_type 1714
#define _tmp_391_type 1715
#define _tmp_392_type 1716
#define _tmp_393_type 1717
#define _tmp_394_type 1718
#define _tmp_395_type 1719
#define _tmp_396_type 1720
#define _tmp_397_type 1721
#define _tmp_398_type 1722
#define _loop0_400_type 1723
#define _gather_399_type 1724
#define _tmp_401_type 1725
#define _tmp_402_type 1726
#define _tmp_403_type 1727
#define _tmp_404_type 1728
#define _tmp_405_type 1729

static mod_ty file_rule(Parser *p);
static mod_ty interactive_rule(Parser *p);
static mod_ty eval_rule(Parser *p);
static mod_ty func_type_rule(Parser *p);
static expr_ty fstring_rule(Parser *p);
static asdl_stmt_seq* statements_rule(Parser *p);
static asdl_stmt_seq* statement_rule(Parser *p);
static asdl_stmt_seq* statement_newline_rule(Parser *p);
static asdl_stmt_seq* simple_stmts_rule(Parser *p);
static asdl_stmt_seq* simple_stmt_complex_rule(Parser *p);
static stmt_ty simple_stmt_rule(Parser *p);
static stmt_ty compound_stmt_rule(Parser *p);
static asdl_stmt_seq* statements_nonewline_rule(Parser *p);
static asdl_stmt_seq* parenthesized_stmt_nonewline_rule(Parser *p);
static asdl_stmt_seq* statement_nonewline_rule(Parser *p);
static asdl_stmt_seq* simple_stmts_nonewline_rule(Parser *p);
static stmt_ty compound_stmt_nonewline_rule(Parser *p);
static stmt_ty assignment_rule(Parser *p);
static expr_ty top_rhs_rule(Parser *p);
static AugOperator* augassign_rule(Parser *p);
static AugOperator* unarassign_rule(Parser *p);
static stmt_ty return_stmt_rule(Parser *p);
static stmt_ty raise_stmt_rule(Parser *p);
static stmt_ty global_stmt_rule(Parser *p);
static stmt_ty nonlocal_stmt_rule(Parser *p);
static stmt_ty del_kw_stmt_rule(Parser *p);
static stmt_ty del_stmt_rule(Parser *p);
static stmt_ty yield_stmt_rule(Parser *p);
static stmt_ty assert_stmt_rule(Parser *p);
static stmt_ty goto_stmt_rule(Parser *p);
static stmt_ty label_stmt_rule(Parser *p);
static stmt_ty import_stmt_rule(Parser *p);
static stmt_ty import_name_rule(Parser *p);
static stmt_ty import_from_rule(Parser *p);
static asdl_alias_seq* import_from_targets_rule(Parser *p);
static asdl_alias_seq* import_from_as_names_rule(Parser *p);
static alias_ty import_from_as_name_rule(Parser *p);
static asdl_alias_seq* dotted_as_names_rule(Parser *p);
static alias_ty dotted_as_name_rule(Parser *p);
static expr_ty dotted_name_rule(Parser *p);
static stmt_ty assignment_block_rule(Parser *p);
static stmt_ty assignment_block_nonewline_rule(Parser *p);
static asdl_stmt_seq* block_entry_rule(Parser *p);
static asdl_stmt_seq* block_entry_nonewline_rule(Parser *p);
static asdl_stmt_seq* braced_block_rule(Parser *p);
static asdl_stmt_seq* block_rule(Parser *p);
static asdl_stmt_seq* block_nonewline_rule(Parser *p);
static asdl_expr_seq* decorators_rule(Parser *p);
static stmt_ty class_def_rule(Parser *p);
static stmt_ty class_def_raw_rule(Parser *p);
static stmt_ty class_def_nonewline_rule(Parser *p);
static stmt_ty class_def_raw_nonewline_rule(Parser *p);
static stmt_ty function_def_rule(Parser *p);
static stmt_ty function_def_raw_rule(Parser *p);
static stmt_ty function_def_nonewline_rule(Parser *p);
static stmt_ty function_def_raw_nonewline_rule(Parser *p);
static arguments_ty params_rule(Parser *p);
static arguments_ty parameters_rule(Parser *p);
static asdl_arg_seq* slash_no_default_rule(Parser *p);
static SlashWithDefault* slash_with_default_rule(Parser *p);
static StarEtc* star_etc_rule(Parser *p);
static arg_ty kwds_rule(Parser *p);
static arg_ty param_no_default_rule(Parser *p);
static arg_ty param_no_default_star_annotation_rule(Parser *p);
static NameDefaultPair* param_with_default_rule(Parser *p);
static NameDefaultPair* param_maybe_default_rule(Parser *p);
static arg_ty param_rule(Parser *p);
static arg_ty param_star_annotation_rule(Parser *p);
static expr_ty annotation_rule(Parser *p);
static expr_ty star_annotation_rule(Parser *p);
static expr_ty default_rule(Parser *p);
static stmt_ty if_stmt_rule(Parser *p);
static stmt_ty elif_stmt_rule(Parser *p);
static asdl_stmt_seq* else_block_rule(Parser *p);
static stmt_ty if_stmt_nonewline_rule(Parser *p);
static stmt_ty elif_stmt_nonewline_rule(Parser *p);
static asdl_stmt_seq* else_block_nonewline_rule(Parser *p);
static stmt_ty while_stmt_rule(Parser *p);
static stmt_ty while_stmt_nonewline_rule(Parser *p);
static stmt_ty for_stmt_rule(Parser *p);
static stmt_ty for_stmt_nonewline_rule(Parser *p);
static stmt_ty with_stmt_rule(Parser *p);
static stmt_ty with_stmt_nonewline_rule(Parser *p);
static withitem_ty with_item_rule(Parser *p);
static stmt_ty try_stmt_rule(Parser *p);
static stmt_ty try_stmt_nonewline_rule(Parser *p);
static excepthandler_ty except_block_rule(Parser *p);
static excepthandler_ty except_star_block_rule(Parser *p);
static asdl_stmt_seq* finally_block_rule(Parser *p);
static excepthandler_ty except_block_nonewline_rule(Parser *p);
static excepthandler_ty except_star_block_nonewline_rule(Parser *p);
static asdl_stmt_seq* finally_block_nonewline_rule(Parser *p);
static stmt_ty switch_stmt_rule(Parser *p);
static switch_case_ty switchcase_block_rule(Parser *p);
static stmt_ty switch_stmt_nonewline_rule(Parser *p);
static switch_case_ty switchcase_block_nonewline_rule(Parser *p);
static expr_ty bitwiseor_pattern_rule(Parser *p);
static expr_ty bitwisexor_pattern_rule(Parser *p);
static expr_ty bitwiseand_pattern_rule(Parser *p);
static expr_ty shift_pattern_rule(Parser *p);
static expr_ty sum_pattern_rule(Parser *p);
static expr_ty term_pattern_rule(Parser *p);
static expr_ty factor_pattern_rule(Parser *p);
static expr_ty power_pattern_rule(Parser *p);
static expr_ty number_pattern_rule(Parser *p);
static stmt_ty match_stmt_rule(Parser *p);
static stmt_ty match_stmt_nonewline_rule(Parser *p);
static expr_ty subject_expr_rule(Parser *p);
static match_case_ty case_block_rule(Parser *p);
static match_case_ty case_block_nonewline_rule(Parser *p);
static expr_ty guard_rule(Parser *p);
static pattern_ty patterns_rule(Parser *p);
static pattern_ty pattern_rule(Parser *p);
static pattern_ty as_pattern_rule(Parser *p);
static pattern_ty or_pattern_rule(Parser *p);
static pattern_ty closed_pattern_rule(Parser *p);
static pattern_ty literal_pattern_rule(Parser *p);
static expr_ty literal_expr_rule(Parser *p);
static expr_ty complex_number_rule(Parser *p);
static expr_ty signed_number_rule(Parser *p);
static expr_ty signed_real_number_rule(Parser *p);
static expr_ty real_number_rule(Parser *p);
static expr_ty imaginary_number_rule(Parser *p);
static pattern_ty capture_pattern_rule(Parser *p);
static expr_ty pattern_capture_target_rule(Parser *p);
static pattern_ty wildcard_pattern_rule(Parser *p);
static pattern_ty value_pattern_rule(Parser *p);
static expr_ty attr_rule(Parser *p);
static expr_ty name_or_attr_rule(Parser *p);
static pattern_ty group_pattern_rule(Parser *p);
static pattern_ty sequence_pattern_rule(Parser *p);
static asdl_seq* open_sequence_pattern_rule(Parser *p);
static asdl_seq* maybe_sequence_pattern_rule(Parser *p);
static pattern_ty maybe_star_pattern_rule(Parser *p);
static pattern_ty star_pattern_rule(Parser *p);
static pattern_ty mapping_pattern_rule(Parser *p);
static asdl_seq* items_pattern_rule(Parser *p);
static KeyPatternPair* key_value_pattern_rule(Parser *p);
static expr_ty double_star_pattern_rule(Parser *p);
static pattern_ty class_pattern_rule(Parser *p);
static asdl_pattern_seq* positional_patterns_rule(Parser *p);
static asdl_seq* keyword_patterns_rule(Parser *p);
static KeyPatternPair* keyword_pattern_rule(Parser *p);
static stmt_ty unless_stmt_rule(Parser *p);
static stmt_ty unless_stmt_nonewline_rule(Parser *p);
static stmt_ty type_alias_rule(Parser *p);
static asdl_type_param_seq* type_params_rule(Parser *p);
static asdl_type_param_seq* type_param_seq_rule(Parser *p);
static type_param_ty type_param_rule(Parser *p);
static expr_ty type_param_bound_rule(Parser *p);
static expr_ty expressions_rule(Parser *p);
static expr_ty expression_rule(Parser *p);
static expr_ty yield_expr_rule(Parser *p);
static expr_ty block_expr_rule(Parser *p);
static expr_ty block_expr_nonewline_rule(Parser *p);
static expr_ty star_expressions_rule(Parser *p);
static expr_ty star_expression_rule(Parser *p);
static expr_ty star_sum_rule(Parser *p);
static asdl_expr_seq* star_named_expressions_rule(Parser *p);
static expr_ty star_named_expression_rule(Parser *p);
static expr_ty star_assignment_expression_rule(Parser *p);
static expr_ty assignment_expression_rule(Parser *p);
static expr_ty named_expression_rule(Parser *p);
static expr_ty disjunction_rule(Parser *p);
static expr_ty conjunction_rule(Parser *p);
static expr_ty inversion_rule(Parser *p);
static expr_ty comparison_rule(Parser *p);
static CmpopExprPair* compare_op_composition_pair_rule(Parser *p);
static CmpopExprPair* eq_composition_rule(Parser *p);
static CmpopExprPair* noteq_composition_rule(Parser *p);
static CmpopExprPair* lte_composition_rule(Parser *p);
static CmpopExprPair* lt_composition_rule(Parser *p);
static CmpopExprPair* gte_composition_rule(Parser *p);
static CmpopExprPair* gt_composition_rule(Parser *p);
static CmpopExprPair* notin_composition_rule(Parser *p);
static CmpopExprPair* in_composition_rule(Parser *p);
static CmpopExprPair* isnotin_composition_rule(Parser *p);
static CmpopExprPair* isin_composition_rule(Parser *p);
static CmpopExprPair* isnot_composition_rule(Parser *p);
static CmpopExprPair* is_composition_rule(Parser *p);
static expr_ty composition_rule(Parser *p);
static expr_ty bitwise_or_rule(Parser *p);
static expr_ty bitwise_xor_rule(Parser *p);
static expr_ty bitwise_and_rule(Parser *p);
static expr_ty shift_expr_rule(Parser *p);
static expr_ty sum_rule(Parser *p);
static expr_ty term_rule(Parser *p);
static expr_ty factor_rule(Parser *p);
static expr_ty coalesce_rule(Parser *p);
static expr_ty power_rule(Parser *p);
static expr_ty await_primary_rule(Parser *p);
static expr_ty primary_rule(Parser *p);
static expr_ty slices_rule(Parser *p);
static expr_ty slice_rule(Parser *p);
static expr_ty simple_slice_rule(Parser *p);
static expr_ty atom_rule(Parser *p);
static expr_ty group_rule(Parser *p);
static expr_ty compound_expr_rule(Parser *p);
static expr_ty lambdef_rule(Parser *p);
static arguments_ty lambda_params_rule(Parser *p);
static arguments_ty lambda_sum_params_rule(Parser *p);
static arguments_ty lambda_parameters_rule(Parser *p);
static asdl_arg_seq* lambda_slash_no_default_rule(Parser *p);
static SlashWithDefault* lambda_slash_with_default_rule(Parser *p);
static StarEtc* lambda_star_etc_rule(Parser *p);
static arg_ty lambda_kwds_rule(Parser *p);
static arg_ty lambda_param_no_default_rule(Parser *p);
static NameDefaultPair* lambda_param_with_default_rule(Parser *p);
static NameDefaultPair* lambda_param_maybe_default_rule(Parser *p);
static arg_ty lambda_param_rule(Parser *p);
static arguments_ty lambda_sum_parameters_rule(Parser *p);
static asdl_arg_seq* lambda_sum_slash_no_default_rule(Parser *p);
static SlashWithDefault* lambda_sum_slash_with_default_rule(Parser *p);
static StarEtc* lambda_sum_star_etc_rule(Parser *p);
static arg_ty lambda_sum_kwds_rule(Parser *p);
static arg_ty lambda_sum_param_no_default_rule(Parser *p);
static arg_ty lambda_sum_param_no_default_star_annotation_rule(Parser *p);
static NameDefaultPair* lambda_sum_param_with_default_rule(Parser *p);
static NameDefaultPair* lambda_sum_param_maybe_default_rule(Parser *p);
static arg_ty sum_param_rule(Parser *p);
static arg_ty sum_param_star_annotation_rule(Parser *p);
static expr_ty sum_annotation_rule(Parser *p);
static expr_ty star_sum_annotation_rule(Parser *p);
static expr_ty sum_default_rule(Parser *p);
static expr_ty fstring_middle_rule(Parser *p);
static expr_ty fstring_replacement_field_rule(Parser *p);
static ResultTokenWithMetadata* fstring_conversion_rule(Parser *p);
static ResultTokenWithMetadata* fstring_full_format_spec_rule(Parser *p);
static expr_ty fstring_format_spec_rule(Parser *p);
static expr_ty string_rule(Parser *p);
static expr_ty strings_rule(Parser *p);
static expr_ty list_rule(Parser *p);
static expr_ty tuple_rule(Parser *p);
static expr_ty set_rule(Parser *p);
static expr_ty dict_rule(Parser *p);
static asdl_seq* double_starred_kvpairs_rule(Parser *p);
static KeyValuePair* double_starred_kvpair_rule(Parser *p);
static KeyValuePair* kvpair_rule(Parser *p);
static asdl_comprehension_seq* for_if_clauses_rule(Parser *p);
static comprehension_ty for_if_clause_rule(Parser *p);
static expr_ty listcomp_rule(Parser *p);
static expr_ty tuplecomp_rule(Parser *p);
static expr_ty setcomp_rule(Parser *p);
static expr_ty genexp_rule(Parser *p);
static expr_ty dictcomp_rule(Parser *p);
static expr_ty arguments_rule(Parser *p);
static expr_ty args_rule(Parser *p);
static asdl_seq* kwargs_rule(Parser *p);
static expr_ty starred_expression_rule(Parser *p);
static KeywordOrStarred* kwarg_or_starred_rule(Parser *p);
static KeywordOrStarred* kwarg_or_double_starred_rule(Parser *p);
static expr_ty star_targets_rule(Parser *p);
static asdl_expr_seq* star_targets_list_seq_rule(Parser *p);
static asdl_expr_seq* star_targets_tuple_seq_rule(Parser *p);
static expr_ty star_target_rule(Parser *p);
static expr_ty target_with_star_atom_rule(Parser *p);
static expr_ty star_atom_rule(Parser *p);
static expr_ty single_target_rule(Parser *p);
static expr_ty single_subscript_attribute_target_rule(Parser *p);
static expr_ty t_primary_rule(Parser *p);
static void *t_lookahead_rule(Parser *p);
static void *t_lookmain_rule(Parser *p);
static asdl_expr_seq* del_targets_rule(Parser *p);
static expr_ty del_target_rule(Parser *p);
static expr_ty del_t_atom_rule(Parser *p);
static asdl_expr_seq* type_expressions_rule(Parser *p);
static Token* func_type_comment_rule(Parser *p);
static void *invalid_arguments_rule(Parser *p);
static void *invalid_kwarg_rule(Parser *p);
static expr_ty expression_without_invalid_rule(Parser *p);
static void *invalid_legacy_expression_rule(Parser *p);
static void *invalid_expression_rule(Parser *p);
static void *invalid_named_expression_rule(Parser *p);
static void *invalid_assignment_rule(Parser *p);
static expr_ty invalid_ann_assign_target_rule(Parser *p);
static void *invalid_del_stmt_rule(Parser *p);
static void *invalid_block_rule(Parser *p);
static void *invalid_comprehension_rule(Parser *p);
static void *invalid_dict_comprehension_rule(Parser *p);
static void *invalid_parameters_rule(Parser *p);
static void *invalid_default_rule(Parser *p);
static void *invalid_sum_default_rule(Parser *p);
static void *invalid_star_etc_rule(Parser *p);
static void *invalid_kwds_rule(Parser *p);
static void *invalid_parameters_helper_rule(Parser *p);
static void *invalid_lambda_parameters_rule(Parser *p);
static void *invalid_lambda_parameters_helper_rule(Parser *p);
static void *invalid_lambda_star_etc_rule(Parser *p);
static void *invalid_lambda_kwds_rule(Parser *p);
static void *invalid_lambda_sum_parameters_rule(Parser *p);
static void *invalid_lambda_sum_parameters_helper_rule(Parser *p);
static void *invalid_lambda_sum_star_etc_rule(Parser *p);
static void *invalid_double_type_comments_rule(Parser *p);
static void *invalid_with_item_rule(Parser *p);
static void *invalid_for_target_rule(Parser *p);
static void *invalid_group_rule(Parser *p);
static void *invalid_import_rule(Parser *p);
static void *invalid_import_from_targets_rule(Parser *p);
static void *invalid_with_stmt_rule(Parser *p);
static void *invalid_with_stmt_indent_rule(Parser *p);
static void *invalid_try_stmt_rule(Parser *p);
static void *invalid_try_stmt_nonewline_rule(Parser *p);
static void *invalid_except_stmt_rule(Parser *p);
static void *invalid_except_stmt_nonewline_rule(Parser *p);
static void *invalid_finally_stmt_rule(Parser *p);
static void *invalid_except_stmt_indent_rule(Parser *p);
static void *invalid_except_star_stmt_indent_rule(Parser *p);
static void *invalid_match_stmt_rule(Parser *p);
static void *invalid_case_block_rule(Parser *p);
static void *invalid_as_pattern_rule(Parser *p);
static void *invalid_class_pattern_rule(Parser *p);
static asdl_pattern_seq* invalid_class_argument_pattern_rule(Parser *p);
static void *invalid_if_stmt_rule(Parser *p);
static void *invalid_elif_stmt_rule(Parser *p);
static void *invalid_else_stmt_rule(Parser *p);
static void *invalid_while_stmt_rule(Parser *p);
static void *invalid_for_stmt_rule(Parser *p);
static void *invalid_def_raw_rule(Parser *p);
static void *invalid_class_def_raw_nonewline_rule(Parser *p);
static void *invalid_class_def_raw_rule(Parser *p);
static void *invalid_double_starred_kvpairs_rule(Parser *p);
static void *invalid_kvpair_rule(Parser *p);
static void *invalid_starred_expression_rule(Parser *p);
static void *invalid_replacement_field_rule(Parser *p);
static void *invalid_conversion_character_rule(Parser *p);
static asdl_seq *_loop0_1_rule(Parser *p);
static asdl_seq *_loop0_2_rule(Parser *p);
static asdl_seq *_loop0_3_rule(Parser *p);
static asdl_seq *_loop1_4_rule(Parser *p);
static void *_tmp_5_rule(Parser *p);
static void *_tmp_6_rule(Parser *p);
static void *_tmp_7_rule(Parser *p);
static void *_tmp_8_rule(Parser *p);
static void *_tmp_9_rule(Parser *p);
static void *_tmp_10_rule(Parser *p);
static void *_tmp_11_rule(Parser *p);
static asdl_seq *_loop1_12_rule(Parser *p);
static asdl_seq *_loop0_14_rule(Parser *p);
static asdl_seq *_gather_13_rule(Parser *p);
static void *_tmp_15_rule(Parser *p);
static void *_tmp_16_rule(Parser *p);
static void *_tmp_17_rule(Parser *p);
static void *_tmp_18_rule(Parser *p);
static void *_tmp_19_rule(Parser *p);
static asdl_seq *_loop1_20_rule(Parser *p);
static void *_tmp_21_rule(Parser *p);
static void *_tmp_22_rule(Parser *p);
static void *_tmp_23_rule(Parser *p);
static void *_tmp_24_rule(Parser *p);
static void *_tmp_25_rule(Parser *p);
static void *_tmp_26_rule(Parser *p);
static void *_tmp_27_rule(Parser *p);
static asdl_seq *_loop0_29_rule(Parser *p);
static asdl_seq *_gather_28_rule(Parser *p);
static asdl_seq *_loop0_31_rule(Parser *p);
static asdl_seq *_gather_30_rule(Parser *p);
static void *_tmp_32_rule(Parser *p);
static void *_tmp_33_rule(Parser *p);
static void *_tmp_34_rule(Parser *p);
static asdl_seq *_loop0_36_rule(Parser *p);
static asdl_seq *_gather_35_rule(Parser *p);
static asdl_seq *_loop0_37_rule(Parser *p);
static asdl_seq *_loop1_38_rule(Parser *p);
static asdl_seq *_loop0_40_rule(Parser *p);
static asdl_seq *_gather_39_rule(Parser *p);
static void *_tmp_41_rule(Parser *p);
static asdl_seq *_loop0_43_rule(Parser *p);
static asdl_seq *_gather_42_rule(Parser *p);
static void *_tmp_44_rule(Parser *p);
static void *_tmp_45_rule(Parser *p);
static void *_tmp_46_rule(Parser *p);
static void *_tmp_47_rule(Parser *p);
static asdl_seq *_loop1_48_rule(Parser *p);
static void *_tmp_49_rule(Parser *p);
static void *_tmp_50_rule(Parser *p);
static void *_tmp_51_rule(Parser *p);
static void *_tmp_52_rule(Parser *p);
static void *_tmp_53_rule(Parser *p);
static asdl_seq *_loop1_54_rule(Parser *p);
static void *_tmp_55_rule(Parser *p);
static void *_tmp_56_rule(Parser *p);
static void *_tmp_57_rule(Parser *p);
static asdl_seq *_loop1_58_rule(Parser *p);
static void *_tmp_59_rule(Parser *p);
static void *_tmp_60_rule(Parser *p);
static void *_tmp_61_rule(Parser *p);
static void *_tmp_62_rule(Parser *p);
static void *_tmp_63_rule(Parser *p);
static void *_tmp_64_rule(Parser *p);
static void *_tmp_65_rule(Parser *p);
static void *_tmp_66_rule(Parser *p);
static void *_tmp_67_rule(Parser *p);
static void *_tmp_68_rule(Parser *p);
static asdl_seq *_loop0_69_rule(Parser *p);
static asdl_seq *_loop0_70_rule(Parser *p);
static asdl_seq *_loop0_71_rule(Parser *p);
static asdl_seq *_loop1_72_rule(Parser *p);
static asdl_seq *_loop0_73_rule(Parser *p);
static asdl_seq *_loop1_74_rule(Parser *p);
static asdl_seq *_loop1_75_rule(Parser *p);
static asdl_seq *_loop1_76_rule(Parser *p);
static asdl_seq *_loop0_77_rule(Parser *p);
static asdl_seq *_loop1_78_rule(Parser *p);
static asdl_seq *_loop0_79_rule(Parser *p);
static asdl_seq *_loop1_80_rule(Parser *p);
static asdl_seq *_loop0_81_rule(Parser *p);
static asdl_seq *_loop0_82_rule(Parser *p);
static asdl_seq *_loop1_83_rule(Parser *p);
static void *_tmp_84_rule(Parser *p);
static void *_tmp_85_rule(Parser *p);
static asdl_seq *_loop0_87_rule(Parser *p);
static asdl_seq *_gather_86_rule(Parser *p);
static asdl_seq *_loop0_89_rule(Parser *p);
static asdl_seq *_gather_88_rule(Parser *p);
static asdl_seq *_loop0_91_rule(Parser *p);
static asdl_seq *_gather_90_rule(Parser *p);
static asdl_seq *_loop0_93_rule(Parser *p);
static asdl_seq *_gather_92_rule(Parser *p);
static asdl_seq *_loop0_95_rule(Parser *p);
static asdl_seq *_gather_94_rule(Parser *p);
static asdl_seq *_loop0_97_rule(Parser *p);
static asdl_seq *_gather_96_rule(Parser *p);
static asdl_seq *_loop0_99_rule(Parser *p);
static asdl_seq *_gather_98_rule(Parser *p);
static asdl_seq *_loop0_101_rule(Parser *p);
static asdl_seq *_gather_100_rule(Parser *p);
static asdl_seq *_loop0_103_rule(Parser *p);
static asdl_seq *_gather_102_rule(Parser *p);
static asdl_seq *_loop0_105_rule(Parser *p);
static asdl_seq *_gather_104_rule(Parser *p);
static asdl_seq *_loop0_107_rule(Parser *p);
static asdl_seq *_gather_106_rule(Parser *p);
static asdl_seq *_loop0_109_rule(Parser *p);
static asdl_seq *_gather_108_rule(Parser *p);
static void *_tmp_110_rule(Parser *p);
static void *_tmp_111_rule(Parser *p);
static void *_tmp_112_rule(Parser *p);
static asdl_seq *_loop1_113_rule(Parser *p);
static void *_tmp_114_rule(Parser *p);
static asdl_seq *_loop1_115_rule(Parser *p);
static void *_tmp_116_rule(Parser *p);
static void *_tmp_117_rule(Parser *p);
static asdl_seq *_loop1_118_rule(Parser *p);
static void *_tmp_119_rule(Parser *p);
static asdl_seq *_loop1_120_rule(Parser *p);
static void *_tmp_121_rule(Parser *p);
static void *_tmp_122_rule(Parser *p);
static void *_tmp_123_rule(Parser *p);
static void *_tmp_124_rule(Parser *p);
static void *_tmp_125_rule(Parser *p);
static void *_tmp_126_rule(Parser *p);
static asdl_seq *_loop1_127_rule(Parser *p);
static asdl_seq *_loop1_128_rule(Parser *p);
static asdl_seq *_loop0_130_rule(Parser *p);
static asdl_seq *_gather_129_rule(Parser *p);
static asdl_seq *_loop1_131_rule(Parser *p);
static asdl_seq *_loop1_132_rule(Parser *p);
static asdl_seq *_loop0_134_rule(Parser *p);
static asdl_seq *_gather_133_rule(Parser *p);
static asdl_seq *_loop1_135_rule(Parser *p);
static asdl_seq *_loop1_136_rule(Parser *p);
static asdl_seq *_loop1_137_rule(Parser *p);
static asdl_seq *_loop1_138_rule(Parser *p);
static asdl_seq *_loop0_140_rule(Parser *p);
static asdl_seq *_gather_139_rule(Parser *p);
static void *_tmp_141_rule(Parser *p);
static void *_tmp_142_rule(Parser *p);
static void *_tmp_143_rule(Parser *p);
static void *_tmp_144_rule(Parser *p);
static asdl_seq *_loop0_146_rule(Parser *p);
static asdl_seq *_gather_145_rule(Parser *p);
static asdl_seq *_loop0_148_rule(Parser *p);
static asdl_seq *_gather_147_rule(Parser *p);
static void *_tmp_149_rule(Parser *p);
static asdl_seq *_loop0_151_rule(Parser *p);
static asdl_seq *_gather_150_rule(Parser *p);
static asdl_seq *_loop0_153_rule(Parser *p);
static asdl_seq *_gather_152_rule(Parser *p);
static void *_tmp_154_rule(Parser *p);
static asdl_seq *_loop0_156_rule(Parser *p);
static asdl_seq *_gather_155_rule(Parser *p);
static asdl_seq *_loop1_157_rule(Parser *p);
static asdl_seq *_loop1_158_rule(Parser *p);
static asdl_seq *_loop0_160_rule(Parser *p);
static asdl_seq *_gather_159_rule(Parser *p);
static asdl_seq *_loop1_161_rule(Parser *p);
static asdl_seq *_loop1_162_rule(Parser *p);
static asdl_seq *_loop1_163_rule(Parser *p);
static void *_tmp_164_rule(Parser *p);
static void *_tmp_165_rule(Parser *p);
static void *_tmp_166_rule(Parser *p);
static void *_tmp_167_rule(Parser *p);
static asdl_seq *_loop0_169_rule(Parser *p);
static asdl_seq *_gather_168_rule(Parser *p);
static void *_tmp_170_rule(Parser *p);
static void *_tmp_171_rule(Parser *p);
static void *_tmp_172_rule(Parser *p);
static void *_tmp_173_rule(Parser *p);
static void *_tmp_174_rule(Parser *p);
static void *_tmp_175_rule(Parser *p);
static void *_tmp_176_rule(Parser *p);
static asdl_seq *_loop0_177_rule(Parser *p);
static asdl_seq *_loop0_178_rule(Parser *p);
static asdl_seq *_loop0_179_rule(Parser *p);
static asdl_seq *_loop1_180_rule(Parser *p);
static asdl_seq *_loop0_181_rule(Parser *p);
static asdl_seq *_loop1_182_rule(Parser *p);
static asdl_seq *_loop1_183_rule(Parser *p);
static asdl_seq *_loop1_184_rule(Parser *p);
static asdl_seq *_loop0_185_rule(Parser *p);
static asdl_seq *_loop1_186_rule(Parser *p);
static asdl_seq *_loop0_187_rule(Parser *p);
static asdl_seq *_loop1_188_rule(Parser *p);
static asdl_seq *_loop0_189_rule(Parser *p);
static asdl_seq *_loop1_190_rule(Parser *p);
static asdl_seq *_loop0_191_rule(Parser *p);
static asdl_seq *_loop0_192_rule(Parser *p);
static asdl_seq *_loop0_193_rule(Parser *p);
static asdl_seq *_loop1_194_rule(Parser *p);
static asdl_seq *_loop0_195_rule(Parser *p);
static asdl_seq *_loop1_196_rule(Parser *p);
static asdl_seq *_loop1_197_rule(Parser *p);
static asdl_seq *_loop1_198_rule(Parser *p);
static asdl_seq *_loop0_199_rule(Parser *p);
static asdl_seq *_loop1_200_rule(Parser *p);
static asdl_seq *_loop0_201_rule(Parser *p);
static asdl_seq *_loop1_202_rule(Parser *p);
static asdl_seq *_loop0_203_rule(Parser *p);
static asdl_seq *_loop0_204_rule(Parser *p);
static asdl_seq *_loop1_205_rule(Parser *p);
static asdl_seq *_loop0_206_rule(Parser *p);
static asdl_seq *_loop1_207_rule(Parser *p);
static void *_tmp_208_rule(Parser *p);
static asdl_seq *_loop0_210_rule(Parser *p);
static asdl_seq *_gather_209_rule(Parser *p);
static asdl_seq *_loop1_211_rule(Parser *p);
static asdl_seq *_loop0_212_rule(Parser *p);
static asdl_seq *_loop0_213_rule(Parser *p);
static asdl_seq *_loop0_214_rule(Parser *p);
static void *_tmp_215_rule(Parser *p);
static void *_tmp_216_rule(Parser *p);
static asdl_seq *_loop0_218_rule(Parser *p);
static asdl_seq *_gather_217_rule(Parser *p);
static void *_tmp_219_rule(Parser *p);
static asdl_seq *_loop0_221_rule(Parser *p);
static asdl_seq *_gather_220_rule(Parser *p);
static asdl_seq *_loop0_223_rule(Parser *p);
static asdl_seq *_gather_222_rule(Parser *p);
static asdl_seq *_loop0_225_rule(Parser *p);
static asdl_seq *_gather_224_rule(Parser *p);
static asdl_seq *_loop0_227_rule(Parser *p);
static asdl_seq *_gather_226_rule(Parser *p);
static void *_tmp_228_rule(Parser *p);
static void *_tmp_229_rule(Parser *p);
static asdl_seq *_loop0_230_rule(Parser *p);
static asdl_seq *_loop0_232_rule(Parser *p);
static asdl_seq *_gather_231_rule(Parser *p);
static asdl_seq *_loop1_233_rule(Parser *p);
static void *_tmp_234_rule(Parser *p);
static void *_tmp_235_rule(Parser *p);
static asdl_seq *_loop0_237_rule(Parser *p);
static asdl_seq *_gather_236_rule(Parser *p);
static asdl_seq *_loop0_239_rule(Parser *p);
static asdl_seq *_gather_238_rule(Parser *p);
static asdl_seq *_loop0_241_rule(Parser *p);
static asdl_seq *_gather_240_rule(Parser *p);
static asdl_seq *_loop0_243_rule(Parser *p);
static asdl_seq *_gather_242_rule(Parser *p);
static asdl_seq *_loop0_245_rule(Parser *p);
static asdl_seq *_gather_244_rule(Parser *p);
static void *_tmp_246_rule(Parser *p);
static void *_tmp_247_rule(Parser *p);
static void *_tmp_248_rule(Parser *p);
static void *_tmp_249_rule(Parser *p);
static void *_tmp_250_rule(Parser *p);
static void *_tmp_251_rule(Parser *p);
static void *_tmp_252_rule(Parser *p);
static void *_tmp_253_rule(Parser *p);
static void *_tmp_254_rule(Parser *p);
static void *_tmp_255_rule(Parser *p);
static void *_tmp_256_rule(Parser *p);
static void *_tmp_257_rule(Parser *p);
static asdl_seq *_loop0_258_rule(Parser *p);
static asdl_seq *_loop0_259_rule(Parser *p);
static asdl_seq *_loop0_260_rule(Parser *p);
static void *_tmp_261_rule(Parser *p);
static void *_tmp_262_rule(Parser *p);
static void *_tmp_263_rule(Parser *p);
static void *_tmp_264_rule(Parser *p);
static void *_tmp_265_rule(Parser *p);
static asdl_seq *_loop0_266_rule(Parser *p);
static asdl_seq *_loop0_267_rule(Parser *p);
static asdl_seq *_loop0_268_rule(Parser *p);
static asdl_seq *_loop1_269_rule(Parser *p);
static void *_tmp_270_rule(Parser *p);
static asdl_seq *_loop0_271_rule(Parser *p);
static void *_tmp_272_rule(Parser *p);
static asdl_seq *_loop0_273_rule(Parser *p);
static asdl_seq *_loop1_274_rule(Parser *p);
static void *_tmp_275_rule(Parser *p);
static void *_tmp_276_rule(Parser *p);
static void *_tmp_277_rule(Parser *p);
static void *_tmp_278_rule(Parser *p);
static asdl_seq *_loop0_279_rule(Parser *p);
static void *_tmp_280_rule(Parser *p);
static void *_tmp_281_rule(Parser *p);
static asdl_seq *_loop1_282_rule(Parser *p);
static void *_tmp_283_rule(Parser *p);
static asdl_seq *_loop0_284_rule(Parser *p);
static asdl_seq *_loop0_285_rule(Parser *p);
static asdl_seq *_loop0_286_rule(Parser *p);
static asdl_seq *_loop0_288_rule(Parser *p);
static asdl_seq *_gather_287_rule(Parser *p);
static void *_tmp_289_rule(Parser *p);
static asdl_seq *_loop0_290_rule(Parser *p);
static void *_tmp_291_rule(Parser *p);
static asdl_seq *_loop0_292_rule(Parser *p);
static asdl_seq *_loop1_293_rule(Parser *p);
static asdl_seq *_loop1_294_rule(Parser *p);
static void *_tmp_295_rule(Parser *p);
static void *_tmp_296_rule(Parser *p);
static asdl_seq *_loop0_297_rule(Parser *p);
static void *_tmp_298_rule(Parser *p);
static void *_tmp_299_rule(Parser *p);
static void *_tmp_300_rule(Parser *p);
static asdl_seq *_loop0_301_rule(Parser *p);
static asdl_seq *_loop0_302_rule(Parser *p);
static asdl_seq *_loop0_303_rule(Parser *p);
static asdl_seq *_loop0_305_rule(Parser *p);
static asdl_seq *_gather_304_rule(Parser *p);
static void *_tmp_306_rule(Parser *p);
static asdl_seq *_loop0_307_rule(Parser *p);
static void *_tmp_308_rule(Parser *p);
static asdl_seq *_loop0_309_rule(Parser *p);
static asdl_seq *_loop1_310_rule(Parser *p);
static asdl_seq *_loop1_311_rule(Parser *p);
static void *_tmp_312_rule(Parser *p);
static void *_tmp_313_rule(Parser *p);
static asdl_seq *_loop0_314_rule(Parser *p);
static void *_tmp_315_rule(Parser *p);
static void *_tmp_316_rule(Parser *p);
static asdl_seq *_loop0_318_rule(Parser *p);
static asdl_seq *_gather_317_rule(Parser *p);
static asdl_seq *_loop0_320_rule(Parser *p);
static asdl_seq *_gather_319_rule(Parser *p);
static asdl_seq *_loop0_322_rule(Parser *p);
static asdl_seq *_gather_321_rule(Parser *p);
static asdl_seq *_loop0_324_rule(Parser *p);
static asdl_seq *_gather_323_rule(Parser *p);
static asdl_seq *_loop0_326_rule(Parser *p);
static asdl_seq *_gather_325_rule(Parser *p);
static void *_tmp_327_rule(Parser *p);
static asdl_seq *_loop0_328_rule(Parser *p);
static asdl_seq *_loop1_329_rule(Parser *p);
static void *_tmp_330_rule(Parser *p);
static asdl_seq *_loop0_331_rule(Parser *p);
static asdl_seq *_loop1_332_rule(Parser *p);
static void *_tmp_333_rule(Parser *p);
static void *_tmp_334_rule(Parser *p);
static asdl_seq *_loop0_335_rule(Parser *p);
static asdl_seq *_loop1_336_rule(Parser *p);
static void *_tmp_337_rule(Parser *p);
static asdl_seq *_loop0_338_rule(Parser *p);
static asdl_seq *_loop1_339_rule(Parser *p);
static void *_tmp_340_rule(Parser *p);
static void *_tmp_341_rule(Parser *p);
static void *_tmp_342_rule(Parser *p);
static void *_tmp_343_rule(Parser *p);
static void *_tmp_344_rule(Parser *p);
static void *_tmp_345_rule(Parser *p);
static void *_tmp_346_rule(Parser *p);
static void *_tmp_347_rule(Parser *p);
static void *_tmp_348_rule(Parser *p);
static void *_tmp_349_rule(Parser *p);
static void *_tmp_350_rule(Parser *p);
static asdl_seq *_loop0_352_rule(Parser *p);
static asdl_seq *_gather_351_rule(Parser *p);
static void *_tmp_353_rule(Parser *p);
static void *_tmp_354_rule(Parser *p);
static void *_tmp_355_rule(Parser *p);
static void *_tmp_356_rule(Parser *p);
static void *_tmp_357_rule(Parser *p);
static void *_tmp_358_rule(Parser *p);
static void *_tmp_359_rule(Parser *p);
static asdl_seq *_loop0_360_rule(Parser *p);
static void *_tmp_361_rule(Parser *p);
static void *_tmp_362_rule(Parser *p);
static void *_tmp_363_rule(Parser *p);
static void *_tmp_364_rule(Parser *p);
static void *_tmp_365_rule(Parser *p);
static void *_tmp_366_rule(Parser *p);
static void *_tmp_367_rule(Parser *p);
static void *_tmp_368_rule(Parser *p);
static void *_tmp_369_rule(Parser *p);
static void *_tmp_370_rule(Parser *p);
static void *_tmp_371_rule(Parser *p);
static asdl_seq *_loop0_373_rule(Parser *p);
static asdl_seq *_gather_372_rule(Parser *p);
static void *_tmp_374_rule(Parser *p);
static void *_tmp_375_rule(Parser *p);
static void *_tmp_376_rule(Parser *p);
static void *_tmp_377_rule(Parser *p);
static void *_tmp_378_rule(Parser *p);
static void *_tmp_379_rule(Parser *p);
static void *_tmp_380_rule(Parser *p);
static void *_tmp_381_rule(Parser *p);
static void *_tmp_382_rule(Parser *p);
static void *_tmp_383_rule(Parser *p);
static void *_tmp_384_rule(Parser *p);
static void *_tmp_385_rule(Parser *p);
static void *_tmp_386_rule(Parser *p);
static void *_tmp_387_rule(Parser *p);
static void *_tmp_388_rule(Parser *p);
static void *_tmp_389_rule(Parser *p);
static void *_tmp_390_rule(Parser *p);
static void *_tmp_391_rule(Parser *p);
static void *_tmp_392_rule(Parser *p);
static void *_tmp_393_rule(Parser *p);
static void *_tmp_394_rule(Parser *p);
static void *_tmp_395_rule(Parser *p);
static void *_tmp_396_rule(Parser *p);
static void *_tmp_397_rule(Parser *p);
static void *_tmp_398_rule(Parser *p);
static asdl_seq *_loop0_400_rule(Parser *p);
static asdl_seq *_gather_399_rule(Parser *p);
static void *_tmp_401_rule(Parser *p);
static void *_tmp_402_rule(Parser *p);
static void *_tmp_403_rule(Parser *p);
static void *_tmp_404_rule(Parser *p);
static void *_tmp_405_rule(Parser *p);


// file: statements? $
static mod_ty
file_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // statements? $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> file[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statements? $"));
        void *a;
        Token * endmarker_var;
        if (
            (a = statements_rule(p), !p->error_indicator)  // statements?
            &&
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ file[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statements? $"));
            _res = _PyPegen_make_module ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s file[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "statements? $"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// interactive: statement_newline
static mod_ty
interactive_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // statement_newline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> interactive[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statement_newline"));
        asdl_stmt_seq* a;
        if (
            (a = statement_newline_rule(p))  // statement_newline
        )
        {
            D(fprintf(stderr, "%*c+ interactive[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statement_newline"));
            _res = _PyAST_Interactive ( a , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s interactive[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "statement_newline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// eval: expressions NEWLINE* $
static mod_ty
eval_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // expressions NEWLINE* $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> eval[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expressions NEWLINE* $"));
        asdl_seq * _loop0_1_var;
        expr_ty a;
        Token * endmarker_var;
        if (
            (a = expressions_rule(p))  // expressions
            &&
            (_loop0_1_var = _loop0_1_rule(p))  // NEWLINE*
            &&
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ eval[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expressions NEWLINE* $"));
            _res = _PyAST_Expression ( a , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s eval[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expressions NEWLINE* $"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// func_type: '(' type_expressions? ')' '->' expression NEWLINE* $
static mod_ty
func_type_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    mod_ty _res = NULL;
    int _mark = p->mark;
    { // '(' type_expressions? ')' '->' expression NEWLINE* $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> func_type[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' type_expressions? ')' '->' expression NEWLINE* $"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        asdl_seq * _loop0_2_var;
        void *a;
        expr_ty b;
        Token * endmarker_var;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = type_expressions_rule(p), !p->error_indicator)  // type_expressions?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (_literal_2 = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (b = expression_rule(p))  // expression
            &&
            (_loop0_2_var = _loop0_2_rule(p))  // NEWLINE*
            &&
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ func_type[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' type_expressions? ')' '->' expression NEWLINE* $"));
            _res = _PyAST_FunctionType ( a , b , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s func_type[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' type_expressions? ')' '->' expression NEWLINE* $"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// fstring: FSTRING_START fstring_middle* FSTRING_END
static expr_ty
fstring_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // FSTRING_START fstring_middle* FSTRING_END
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> fstring[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "FSTRING_START fstring_middle* FSTRING_END"));
        Token * a;
        asdl_seq * b;
        Token * c;
        if (
            (a = _PyPegen_expect_token(p, FSTRING_START))  // token='FSTRING_START'
            &&
            (b = _loop0_3_rule(p))  // fstring_middle*
            &&
            (c = _PyPegen_expect_token(p, FSTRING_END))  // token='FSTRING_END'
        )
        {
            D(fprintf(stderr, "%*c+ fstring[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "FSTRING_START fstring_middle* FSTRING_END"));
            _res = _PyPegen_joined_str ( p , a , ( asdl_expr_seq* ) b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s fstring[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "FSTRING_START fstring_middle* FSTRING_END"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// statements: statement+
static asdl_stmt_seq*
statements_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // statement+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statements[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statement+"));
        asdl_seq * a;
        if (
            (a = _loop1_4_rule(p))  // statement+
        )
        {
            D(fprintf(stderr, "%*c+ statements[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statement+"));
            _res = ( asdl_stmt_seq* ) _PyPegen_seq_flatten ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statements[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "statement+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// statement: compound_stmt | simple_stmts
static asdl_stmt_seq*
statement_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // compound_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "compound_stmt"));
        stmt_ty a;
        if (
            (a = compound_stmt_rule(p))  // compound_stmt
        )
        {
            D(fprintf(stderr, "%*c+ statement[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "compound_stmt"));
            _res = ( asdl_stmt_seq* ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "compound_stmt"));
    }
    { // simple_stmts
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmts"));
        asdl_stmt_seq* a;
        if (
            (a = (asdl_stmt_seq*)simple_stmts_rule(p))  // simple_stmts
        )
        {
            D(fprintf(stderr, "%*c+ statement[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmts"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_stmts"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// statement_newline: compound_stmt NEWLINE | simple_stmts | NEWLINE | $
static asdl_stmt_seq*
statement_newline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // compound_stmt NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "compound_stmt NEWLINE"));
        stmt_ty a;
        Token * newline_var;
        if (
            (a = compound_stmt_rule(p))  // compound_stmt
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "compound_stmt NEWLINE"));
            _res = ( asdl_stmt_seq* ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "compound_stmt NEWLINE"));
    }
    { // simple_stmts
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmts"));
        asdl_stmt_seq* simple_stmts_var;
        if (
            (simple_stmts_var = simple_stmts_rule(p))  // simple_stmts
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmts"));
            _res = simple_stmts_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_stmts"));
    }
    { // NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE"));
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = ( asdl_stmt_seq* ) _PyPegen_singleton_seq ( p , CHECK ( stmt_ty , _PyAST_Pass ( EXTRA ) ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NEWLINE"));
    }
    { // $
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_newline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "$"));
        Token * endmarker_var;
        if (
            (endmarker_var = _PyPegen_expect_token(p, ENDMARKER))  // token='ENDMARKER'
        )
        {
            D(fprintf(stderr, "%*c+ statement_newline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "$"));
            _res = _PyPegen_interactive_exit ( p );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_newline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "$"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// simple_stmts: simple_stmts_nonewline NEWLINE
static asdl_stmt_seq*
simple_stmts_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // simple_stmts_nonewline NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmts[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmts_nonewline NEWLINE"));
        asdl_stmt_seq* a;
        Token * newline_var;
        if (
            (a = simple_stmts_nonewline_rule(p))  // simple_stmts_nonewline
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmts[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmts_nonewline NEWLINE"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmts[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_stmts_nonewline NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// simple_stmt_complex: simple_stmt | parenthesized_stmt_nonewline
static asdl_stmt_seq*
simple_stmt_complex_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // simple_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt_complex[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmt"));
        stmt_ty a;
        if (
            (a = simple_stmt_rule(p))  // simple_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt_complex[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmt"));
            _res = ( asdl_stmt_seq* ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt_complex[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_stmt"));
    }
    { // parenthesized_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt_complex[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "parenthesized_stmt_nonewline"));
        asdl_stmt_seq* parenthesized_stmt_nonewline_var;
        if (
            (parenthesized_stmt_nonewline_var = parenthesized_stmt_nonewline_rule(p))  // parenthesized_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt_complex[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "parenthesized_stmt_nonewline"));
            _res = parenthesized_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt_complex[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "parenthesized_stmt_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// simple_stmt:
//     | assignment
//     | &"type" type_alias
//     | &"label" label_stmt
//     | star_expressions
//     | &'return' ('return' del_kw_stmt | return_stmt)
//     | &('import' | 'from') import_stmt
//     | &'raise' raise_stmt
//     | 'pass'
//     | &'del' (del_kw_stmt | del_stmt)
//     | &'yield' yield_stmt
//     | &'assert' assert_stmt
//     | 'break'
//     | 'continue'
//     | &'global' global_stmt
//     | &'nonlocal' nonlocal_stmt
//     | &'goto' goto_stmt
static stmt_ty
simple_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    if (_PyPegen_is_memoized(p, simple_stmt_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // assignment
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment"));
        stmt_ty assignment_var;
        if (
            (assignment_var = assignment_rule(p))  // assignment
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment"));
            _res = assignment_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "assignment"));
    }
    { // &"type" type_alias
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"type\" type_alias"));
        stmt_ty type_alias_var;
        if (
            _PyPegen_lookahead_with_string(1, _PyPegen_expect_soft_keyword, p, "type")
            &&
            (type_alias_var = type_alias_rule(p))  // type_alias
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"type\" type_alias"));
            _res = type_alias_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&\"type\" type_alias"));
    }
    { // &"label" label_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"label\" label_stmt"));
        stmt_ty label_stmt_var;
        if (
            _PyPegen_lookahead_with_string(1, _PyPegen_expect_soft_keyword, p, "label")
            &&
            (label_stmt_var = label_stmt_rule(p))  // label_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"label\" label_stmt"));
            _res = label_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&\"label\" label_stmt"));
    }
    { // star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expressions"));
        expr_ty e;
        if (
            (e = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expressions"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Expr ( e , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_expressions"));
    }
    { // &'return' ('return' del_kw_stmt | return_stmt)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'return' ('return' del_kw_stmt | return_stmt)"));
        void *_tmp_5_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 567)  // token='return'
            &&
            (_tmp_5_var = _tmp_5_rule(p))  // 'return' del_kw_stmt | return_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'return' ('return' del_kw_stmt | return_stmt)"));
            _res = _tmp_5_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'return' ('return' del_kw_stmt | return_stmt)"));
    }
    { // &('import' | 'from') import_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('import' | 'from') import_stmt"));
        stmt_ty import_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_6_rule, p)
            &&
            (import_stmt_var = import_stmt_rule(p))  // import_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('import' | 'from') import_stmt"));
            _res = import_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&('import' | 'from') import_stmt"));
    }
    { // &'raise' raise_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'raise' raise_stmt"));
        stmt_ty raise_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 566)  // token='raise'
            &&
            (raise_stmt_var = raise_stmt_rule(p))  // raise_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'raise' raise_stmt"));
            _res = raise_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'raise' raise_stmt"));
    }
    { // 'pass'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'pass'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 565))  // token='pass'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'pass'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Pass ( EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'pass'"));
    }
    { // &'del' (del_kw_stmt | del_stmt)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'del' (del_kw_stmt | del_stmt)"));
        void *_tmp_7_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 717)  // token='del'
            &&
            (_tmp_7_var = _tmp_7_rule(p))  // del_kw_stmt | del_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'del' (del_kw_stmt | del_stmt)"));
            _res = _tmp_7_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'del' (del_kw_stmt | del_stmt)"));
    }
    { // &'yield' yield_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'yield' yield_stmt"));
        stmt_ty yield_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 676)  // token='yield'
            &&
            (yield_stmt_var = yield_stmt_rule(p))  // yield_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'yield' yield_stmt"));
            _res = yield_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'yield' yield_stmt"));
    }
    { // &'assert' assert_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'assert' assert_stmt"));
        stmt_ty assert_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 573)  // token='assert'
            &&
            (assert_stmt_var = assert_stmt_rule(p))  // assert_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'assert' assert_stmt"));
            _res = assert_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'assert' assert_stmt"));
    }
    { // 'break'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'break'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 545))  // token='break'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'break'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Break ( EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'break'"));
    }
    { // 'continue'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'continue'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 547))  // token='continue'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'continue'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Continue ( EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'continue'"));
    }
    { // &'global' global_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'global' global_stmt"));
        stmt_ty global_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 555)  // token='global'
            &&
            (global_stmt_var = global_stmt_rule(p))  // global_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'global' global_stmt"));
            _res = global_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'global' global_stmt"));
    }
    { // &'nonlocal' nonlocal_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'nonlocal' nonlocal_stmt"));
        stmt_ty nonlocal_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 562)  // token='nonlocal'
            &&
            (nonlocal_stmt_var = nonlocal_stmt_rule(p))  // nonlocal_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'nonlocal' nonlocal_stmt"));
            _res = nonlocal_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'nonlocal' nonlocal_stmt"));
    }
    { // &'goto' goto_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'goto' goto_stmt"));
        stmt_ty goto_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 574)  // token='goto'
            &&
            (goto_stmt_var = goto_stmt_rule(p))  // goto_stmt
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'goto' goto_stmt"));
            _res = goto_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'goto' goto_stmt"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, simple_stmt_type, _res);
    p->level--;
    return _res;
}

// compound_stmt:
//     | &("def" | '@' | 'async') function_def
//     | &'if' if_stmt
//     | &':' unless_stmt
//     | &('class' | '@') class_def
//     | &('with' | 'async') with_stmt
//     | &('for' | 'async') for_stmt
//     | &'try' try_stmt
//     | &'while' while_stmt
//     | &"switch" switch_stmt
//     | match_stmt
//     | &"block" block_expr
//     | assignment_block
static stmt_ty
compound_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // &("def" | '@' | 'async') function_def
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&(\"def\" | '@' | 'async') function_def"));
        stmt_ty function_def_var;
        if (
            _PyPegen_lookahead(1, _tmp_8_rule, p)
            &&
            (function_def_var = function_def_rule(p))  // function_def
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&(\"def\" | '@' | 'async') function_def"));
            _res = function_def_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&(\"def\" | '@' | 'async') function_def"));
    }
    { // &'if' if_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'if' if_stmt"));
        stmt_ty if_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 772)  // token='if'
            &&
            (if_stmt_var = if_stmt_rule(p))  // if_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'if' if_stmt"));
            _res = if_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'if' if_stmt"));
    }
    { // &':' unless_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&':' unless_stmt"));
        stmt_ty unless_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
            &&
            (unless_stmt_var = unless_stmt_rule(p))  // unless_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&':' unless_stmt"));
            _res = unless_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&':' unless_stmt"));
    }
    { // &('class' | '@') class_def
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('class' | '@') class_def"));
        stmt_ty class_def_var;
        if (
            _PyPegen_lookahead(1, _tmp_9_rule, p)
            &&
            (class_def_var = class_def_rule(p))  // class_def
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('class' | '@') class_def"));
            _res = class_def_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&('class' | '@') class_def"));
    }
    { // &('with' | 'async') with_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('with' | 'async') with_stmt"));
        stmt_ty with_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_10_rule, p)
            &&
            (with_stmt_var = with_stmt_rule(p))  // with_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('with' | 'async') with_stmt"));
            _res = with_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&('with' | 'async') with_stmt"));
    }
    { // &('for' | 'async') for_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('for' | 'async') for_stmt"));
        stmt_ty for_stmt_var;
        if (
            _PyPegen_lookahead(1, _tmp_11_rule, p)
            &&
            (for_stmt_var = for_stmt_rule(p))  // for_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('for' | 'async') for_stmt"));
            _res = for_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&('for' | 'async') for_stmt"));
    }
    { // &'try' try_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'try' try_stmt"));
        stmt_ty try_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 751)  // token='try'
            &&
            (try_stmt_var = try_stmt_rule(p))  // try_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'try' try_stmt"));
            _res = try_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'try' try_stmt"));
    }
    { // &'while' while_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'while' while_stmt"));
        stmt_ty while_stmt_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 777)  // token='while'
            &&
            (while_stmt_var = while_stmt_rule(p))  // while_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'while' while_stmt"));
            _res = while_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'while' while_stmt"));
    }
    { // &"switch" switch_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"switch\" switch_stmt"));
        stmt_ty switch_stmt_var;
        if (
            _PyPegen_lookahead_with_string(1, _PyPegen_expect_soft_keyword, p, "switch")
            &&
            (switch_stmt_var = switch_stmt_rule(p))  // switch_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"switch\" switch_stmt"));
            _res = switch_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&\"switch\" switch_stmt"));
    }
    { // match_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "match_stmt"));
        stmt_ty match_stmt_var;
        if (
            (match_stmt_var = match_stmt_rule(p))  // match_stmt
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "match_stmt"));
            _res = match_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "match_stmt"));
    }
    { // &"block" block_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"block\" block_expr"));
        expr_ty a;
        if (
            _PyPegen_lookahead_with_string(1, _PyPegen_expect_soft_keyword, p, "block")
            &&
            (a = block_expr_rule(p))  // block_expr
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"block\" block_expr"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Expr ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&\"block\" block_expr"));
    }
    { // assignment_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_block"));
        stmt_ty assignment_block_var;
        if (
            (assignment_block_var = assignment_block_rule(p))  // assignment_block
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_block"));
            _res = assignment_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "assignment_block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// statements_nonewline: statement_nonewline+
static asdl_stmt_seq*
statements_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // statement_nonewline+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statements_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statement_nonewline+"));
        asdl_seq * a;
        if (
            (a = _loop1_12_rule(p))  // statement_nonewline+
        )
        {
            D(fprintf(stderr, "%*c+ statements_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statement_nonewline+"));
            _res = ( asdl_stmt_seq* ) _PyPegen_seq_flatten ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statements_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "statement_nonewline+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// parenthesized_stmt_nonewline: '(' statement_nonewline ')'
static asdl_stmt_seq*
parenthesized_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // '(' statement_nonewline ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> parenthesized_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' statement_nonewline ')'"));
        Token * _literal;
        Token * _literal_1;
        asdl_stmt_seq* a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = statement_nonewline_rule(p))  // statement_nonewline
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ parenthesized_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' statement_nonewline ')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s parenthesized_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' statement_nonewline ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// statement_nonewline: compound_stmt_nonewline | simple_stmts_nonewline
static asdl_stmt_seq*
statement_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    if (_PyPegen_is_memoized(p, statement_nonewline_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    { // compound_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "compound_stmt_nonewline"));
        stmt_ty a;
        if (
            (a = compound_stmt_nonewline_rule(p))  // compound_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ statement_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "compound_stmt_nonewline"));
            _res = ( asdl_stmt_seq* ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "compound_stmt_nonewline"));
    }
    { // simple_stmts_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> statement_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmts_nonewline"));
        asdl_stmt_seq* a;
        if (
            (a = (asdl_stmt_seq*)simple_stmts_nonewline_rule(p))  // simple_stmts_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ statement_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmts_nonewline"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s statement_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_stmts_nonewline"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, statement_nonewline_type, _res);
    p->level--;
    return _res;
}

// simple_stmts_nonewline:
//     | simple_stmt_complex !';'
//     | ';'.(';'.simple_stmt+ | parenthesized_stmt_nonewline)+ ';'?
static asdl_stmt_seq*
simple_stmts_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    if (_PyPegen_is_memoized(p, simple_stmts_nonewline_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    { // simple_stmt_complex !';'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmts_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmt_complex !';'"));
        asdl_stmt_seq* simple_stmt_complex_var;
        if (
            (simple_stmt_complex_var = simple_stmt_complex_rule(p))  // simple_stmt_complex
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 13)  // token=';'
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmts_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmt_complex !';'"));
            _res = simple_stmt_complex_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmts_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_stmt_complex !';'"));
    }
    { // ';'.(';'.simple_stmt+ | parenthesized_stmt_nonewline)+ ';'?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_stmts_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';'.(';'.simple_stmt+ | parenthesized_stmt_nonewline)+ ';'?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq * a;
        if (
            (a = _gather_13_rule(p))  // ';'.(';'.simple_stmt+ | parenthesized_stmt_nonewline)+
            &&
            (_opt_var = _PyPegen_expect_token(p, 13), !p->error_indicator)  // ';'?
        )
        {
            D(fprintf(stderr, "%*c+ simple_stmts_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';'.(';'.simple_stmt+ | parenthesized_stmt_nonewline)+ ';'?"));
            _res = ( asdl_stmt_seq* ) _PyPegen_seq_flatten ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_stmts_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "';'.(';'.simple_stmt+ | parenthesized_stmt_nonewline)+ ';'?"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, simple_stmts_nonewline_type, _res);
    p->level--;
    return _res;
}

// compound_stmt_nonewline:
//     | &'if' if_stmt_nonewline
//     | &':' unless_stmt_nonewline
//     | &('with' | 'async') with_stmt_nonewline
//     | &('for' | 'async') for_stmt_nonewline
//     | &'try' try_stmt_nonewline
//     | &'while' while_stmt_nonewline
//     | &"switch" switch_stmt_nonewline
//     | match_stmt_nonewline
//     | &"block" block_expr_nonewline
//     | assignment_block_nonewline
static stmt_ty
compound_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // &'if' if_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'if' if_stmt_nonewline"));
        stmt_ty if_stmt_nonewline_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 772)  // token='if'
            &&
            (if_stmt_nonewline_var = if_stmt_nonewline_rule(p))  // if_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'if' if_stmt_nonewline"));
            _res = if_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'if' if_stmt_nonewline"));
    }
    { // &':' unless_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&':' unless_stmt_nonewline"));
        stmt_ty unless_stmt_nonewline_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
            &&
            (unless_stmt_nonewline_var = unless_stmt_nonewline_rule(p))  // unless_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&':' unless_stmt_nonewline"));
            _res = unless_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&':' unless_stmt_nonewline"));
    }
    { // &('with' | 'async') with_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('with' | 'async') with_stmt_nonewline"));
        stmt_ty with_stmt_nonewline_var;
        if (
            _PyPegen_lookahead(1, _tmp_15_rule, p)
            &&
            (with_stmt_nonewline_var = with_stmt_nonewline_rule(p))  // with_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('with' | 'async') with_stmt_nonewline"));
            _res = with_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&('with' | 'async') with_stmt_nonewline"));
    }
    { // &('for' | 'async') for_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('for' | 'async') for_stmt_nonewline"));
        stmt_ty for_stmt_nonewline_var;
        if (
            _PyPegen_lookahead(1, _tmp_16_rule, p)
            &&
            (for_stmt_nonewline_var = for_stmt_nonewline_rule(p))  // for_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('for' | 'async') for_stmt_nonewline"));
            _res = for_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&('for' | 'async') for_stmt_nonewline"));
    }
    { // &'try' try_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'try' try_stmt_nonewline"));
        stmt_ty try_stmt_nonewline_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 751)  // token='try'
            &&
            (try_stmt_nonewline_var = try_stmt_nonewline_rule(p))  // try_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'try' try_stmt_nonewline"));
            _res = try_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'try' try_stmt_nonewline"));
    }
    { // &'while' while_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'while' while_stmt_nonewline"));
        stmt_ty while_stmt_nonewline_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 777)  // token='while'
            &&
            (while_stmt_nonewline_var = while_stmt_nonewline_rule(p))  // while_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'while' while_stmt_nonewline"));
            _res = while_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'while' while_stmt_nonewline"));
    }
    { // &"switch" switch_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"switch\" switch_stmt_nonewline"));
        stmt_ty switch_stmt_nonewline_var;
        if (
            _PyPegen_lookahead_with_string(1, _PyPegen_expect_soft_keyword, p, "switch")
            &&
            (switch_stmt_nonewline_var = switch_stmt_nonewline_rule(p))  // switch_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"switch\" switch_stmt_nonewline"));
            _res = switch_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&\"switch\" switch_stmt_nonewline"));
    }
    { // match_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "match_stmt_nonewline"));
        stmt_ty match_stmt_nonewline_var;
        if (
            (match_stmt_nonewline_var = match_stmt_nonewline_rule(p))  // match_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "match_stmt_nonewline"));
            _res = match_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "match_stmt_nonewline"));
    }
    { // &"block" block_expr_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"block\" block_expr_nonewline"));
        expr_ty a;
        if (
            _PyPegen_lookahead_with_string(1, _PyPegen_expect_soft_keyword, p, "block")
            &&
            (a = block_expr_nonewline_rule(p))  // block_expr_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"block\" block_expr_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Expr ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&\"block\" block_expr_nonewline"));
    }
    { // assignment_block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_block_nonewline"));
        stmt_ty assignment_block_nonewline_var;
        if (
            (assignment_block_nonewline_var = assignment_block_nonewline_rule(p))  // assignment_block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ compound_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_block_nonewline"));
            _res = assignment_block_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "assignment_block_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// assignment:
//     | NAME ':' expression ['=' top_rhs]
//     | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' top_rhs]
//     | ((star_targets '='))+ top_rhs !'=' TYPE_COMMENT?
//     | single_target ('|>=') ~ (top_rhs?)
//     | single_target unarassign &(';' | NEWLINE)
//     | single_target augassign ~ top_rhs
//     | invalid_assignment
static stmt_ty
assignment_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME ':' expression ['=' top_rhs]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME ':' expression ['=' top_rhs]"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        void *c;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
            &&
            (c = _tmp_17_rule(p), !p->error_indicator)  // ['=' top_rhs]
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME ':' expression ['=' top_rhs]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 6 , "Variable annotation syntax is" , _PyAST_AnnAssign ( CHECK ( expr_ty , _PyPegen_set_expr_context ( p , a , Store ) ) , b , c , 1 , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME ':' expression ['=' top_rhs]"));
    }
    { // ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' top_rhs]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' top_rhs]"));
        Token * _literal;
        void *a;
        expr_ty b;
        void *c;
        if (
            (a = _tmp_18_rule(p))  // '(' single_target ')' | single_subscript_attribute_target
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
            &&
            (c = _tmp_19_rule(p), !p->error_indicator)  // ['=' top_rhs]
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' top_rhs]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 6 , "Variable annotations syntax is" , _PyAST_AnnAssign ( a , b , c , 0 , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' top_rhs]"));
    }
    { // ((star_targets '='))+ top_rhs !'=' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((star_targets '='))+ top_rhs !'=' TYPE_COMMENT?"));
        asdl_expr_seq* a;
        expr_ty b;
        void *tc;
        if (
            (a = (asdl_expr_seq*)_loop1_20_rule(p))  // ((star_targets '='))+
            &&
            (b = top_rhs_rule(p))  // top_rhs
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 22)  // token='='
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((star_targets '='))+ top_rhs !'=' TYPE_COMMENT?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Assign ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "((star_targets '='))+ top_rhs !'=' TYPE_COMMENT?"));
    }
    { // single_target ('|>=') ~ (top_rhs?)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target ('|>=') ~ (top_rhs?)"));
        int _cut_var = 0;
        expr_ty a;
        void *c;
        void *t;
        if (
            (a = single_target_rule(p))  // single_target
            &&
            (t = _tmp_21_rule(p))  // '|>='
            &&
            (_cut_var = 1)
            &&
            (c = _tmp_22_rule(p))  // top_rhs?
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target ('|>=') ~ (top_rhs?)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_AugAssign ( a , Comp , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "single_target ('|>=') ~ (top_rhs?)"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // single_target unarassign &(';' | NEWLINE)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target unarassign &(';' | NEWLINE)"));
        expr_ty a;
        AugOperator* b;
        if (
            (a = single_target_rule(p))  // single_target
            &&
            (b = unarassign_rule(p))  // unarassign
            &&
            _PyPegen_lookahead(1, _tmp_23_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target unarassign &(';' | NEWLINE)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_AugAssign ( a , b -> kind , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "single_target unarassign &(';' | NEWLINE)"));
    }
    { // single_target augassign ~ top_rhs
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target augassign ~ top_rhs"));
        int _cut_var = 0;
        expr_ty a;
        AugOperator* b;
        expr_ty c;
        if (
            (a = single_target_rule(p))  // single_target
            &&
            (b = augassign_rule(p))  // augassign
            &&
            (_cut_var = 1)
            &&
            (c = top_rhs_rule(p))  // top_rhs
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target augassign ~ top_rhs"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_AugAssign ( a , b -> kind , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "single_target augassign ~ top_rhs"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    if (p->call_invalid_rules) { // invalid_assignment
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_assignment"));
        void *invalid_assignment_var;
        if (
            (invalid_assignment_var = invalid_assignment_rule(p))  // invalid_assignment
        )
        {
            D(fprintf(stderr, "%*c+ assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_assignment"));
            _res = invalid_assignment_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_assignment"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// top_rhs: yield_expr | star_expressions
static expr_ty
top_rhs_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // yield_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> top_rhs[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "yield_expr"));
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))  // yield_expr
        )
        {
            D(fprintf(stderr, "%*c+ top_rhs[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "yield_expr"));
            _res = yield_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s top_rhs[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "yield_expr"));
    }
    { // star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> top_rhs[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expressions"));
        expr_ty star_expressions_var;
        if (
            (star_expressions_var = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ top_rhs[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expressions"));
            _res = star_expressions_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s top_rhs[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// augassign:
//     | '+='
//     | '-='
//     | '*='
//     | '@='
//     | '/='
//     | '%='
//     | '&='
//     | '|='
//     | '^='
//     | '<<='
//     | '>>='
//     | '**='
//     | '//='
//     | '|>='
//     | '??='
static AugOperator*
augassign_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    AugOperator* _res = NULL;
    int _mark = p->mark;
    { // '+='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 36))  // token='+='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+='"));
            _res = _PyPegen_augoperator ( p , Add );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'+='"));
    }
    { // '-='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 37))  // token='-='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-='"));
            _res = _PyPegen_augoperator ( p , Sub );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'-='"));
    }
    { // '*='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 38))  // token='*='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*='"));
            _res = _PyPegen_augoperator ( p , Mult );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*='"));
    }
    { // '@='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 50))  // token='@='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@='"));
            _res = CHECK_VERSION ( AugOperator* , 5 , "The '@' operator is" , _PyPegen_augoperator ( p , MatMult ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'@='"));
    }
    { // '/='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'/='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 39))  // token='/='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'/='"));
            _res = _PyPegen_augoperator ( p , Div );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'/='"));
    }
    { // '%='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'%='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 40))  // token='%='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'%='"));
            _res = _PyPegen_augoperator ( p , Mod );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'%='"));
    }
    { // '&='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'&='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 41))  // token='&='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'&='"));
            _res = _PyPegen_augoperator ( p , BitAnd );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'&='"));
    }
    { // '|='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 42))  // token='|='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|='"));
            _res = _PyPegen_augoperator ( p , BitOr );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|='"));
    }
    { // '^='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'^='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 43))  // token='^='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'^='"));
            _res = _PyPegen_augoperator ( p , BitXor );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'^='"));
    }
    { // '<<='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'<<='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 44))  // token='<<='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'<<='"));
            _res = _PyPegen_augoperator ( p , LShift );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'<<='"));
    }
    { // '>>='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'>>='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 45))  // token='>>='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'>>='"));
            _res = _PyPegen_augoperator ( p , RShift );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'>>='"));
    }
    { // '**='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 46))  // token='**='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**='"));
            _res = _PyPegen_augoperator ( p , Pow );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**='"));
    }
    { // '//='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'//='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 48))  // token='//='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'//='"));
            _res = _PyPegen_augoperator ( p , FloorDiv );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'//='"));
    }
    { // '|>='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|>='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 57))  // token='|>='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|>='"));
            _res = _PyPegen_augoperator ( p , Comp );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|>='"));
    }
    { // '??='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> augassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'??='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 60))  // token='??='
        )
        {
            D(fprintf(stderr, "%*c+ augassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'??='"));
            _res = _PyPegen_augoperator ( p , Clsc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s augassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'??='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// unarassign: ('+=' | '+' '=') | ('-=' | '-' '=') | '~' '=' | ('!=' | '!' '=')
static AugOperator*
unarassign_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    AugOperator* _res = NULL;
    int _mark = p->mark;
    { // ('+=' | '+' '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> unarassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('+=' | '+' '=')"));
        void *_tmp_24_var;
        if (
            (_tmp_24_var = _tmp_24_rule(p))  // '+=' | '+' '='
        )
        {
            D(fprintf(stderr, "%*c+ unarassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('+=' | '+' '=')"));
            _res = _PyPegen_augoperator ( p , ( operator_ty ) UAdd );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s unarassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('+=' | '+' '=')"));
    }
    { // ('-=' | '-' '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> unarassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('-=' | '-' '=')"));
        void *_tmp_25_var;
        if (
            (_tmp_25_var = _tmp_25_rule(p))  // '-=' | '-' '='
        )
        {
            D(fprintf(stderr, "%*c+ unarassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('-=' | '-' '=')"));
            _res = _PyPegen_augoperator ( p , ( operator_ty ) USub );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s unarassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('-=' | '-' '=')"));
    }
    { // '~' '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> unarassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'~' '='"));
        Token * _literal;
        Token * _literal_1;
        if (
            (_literal = _PyPegen_expect_token(p, 31))  // token='~'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ unarassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'~' '='"));
            _res = _PyPegen_augoperator ( p , ( operator_ty ) Invert );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s unarassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'~' '='"));
    }
    { // ('!=' | '!' '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> unarassign[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('!=' | '!' '=')"));
        void *_tmp_26_var;
        if (
            (_tmp_26_var = _tmp_26_rule(p))  // '!=' | '!' '='
        )
        {
            D(fprintf(stderr, "%*c+ unarassign[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('!=' | '!' '=')"));
            _res = _PyPegen_augoperator ( p , ( operator_ty ) Not );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s unarassign[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('!=' | '!' '=')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// return_stmt: 'return' star_expressions?
static stmt_ty
return_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'return' star_expressions?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> return_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'return' star_expressions?"));
        Token * _keyword;
        void *a;
        if (
            (_keyword = _PyPegen_expect_token(p, 567))  // token='return'
            &&
            (a = star_expressions_rule(p), !p->error_indicator)  // star_expressions?
        )
        {
            D(fprintf(stderr, "%*c+ return_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'return' star_expressions?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Return ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s return_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'return' star_expressions?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// raise_stmt: 'raise' expression ['from' expression] | 'raise'
static stmt_ty
raise_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'raise' expression ['from' expression]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> raise_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'raise' expression ['from' expression]"));
        Token * _keyword;
        expr_ty a;
        void *b;
        if (
            (_keyword = _PyPegen_expect_token(p, 566))  // token='raise'
            &&
            (a = expression_rule(p))  // expression
            &&
            (b = _tmp_27_rule(p), !p->error_indicator)  // ['from' expression]
        )
        {
            D(fprintf(stderr, "%*c+ raise_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'raise' expression ['from' expression]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Raise ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s raise_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'raise' expression ['from' expression]"));
    }
    { // 'raise'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> raise_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'raise'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 566))  // token='raise'
        )
        {
            D(fprintf(stderr, "%*c+ raise_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'raise'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Raise ( NULL , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s raise_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'raise'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// global_stmt: 'global' ','.NAME+
static stmt_ty
global_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'global' ','.NAME+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> global_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'global' ','.NAME+"));
        Token * _keyword;
        asdl_expr_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 555))  // token='global'
            &&
            (a = (asdl_expr_seq*)_gather_28_rule(p))  // ','.NAME+
        )
        {
            D(fprintf(stderr, "%*c+ global_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'global' ','.NAME+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Global ( CHECK ( asdl_identifier_seq* , _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s global_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'global' ','.NAME+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// nonlocal_stmt: 'nonlocal' ','.NAME+
static stmt_ty
nonlocal_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'nonlocal' ','.NAME+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> nonlocal_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'nonlocal' ','.NAME+"));
        Token * _keyword;
        asdl_expr_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 562))  // token='nonlocal'
            &&
            (a = (asdl_expr_seq*)_gather_30_rule(p))  // ','.NAME+
        )
        {
            D(fprintf(stderr, "%*c+ nonlocal_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'nonlocal' ','.NAME+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Nonlocal ( CHECK ( asdl_identifier_seq* , _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s nonlocal_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'nonlocal' ','.NAME+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// del_kw_stmt:
//     | 'del' ('False' | 'None' | 'True' | 'and' | 'as' | 'assert' | 'async' | 'await' | 'break' | 'class' | 'continue' | 'del' | 'elif' | 'else' | 'except' | 'finally' | 'for' | 'from' | 'global' | 'goto' | 'if' | 'import' | 'in' | 'is' | 'lambda' | 'nonlocal' | 'not' | 'or' | 'pass' | 'raise' | 'return' | 'try' | 'while' | 'with' | 'yield')
static stmt_ty
del_kw_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'del' ('False' | 'None' | 'True' | 'and' | 'as' | 'assert' | 'async' | 'await' | 'break' | 'class' | 'continue' | 'del' | 'elif' | 'else' | 'except' | 'finally' | 'for' | 'from' | 'global' | 'goto' | 'if' | 'import' | 'in' | 'is' | 'lambda' | 'nonlocal' | 'not' | 'or' | 'pass' | 'raise' | 'return' | 'try' | 'while' | 'with' | 'yield')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_kw_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'del' ('False' | 'None' | 'True' | 'and' | 'as' | 'assert' | 'async' | 'await' | 'break' | 'class' | 'continue' | 'del' | 'elif' | 'else' | 'except' | 'finally' | 'for' | 'from' | 'global' | 'goto' | 'if' | 'import' | 'in' | 'is' | 'lambda' | 'nonlocal' | 'not' | 'or' | 'pass' | 'raise' | 'return' | 'try' | 'while' | 'with' | 'yield')"));
        Token * _keyword;
        Token* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 717))  // token='del'
            &&
            (a = (Token*)_tmp_32_rule(p))  // 'False' | 'None' | 'True' | 'and' | 'as' | 'assert' | 'async' | 'await' | 'break' | 'class' | 'continue' | 'del' | 'elif' | 'else' | 'except' | 'finally' | 'for' | 'from' | 'global' | 'goto' | 'if' | 'import' | 'in' | 'is' | 'lambda' | 'nonlocal' | 'not' | 'or' | 'pass' | 'raise' | 'return' | 'try' | 'while' | 'with' | 'yield'
        )
        {
            D(fprintf(stderr, "%*c+ del_kw_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'del' ('False' | 'None' | 'True' | 'and' | 'as' | 'assert' | 'async' | 'await' | 'break' | 'class' | 'continue' | 'del' | 'elif' | 'else' | 'except' | 'finally' | 'for' | 'from' | 'global' | 'goto' | 'if' | 'import' | 'in' | 'is' | 'lambda' | 'nonlocal' | 'not' | 'or' | 'pass' | 'raise' | 'return' | 'try' | 'while' | 'with' | 'yield')"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_add_restricted ( p , a ) ? _PyAST_Pass ( EXTRA ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_kw_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'del' ('False' | 'None' | 'True' | 'and' | 'as' | 'assert' | 'async' | 'await' | 'break' | 'class' | 'continue' | 'del' | 'elif' | 'else' | 'except' | 'finally' | 'for' | 'from' | 'global' | 'goto' | 'if' | 'import' | 'in' | 'is' | 'lambda' | 'nonlocal' | 'not' | 'or' | 'pass' | 'raise' | 'return' | 'try' | 'while' | 'with' | 'yield')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// del_stmt: 'del' del_targets &(';' | NEWLINE) | invalid_del_stmt
static stmt_ty
del_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'del' del_targets &(';' | NEWLINE)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'del' del_targets &(';' | NEWLINE)"));
        Token * _keyword;
        asdl_expr_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 717))  // token='del'
            &&
            (a = del_targets_rule(p))  // del_targets
            &&
            _PyPegen_lookahead(1, _tmp_33_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ del_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'del' del_targets &(';' | NEWLINE)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Delete ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'del' del_targets &(';' | NEWLINE)"));
    }
    if (p->call_invalid_rules) { // invalid_del_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_del_stmt"));
        void *invalid_del_stmt_var;
        if (
            (invalid_del_stmt_var = invalid_del_stmt_rule(p))  // invalid_del_stmt
        )
        {
            D(fprintf(stderr, "%*c+ del_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_del_stmt"));
            _res = invalid_del_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_del_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// yield_stmt: yield_expr
static stmt_ty
yield_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // yield_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> yield_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "yield_expr"));
        expr_ty y;
        if (
            (y = yield_expr_rule(p))  // yield_expr
        )
        {
            D(fprintf(stderr, "%*c+ yield_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "yield_expr"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Expr ( y , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s yield_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "yield_expr"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// assert_stmt: 'assert' expression [',' expression]
static stmt_ty
assert_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'assert' expression [',' expression]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assert_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'assert' expression [',' expression]"));
        Token * _keyword;
        expr_ty a;
        void *b;
        if (
            (_keyword = _PyPegen_expect_token(p, 573))  // token='assert'
            &&
            (a = expression_rule(p))  // expression
            &&
            (b = _tmp_34_rule(p), !p->error_indicator)  // [',' expression]
        )
        {
            D(fprintf(stderr, "%*c+ assert_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'assert' expression [',' expression]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Assert ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assert_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'assert' expression [',' expression]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// goto_stmt: 'goto' NAME
static stmt_ty
goto_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'goto' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> goto_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'goto' NAME"));
        Token * _keyword;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 574))  // token='goto'
            &&
            (a = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ goto_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'goto' NAME"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Goto ( a -> v . Name . id , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s goto_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'goto' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// label_stmt: "label" ','.NAME+
static stmt_ty
label_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "label" ','.NAME+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> label_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"label\" ','.NAME+"));
        expr_ty _keyword;
        asdl_expr_seq* a;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "label"))  // soft_keyword='"label"'
            &&
            (a = (asdl_expr_seq*)_gather_35_rule(p))  // ','.NAME+
        )
        {
            D(fprintf(stderr, "%*c+ label_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"label\" ','.NAME+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Label ( CHECK ( asdl_identifier_seq* , _PyPegen_map_names_to_ids ( p , a ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s label_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"label\" ','.NAME+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_stmt: invalid_import | import_name | import_from
static stmt_ty
import_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_import
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_import"));
        void *invalid_import_var;
        if (
            (invalid_import_var = invalid_import_rule(p))  // invalid_import
        )
        {
            D(fprintf(stderr, "%*c+ import_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_import"));
            _res = invalid_import_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_import"));
    }
    { // import_name
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "import_name"));
        stmt_ty import_name_var;
        if (
            (import_name_var = import_name_rule(p))  // import_name
        )
        {
            D(fprintf(stderr, "%*c+ import_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "import_name"));
            _res = import_name_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "import_name"));
    }
    { // import_from
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "import_from"));
        stmt_ty import_from_var;
        if (
            (import_from_var = import_from_rule(p))  // import_from
        )
        {
            D(fprintf(stderr, "%*c+ import_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "import_from"));
            _res = import_from_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "import_from"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_name: 'import' dotted_as_names
static stmt_ty
import_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'import' dotted_as_names
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_name[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'import' dotted_as_names"));
        Token * _keyword;
        asdl_alias_seq* a;
        if (
            (_keyword = _PyPegen_expect_token(p, 721))  // token='import'
            &&
            (a = dotted_as_names_rule(p))  // dotted_as_names
        )
        {
            D(fprintf(stderr, "%*c+ import_name[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'import' dotted_as_names"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Import ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_name[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'import' dotted_as_names"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from:
//     | 'from' (('.' | '...'))* dotted_name 'import' import_from_targets
//     | 'from' (('.' | '...'))+ 'import' import_from_targets
static stmt_ty
import_from_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'from' (('.' | '...'))* dotted_name 'import' import_from_targets
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'from' (('.' | '...'))* dotted_name 'import' import_from_targets"));
        Token * _keyword;
        Token * _keyword_1;
        asdl_seq * a;
        expr_ty b;
        asdl_alias_seq* c;
        if (
            (_keyword = _PyPegen_expect_token(p, 722))  // token='from'
            &&
            (a = _loop0_37_rule(p))  // (('.' | '...'))*
            &&
            (b = dotted_name_rule(p))  // dotted_name
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 721))  // token='import'
            &&
            (c = import_from_targets_rule(p))  // import_from_targets
        )
        {
            D(fprintf(stderr, "%*c+ import_from[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'from' (('.' | '...'))* dotted_name 'import' import_from_targets"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_barry_import ( p , _PyAST_ImportFrom ( b -> v . Name . id , c , _PyPegen_seq_count_dots ( a ) , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'from' (('.' | '...'))* dotted_name 'import' import_from_targets"));
    }
    { // 'from' (('.' | '...'))+ 'import' import_from_targets
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'from' (('.' | '...'))+ 'import' import_from_targets"));
        Token * _keyword;
        Token * _keyword_1;
        asdl_seq * a;
        asdl_alias_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 722))  // token='from'
            &&
            (a = _loop1_38_rule(p))  // (('.' | '...'))+
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 721))  // token='import'
            &&
            (b = import_from_targets_rule(p))  // import_from_targets
        )
        {
            D(fprintf(stderr, "%*c+ import_from[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'from' (('.' | '...'))+ 'import' import_from_targets"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ImportFrom ( NULL , b , _PyPegen_seq_count_dots ( a ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'from' (('.' | '...'))+ 'import' import_from_targets"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from_targets:
//     | '(' import_from_as_names ','? ')'
//     | import_from_as_names !','
//     | '*'
//     | invalid_import_from_targets
static asdl_alias_seq*
import_from_targets_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_alias_seq* _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '(' import_from_as_names ','? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' import_from_as_names ','? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_alias_seq* a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = import_from_as_names_rule(p))  // import_from_as_names
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' import_from_as_names ','? ')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' import_from_as_names ','? ')'"));
    }
    { // import_from_as_names !','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "import_from_as_names !','"));
        asdl_alias_seq* import_from_as_names_var;
        if (
            (import_from_as_names_var = import_from_as_names_rule(p))  // import_from_as_names
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "import_from_as_names !','"));
            _res = import_from_as_names_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "import_from_as_names !','"));
    }
    { // '*'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = ( asdl_alias_seq* ) _PyPegen_singleton_seq ( p , CHECK ( alias_ty , _PyPegen_alias_for_star ( p , EXTRA ) ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*'"));
    }
    if (p->call_invalid_rules) { // invalid_import_from_targets
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_targets[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_import_from_targets"));
        void *invalid_import_from_targets_var;
        if (
            (invalid_import_from_targets_var = invalid_import_from_targets_rule(p))  // invalid_import_from_targets
        )
        {
            D(fprintf(stderr, "%*c+ import_from_targets[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_import_from_targets"));
            _res = invalid_import_from_targets_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_targets[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_import_from_targets"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from_as_names: ','.import_from_as_name+
static asdl_alias_seq*
import_from_as_names_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_alias_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.import_from_as_name+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_as_names[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.import_from_as_name+"));
        asdl_alias_seq* a;
        if (
            (a = (asdl_alias_seq*)_gather_39_rule(p))  // ','.import_from_as_name+
        )
        {
            D(fprintf(stderr, "%*c+ import_from_as_names[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.import_from_as_name+"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_as_names[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.import_from_as_name+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// import_from_as_name: NAME ['as' NAME]
static alias_ty
import_from_as_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    alias_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME ['as' NAME]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> import_from_as_name[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME ['as' NAME]"));
        expr_ty a;
        void *b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = _tmp_41_rule(p), !p->error_indicator)  // ['as' NAME]
        )
        {
            D(fprintf(stderr, "%*c+ import_from_as_name[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME ['as' NAME]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s import_from_as_name[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME ['as' NAME]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// dotted_as_names: ','.dotted_as_name+
static asdl_alias_seq*
dotted_as_names_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_alias_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.dotted_as_name+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_as_names[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.dotted_as_name+"));
        asdl_alias_seq* a;
        if (
            (a = (asdl_alias_seq*)_gather_42_rule(p))  // ','.dotted_as_name+
        )
        {
            D(fprintf(stderr, "%*c+ dotted_as_names[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.dotted_as_name+"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_as_names[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.dotted_as_name+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// dotted_as_name: dotted_name ['as' NAME]
static alias_ty
dotted_as_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    alias_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // dotted_name ['as' NAME]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_as_name[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dotted_name ['as' NAME]"));
        expr_ty a;
        void *b;
        if (
            (a = dotted_name_rule(p))  // dotted_name
            &&
            (b = _tmp_44_rule(p), !p->error_indicator)  // ['as' NAME]
        )
        {
            D(fprintf(stderr, "%*c+ dotted_as_name[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dotted_name ['as' NAME]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_alias ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Name . id : NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_as_name[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "dotted_name ['as' NAME]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// dotted_name: dotted_name '.' NAME | NAME
static expr_ty dotted_name_raw(Parser *);
static expr_ty
dotted_name_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, dotted_name_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_0 = _PyPegen_update_memo(p, _mark, dotted_name_type, _res);
        if (tmpvar_0) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = dotted_name_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
dotted_name_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // dotted_name '.' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_name[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dotted_name '.' NAME"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = dotted_name_rule(p))  // dotted_name
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ dotted_name[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dotted_name '.' NAME"));
            _res = _PyPegen_join_names_with_dot ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_name[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "dotted_name '.' NAME"));
    }
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dotted_name[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
        expr_ty name_var;
        if (
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ dotted_name[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
            _res = name_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dotted_name[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// assignment_block:
//     | NAME ':' expression ['=' block_expr]
//     | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' block_expr]
//     | ((star_targets '='))+ block_expr !'=' TYPE_COMMENT?
//     | single_target ('|>=') ~ (block_expr?)
//     | single_target augassign block_expr
static stmt_ty
assignment_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME ':' expression ['=' block_expr]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME ':' expression ['=' block_expr]"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        void *c;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
            &&
            (c = _tmp_45_rule(p), !p->error_indicator)  // ['=' block_expr]
        )
        {
            D(fprintf(stderr, "%*c+ assignment_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME ':' expression ['=' block_expr]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 6 , "Variable annotation syntax is" , _PyAST_AnnAssign ( CHECK ( expr_ty , _PyPegen_set_expr_context ( p , a , Store ) ) , b , c , 1 , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME ':' expression ['=' block_expr]"));
    }
    { // ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' block_expr]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' block_expr]"));
        Token * _literal;
        void *a;
        expr_ty b;
        void *c;
        if (
            (a = _tmp_46_rule(p))  // '(' single_target ')' | single_subscript_attribute_target
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
            &&
            (c = _tmp_47_rule(p), !p->error_indicator)  // ['=' block_expr]
        )
        {
            D(fprintf(stderr, "%*c+ assignment_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' block_expr]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 6 , "Variable annotations syntax is" , _PyAST_AnnAssign ( a , b , c , 0 , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' block_expr]"));
    }
    { // ((star_targets '='))+ block_expr !'=' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((star_targets '='))+ block_expr !'=' TYPE_COMMENT?"));
        asdl_expr_seq* a;
        expr_ty b;
        void *tc;
        if (
            (a = (asdl_expr_seq*)_loop1_48_rule(p))  // ((star_targets '='))+
            &&
            (b = block_expr_rule(p))  // block_expr
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 22)  // token='='
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ assignment_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((star_targets '='))+ block_expr !'=' TYPE_COMMENT?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Assign ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "((star_targets '='))+ block_expr !'=' TYPE_COMMENT?"));
    }
    { // single_target ('|>=') ~ (block_expr?)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target ('|>=') ~ (block_expr?)"));
        int _cut_var = 0;
        expr_ty a;
        void *c;
        void *t;
        if (
            (a = single_target_rule(p))  // single_target
            &&
            (t = _tmp_49_rule(p))  // '|>='
            &&
            (_cut_var = 1)
            &&
            (c = _tmp_50_rule(p))  // block_expr?
        )
        {
            D(fprintf(stderr, "%*c+ assignment_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target ('|>=') ~ (block_expr?)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_AugAssign ( a , Comp , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "single_target ('|>=') ~ (block_expr?)"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // single_target augassign block_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target augassign block_expr"));
        expr_ty a;
        AugOperator* b;
        expr_ty c;
        if (
            (a = single_target_rule(p))  // single_target
            &&
            (b = augassign_rule(p))  // augassign
            &&
            (c = block_expr_rule(p))  // block_expr
        )
        {
            D(fprintf(stderr, "%*c+ assignment_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target augassign block_expr"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_AugAssign ( a , b -> kind , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "single_target augassign block_expr"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// assignment_block_nonewline:
//     | NAME ':' expression ['=' block_expr_nonewline]
//     | ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' block_expr_nonewline]
//     | ((star_targets '='))+ block_expr_nonewline !'=' TYPE_COMMENT?
//     | single_target ('|>=') ~ (block_expr_nonewline?)
//     | single_target augassign block_expr_nonewline
static stmt_ty
assignment_block_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME ':' expression ['=' block_expr_nonewline]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME ':' expression ['=' block_expr_nonewline]"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        void *c;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
            &&
            (c = _tmp_51_rule(p), !p->error_indicator)  // ['=' block_expr_nonewline]
        )
        {
            D(fprintf(stderr, "%*c+ assignment_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME ':' expression ['=' block_expr_nonewline]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 6 , "Variable annotation syntax is" , _PyAST_AnnAssign ( CHECK ( expr_ty , _PyPegen_set_expr_context ( p , a , Store ) ) , b , c , 1 , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME ':' expression ['=' block_expr_nonewline]"));
    }
    { // ('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' block_expr_nonewline]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' block_expr_nonewline]"));
        Token * _literal;
        void *a;
        expr_ty b;
        void *c;
        if (
            (a = _tmp_52_rule(p))  // '(' single_target ')' | single_subscript_attribute_target
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
            &&
            (c = _tmp_53_rule(p), !p->error_indicator)  // ['=' block_expr_nonewline]
        )
        {
            D(fprintf(stderr, "%*c+ assignment_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' block_expr_nonewline]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 6 , "Variable annotations syntax is" , _PyAST_AnnAssign ( a , b , c , 0 , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('(' single_target ')' | single_subscript_attribute_target) ':' expression ['=' block_expr_nonewline]"));
    }
    { // ((star_targets '='))+ block_expr_nonewline !'=' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((star_targets '='))+ block_expr_nonewline !'=' TYPE_COMMENT?"));
        asdl_expr_seq* a;
        expr_ty b;
        void *tc;
        if (
            (a = (asdl_expr_seq*)_loop1_54_rule(p))  // ((star_targets '='))+
            &&
            (b = block_expr_nonewline_rule(p))  // block_expr_nonewline
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 22)  // token='='
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ assignment_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((star_targets '='))+ block_expr_nonewline !'=' TYPE_COMMENT?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Assign ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "((star_targets '='))+ block_expr_nonewline !'=' TYPE_COMMENT?"));
    }
    { // single_target ('|>=') ~ (block_expr_nonewline?)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target ('|>=') ~ (block_expr_nonewline?)"));
        int _cut_var = 0;
        expr_ty a;
        void *c;
        void *t;
        if (
            (a = single_target_rule(p))  // single_target
            &&
            (t = _tmp_55_rule(p))  // '|>='
            &&
            (_cut_var = 1)
            &&
            (c = _tmp_56_rule(p))  // block_expr_nonewline?
        )
        {
            D(fprintf(stderr, "%*c+ assignment_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target ('|>=') ~ (block_expr_nonewline?)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_AugAssign ( a , Comp , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "single_target ('|>=') ~ (block_expr_nonewline?)"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // single_target augassign block_expr_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target augassign block_expr_nonewline"));
        expr_ty a;
        AugOperator* b;
        expr_ty c;
        if (
            (a = single_target_rule(p))  // single_target
            &&
            (b = augassign_rule(p))  // augassign
            &&
            (c = block_expr_nonewline_rule(p))  // block_expr_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ assignment_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_target augassign block_expr_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_AugAssign ( a , b -> kind , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "single_target augassign block_expr_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// block_entry: ':' block | braced_block
static asdl_stmt_seq*
block_entry_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // ':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block_entry[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' block"));
        Token * _literal;
        asdl_stmt_seq* a;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (a = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ block_entry[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' block"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block_entry[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':' block"));
    }
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block_entry[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ block_entry[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block_entry[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// block_entry_nonewline: ':' block_nonewline | braced_block
static asdl_stmt_seq*
block_entry_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // ':' block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block_entry_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' block_nonewline"));
        Token * _literal;
        asdl_stmt_seq* a;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (a = block_nonewline_rule(p))  // block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ block_entry_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' block_nonewline"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block_entry_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':' block_nonewline"));
    }
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block_entry_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ block_entry_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block_entry_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// braced_block: ('{') block_nonewline '}'
static asdl_stmt_seq*
braced_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // ('{') block_nonewline '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> braced_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('{') block_nonewline '}'"));
        Token * _literal;
        void *_tmp_57_var;
        asdl_stmt_seq* a;
        if (
            (_tmp_57_var = _tmp_57_rule(p))  // '{'
            &&
            (a = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ braced_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('{') block_nonewline '}'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s braced_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('{') block_nonewline '}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// block: NEWLINE INDENT statements DEDENT | simple_stmts | invalid_block
static asdl_stmt_seq*
block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    if (_PyPegen_is_memoized(p, block_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    { // NEWLINE INDENT statements DEDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE INDENT statements DEDENT"));
        asdl_stmt_seq* a;
        Token * dedent_var;
        Token * indent_var;
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (indent_var = _PyPegen_expect_token(p, INDENT))  // token='INDENT'
            &&
            (a = statements_rule(p))  // statements
            &&
            (dedent_var = _PyPegen_expect_token(p, DEDENT))  // token='DEDENT'
        )
        {
            D(fprintf(stderr, "%*c+ block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE INDENT statements DEDENT"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NEWLINE INDENT statements DEDENT"));
    }
    { // simple_stmts
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmts"));
        asdl_stmt_seq* simple_stmts_var;
        if (
            (simple_stmts_var = simple_stmts_rule(p))  // simple_stmts
        )
        {
            D(fprintf(stderr, "%*c+ block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmts"));
            _res = simple_stmts_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_stmts"));
    }
    if (p->call_invalid_rules) { // invalid_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_block"));
        void *invalid_block_var;
        if (
            (invalid_block_var = invalid_block_rule(p))  // invalid_block
        )
        {
            D(fprintf(stderr, "%*c+ block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_block"));
            _res = invalid_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_block"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, block_type, _res);
    p->level--;
    return _res;
}

// block_nonewline: statements_nonewline
static asdl_stmt_seq*
block_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // statements_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statements_nonewline"));
        asdl_stmt_seq* statements_nonewline_var;
        if (
            (statements_nonewline_var = statements_nonewline_rule(p))  // statements_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statements_nonewline"));
            _res = statements_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "statements_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// decorators: (('@' named_expression NEWLINE))+
static asdl_expr_seq*
decorators_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_expr_seq* _res = NULL;
    int _mark = p->mark;
    { // (('@' named_expression NEWLINE))+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> decorators[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(('@' named_expression NEWLINE))+"));
        asdl_expr_seq* a;
        if (
            (a = (asdl_expr_seq*)_loop1_58_rule(p))  // (('@' named_expression NEWLINE))+
        )
        {
            D(fprintf(stderr, "%*c+ decorators[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(('@' named_expression NEWLINE))+"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s decorators[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(('@' named_expression NEWLINE))+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// class_def: decorators class_def_raw | class_def_raw
static stmt_ty
class_def_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    { // decorators class_def_raw
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_def[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "decorators class_def_raw"));
        asdl_expr_seq* a;
        stmt_ty b;
        if (
            (a = decorators_rule(p))  // decorators
            &&
            (b = class_def_raw_rule(p))  // class_def_raw
        )
        {
            D(fprintf(stderr, "%*c+ class_def[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "decorators class_def_raw"));
            _res = _PyPegen_class_def_decorators ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_def[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "decorators class_def_raw"));
    }
    { // class_def_raw
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_def[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "class_def_raw"));
        stmt_ty class_def_raw_var;
        if (
            (class_def_raw_var = class_def_raw_rule(p))  // class_def_raw
        )
        {
            D(fprintf(stderr, "%*c+ class_def[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "class_def_raw"));
            _res = class_def_raw_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_def[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "class_def_raw"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// class_def_raw:
//     | invalid_class_def_raw
//     | 'class' NAME type_params? ['(' arguments? ')'] block_entry
static stmt_ty
class_def_raw_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_class_def_raw
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_def_raw[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_class_def_raw"));
        void *invalid_class_def_raw_var;
        if (
            (invalid_class_def_raw_var = invalid_class_def_raw_rule(p))  // invalid_class_def_raw
        )
        {
            D(fprintf(stderr, "%*c+ class_def_raw[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_class_def_raw"));
            _res = invalid_class_def_raw_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_def_raw[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_class_def_raw"));
    }
    { // 'class' NAME type_params? ['(' arguments? ')'] block_entry
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_def_raw[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class' NAME type_params? ['(' arguments? ')'] block_entry"));
        Token * _keyword;
        expr_ty a;
        void *b;
        asdl_stmt_seq* c;
        void *t;
        if (
            (_keyword = _PyPegen_expect_token(p, 786))  // token='class'
            &&
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (t = type_params_rule(p), !p->error_indicator)  // type_params?
            &&
            (b = _tmp_59_rule(p), !p->error_indicator)  // ['(' arguments? ')']
            &&
            (c = block_entry_rule(p))  // block_entry
        )
        {
            D(fprintf(stderr, "%*c+ class_def_raw[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class' NAME type_params? ['(' arguments? ')'] block_entry"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ClassDef ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , c , NULL , t , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_def_raw[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'class' NAME type_params? ['(' arguments? ')'] block_entry"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// class_def_nonewline: decorators class_def_raw_nonewline | class_def_raw_nonewline
static stmt_ty
class_def_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    { // decorators class_def_raw_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_def_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "decorators class_def_raw_nonewline"));
        asdl_expr_seq* a;
        stmt_ty b;
        if (
            (a = decorators_rule(p))  // decorators
            &&
            (b = class_def_raw_nonewline_rule(p))  // class_def_raw_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ class_def_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "decorators class_def_raw_nonewline"));
            _res = _PyPegen_class_def_decorators ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_def_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "decorators class_def_raw_nonewline"));
    }
    { // class_def_raw_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_def_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "class_def_raw_nonewline"));
        stmt_ty class_def_raw_nonewline_var;
        if (
            (class_def_raw_nonewline_var = class_def_raw_nonewline_rule(p))  // class_def_raw_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ class_def_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "class_def_raw_nonewline"));
            _res = class_def_raw_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_def_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "class_def_raw_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// class_def_raw_nonewline:
//     | invalid_class_def_raw_nonewline
//     | 'class' NAME type_params? ['(' arguments? ')'] block_entry_nonewline
static stmt_ty
class_def_raw_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_class_def_raw_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_def_raw_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_class_def_raw_nonewline"));
        void *invalid_class_def_raw_nonewline_var;
        if (
            (invalid_class_def_raw_nonewline_var = invalid_class_def_raw_nonewline_rule(p))  // invalid_class_def_raw_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ class_def_raw_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_class_def_raw_nonewline"));
            _res = invalid_class_def_raw_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_def_raw_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_class_def_raw_nonewline"));
    }
    { // 'class' NAME type_params? ['(' arguments? ')'] block_entry_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_def_raw_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class' NAME type_params? ['(' arguments? ')'] block_entry_nonewline"));
        Token * _keyword;
        expr_ty a;
        void *b;
        asdl_stmt_seq* c;
        void *t;
        if (
            (_keyword = _PyPegen_expect_token(p, 786))  // token='class'
            &&
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (t = type_params_rule(p), !p->error_indicator)  // type_params?
            &&
            (b = _tmp_60_rule(p), !p->error_indicator)  // ['(' arguments? ')']
            &&
            (c = block_entry_nonewline_rule(p))  // block_entry_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ class_def_raw_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class' NAME type_params? ['(' arguments? ')'] block_entry_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ClassDef ( a -> v . Name . id , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , c , NULL , t , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_def_raw_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'class' NAME type_params? ['(' arguments? ')'] block_entry_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// function_def: decorators function_def_raw | function_def_raw
static stmt_ty
function_def_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    { // decorators function_def_raw
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "decorators function_def_raw"));
        asdl_expr_seq* d;
        stmt_ty f;
        if (
            (d = decorators_rule(p))  // decorators
            &&
            (f = function_def_raw_rule(p))  // function_def_raw
        )
        {
            D(fprintf(stderr, "%*c+ function_def[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "decorators function_def_raw"));
            _res = _PyPegen_function_def_decorators ( p , d , f );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "decorators function_def_raw"));
    }
    { // function_def_raw
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "function_def_raw"));
        stmt_ty function_def_raw_var;
        if (
            (function_def_raw_var = function_def_raw_rule(p))  // function_def_raw
        )
        {
            D(fprintf(stderr, "%*c+ function_def[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "function_def_raw"));
            _res = function_def_raw_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "function_def_raw"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// function_def_raw:
//     | invalid_def_raw
//     | "def" NAME type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'
//     | 'async' "def" NAME type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'
//     | "def" NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block
//     | 'async' "def" NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block
static stmt_ty
function_def_raw_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_def_raw
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_raw[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_def_raw"));
        void *invalid_def_raw_var;
        if (
            (invalid_def_raw_var = invalid_def_raw_rule(p))  // invalid_def_raw
        )
        {
            D(fprintf(stderr, "%*c+ function_def_raw[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_def_raw"));
            _res = invalid_def_raw_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_raw[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_def_raw"));
    }
    { // "def" NAME type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_raw[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\" NAME type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
        expr_ty _keyword;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        Token * _literal_3;
        void *a;
        asdl_stmt_seq* b;
        expr_ty n;
        void *params;
        void *t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "def"))  // soft_keyword='"def"'
            &&
            (n = _PyPegen_name_token(p))  // NAME
            &&
            (t = type_params_rule(p), !p->error_indicator)  // type_params?
            &&
            (_literal = _PyPegen_expect_forced_token(p, 7, "("))  // forced_token='('
            &&
            (params = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (a = _tmp_61_rule(p), !p->error_indicator)  // ['->' expression]
            &&
            (_literal_2 = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = func_type_comment_rule(p), !p->error_indicator)  // func_type_comment?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_3 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ function_def_raw[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\" NAME type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? _PyAST_FunctionDef ( n -> v . Name . id , ( params ) ? params : CHECK ( arguments_ty , _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , t , EXTRA ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_raw[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"def\" NAME type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
    }
    { // 'async' "def" NAME type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_raw[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
        Token * _keyword;
        expr_ty _keyword_1;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        Token * _literal_3;
        void *a;
        asdl_stmt_seq* b;
        expr_ty n;
        void *params;
        void *t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_soft_keyword(p, "def"))  // soft_keyword='"def"'
            &&
            (n = _PyPegen_name_token(p))  // NAME
            &&
            (t = type_params_rule(p), !p->error_indicator)  // type_params?
            &&
            (_literal = _PyPegen_expect_forced_token(p, 7, "("))  // forced_token='('
            &&
            (params = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (a = _tmp_62_rule(p), !p->error_indicator)  // ['->' expression]
            &&
            (_literal_2 = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = func_type_comment_rule(p), !p->error_indicator)  // func_type_comment?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_3 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ function_def_raw[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? CHECK_VERSION ( stmt_ty , 5 , "Async functions are" , _PyAST_AsyncFunctionDef ( n -> v . Name . id , ( params ) ? params : CHECK ( arguments_ty , _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , t , EXTRA ) ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_raw[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
    }
    { // "def" NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_raw[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\" NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block"));
        expr_ty _keyword;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *a;
        asdl_stmt_seq* b;
        expr_ty n;
        void *params;
        void *t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "def"))  // soft_keyword='"def"'
            &&
            (n = _PyPegen_name_token(p))  // NAME
            &&
            (t = type_params_rule(p), !p->error_indicator)  // type_params?
            &&
            (_literal = _PyPegen_expect_forced_token(p, 7, "("))  // forced_token='('
            &&
            (params = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (a = _tmp_63_rule(p), !p->error_indicator)  // ['->' expression]
            &&
            (_literal_2 = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (tc = func_type_comment_rule(p), !p->error_indicator)  // func_type_comment?
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ function_def_raw[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\" NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_FunctionDef ( n -> v . Name . id , ( params ) ? params : CHECK ( arguments_ty , _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , t , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_raw[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"def\" NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block"));
    }
    { // 'async' "def" NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_raw[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block"));
        Token * _keyword;
        expr_ty _keyword_1;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *a;
        asdl_stmt_seq* b;
        expr_ty n;
        void *params;
        void *t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_soft_keyword(p, "def"))  // soft_keyword='"def"'
            &&
            (n = _PyPegen_name_token(p))  // NAME
            &&
            (t = type_params_rule(p), !p->error_indicator)  // type_params?
            &&
            (_literal = _PyPegen_expect_forced_token(p, 7, "("))  // forced_token='('
            &&
            (params = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (a = _tmp_64_rule(p), !p->error_indicator)  // ['->' expression]
            &&
            (_literal_2 = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (tc = func_type_comment_rule(p), !p->error_indicator)  // func_type_comment?
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ function_def_raw[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 5 , "Async functions are" , _PyAST_AsyncFunctionDef ( n -> v . Name . id , ( params ) ? params : CHECK ( arguments_ty , _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , t , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_raw[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// function_def_nonewline:
//     | decorators function_def_raw_nonewline
//     | function_def_raw_nonewline
static stmt_ty
function_def_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    { // decorators function_def_raw_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "decorators function_def_raw_nonewline"));
        asdl_expr_seq* d;
        stmt_ty f;
        if (
            (d = decorators_rule(p))  // decorators
            &&
            (f = function_def_raw_nonewline_rule(p))  // function_def_raw_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ function_def_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "decorators function_def_raw_nonewline"));
            _res = _PyPegen_function_def_decorators ( p , d , f );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "decorators function_def_raw_nonewline"));
    }
    { // function_def_raw_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "function_def_raw_nonewline"));
        stmt_ty function_def_raw_nonewline_var;
        if (
            (function_def_raw_nonewline_var = function_def_raw_nonewline_rule(p))  // function_def_raw_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ function_def_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "function_def_raw_nonewline"));
            _res = function_def_raw_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "function_def_raw_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// function_def_raw_nonewline:
//     | "def" NAME? type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'
//     | 'async' "def" NAME? type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'
//     | "def" NAME? type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block_nonewline
//     | 'async' "def" NAME? type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block_nonewline
static stmt_ty
function_def_raw_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "def" NAME? type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_raw_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\" NAME? type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
        expr_ty _keyword;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        Token * _literal_3;
        void *a;
        asdl_stmt_seq* b;
        void *n;
        void *params;
        void *t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "def"))  // soft_keyword='"def"'
            &&
            (n = _PyPegen_name_token(p), !p->error_indicator)  // NAME?
            &&
            (t = type_params_rule(p), !p->error_indicator)  // type_params?
            &&
            (_literal = _PyPegen_expect_forced_token(p, 7, "("))  // forced_token='('
            &&
            (params = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (a = _tmp_65_rule(p), !p->error_indicator)  // ['->' expression]
            &&
            (_literal_2 = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = func_type_comment_rule(p), !p->error_indicator)  // func_type_comment?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_3 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ function_def_raw_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\" NAME? type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? _PyAST_FunctionDef ( n ? ( ( expr_ty ) n ) -> v . Name . id : NULL , ( params ) ? params : CHECK ( arguments_ty , _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , t , EXTRA ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_raw_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"def\" NAME? type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
    }
    { // 'async' "def" NAME? type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_raw_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME? type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
        Token * _keyword;
        expr_ty _keyword_1;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        Token * _literal_3;
        void *a;
        asdl_stmt_seq* b;
        void *n;
        void *params;
        void *t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_soft_keyword(p, "def"))  // soft_keyword='"def"'
            &&
            (n = _PyPegen_name_token(p), !p->error_indicator)  // NAME?
            &&
            (t = type_params_rule(p), !p->error_indicator)  // type_params?
            &&
            (_literal = _PyPegen_expect_forced_token(p, 7, "("))  // forced_token='('
            &&
            (params = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (a = _tmp_66_rule(p), !p->error_indicator)  // ['->' expression]
            &&
            (_literal_2 = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = func_type_comment_rule(p), !p->error_indicator)  // func_type_comment?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_3 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ function_def_raw_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME? type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? CHECK_VERSION ( stmt_ty , 5 , "Async functions are" , _PyAST_AsyncFunctionDef ( n ? ( ( expr_ty ) n ) -> v . Name . id : NULL , ( params ) ? params : CHECK ( arguments_ty , _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , t , EXTRA ) ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_raw_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME? type_params? &&'(' params? ')' ['->' expression] '{' func_type_comment? block_nonewline '}'"));
    }
    { // "def" NAME? type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_raw_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\" NAME? type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block_nonewline"));
        expr_ty _keyword;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *a;
        asdl_stmt_seq* b;
        void *n;
        void *params;
        void *t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "def"))  // soft_keyword='"def"'
            &&
            (n = _PyPegen_name_token(p), !p->error_indicator)  // NAME?
            &&
            (t = type_params_rule(p), !p->error_indicator)  // type_params?
            &&
            (_literal = _PyPegen_expect_forced_token(p, 7, "("))  // forced_token='('
            &&
            (params = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (a = _tmp_67_rule(p), !p->error_indicator)  // ['->' expression]
            &&
            (_literal_2 = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (tc = func_type_comment_rule(p), !p->error_indicator)  // func_type_comment?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ function_def_raw_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\" NAME? type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_FunctionDef ( n ? ( ( expr_ty ) n ) -> v . Name . id : NULL , ( params ) ? params : CHECK ( arguments_ty , _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , t , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_raw_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"def\" NAME? type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block_nonewline"));
    }
    { // 'async' "def" NAME? type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> function_def_raw_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME? type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block_nonewline"));
        Token * _keyword;
        expr_ty _keyword_1;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *a;
        asdl_stmt_seq* b;
        void *n;
        void *params;
        void *t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_soft_keyword(p, "def"))  // soft_keyword='"def"'
            &&
            (n = _PyPegen_name_token(p), !p->error_indicator)  // NAME?
            &&
            (t = type_params_rule(p), !p->error_indicator)  // type_params?
            &&
            (_literal = _PyPegen_expect_forced_token(p, 7, "("))  // forced_token='('
            &&
            (params = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (a = _tmp_68_rule(p), !p->error_indicator)  // ['->' expression]
            &&
            (_literal_2 = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (tc = func_type_comment_rule(p), !p->error_indicator)  // func_type_comment?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ function_def_raw_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME? type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 5 , "Async functions are" , _PyAST_AsyncFunctionDef ( n ? ( ( expr_ty ) n ) -> v . Name . id : NULL , ( params ) ? params : CHECK ( arguments_ty , _PyPegen_empty_arguments ( p ) ) , b , NULL , a , NEW_TYPE_COMMENT ( p , tc ) , t , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s function_def_raw_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' \"def\" NAME? type_params? &&'(' params? ')' ['->' expression] &&':' func_type_comment? block_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// params: invalid_parameters | parameters
static arguments_ty
params_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arguments_ty _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_parameters
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> params[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_parameters"));
        void *invalid_parameters_var;
        if (
            (invalid_parameters_var = invalid_parameters_rule(p))  // invalid_parameters
        )
        {
            D(fprintf(stderr, "%*c+ params[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_parameters"));
            _res = invalid_parameters_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s params[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_parameters"));
    }
    { // parameters
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> params[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "parameters"));
        arguments_ty parameters_var;
        if (
            (parameters_var = parameters_rule(p))  // parameters
        )
        {
            D(fprintf(stderr, "%*c+ params[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "parameters"));
            _res = parameters_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s params[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "parameters"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// parameters:
//     | slash_no_default param_no_default* param_with_default* star_etc?
//     | slash_with_default param_with_default* star_etc?
//     | param_no_default+ param_with_default* star_etc?
//     | param_with_default+ star_etc?
//     | star_etc
static arguments_ty
parameters_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arguments_ty _res = NULL;
    int _mark = p->mark;
    { // slash_no_default param_no_default* param_with_default* star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_no_default param_no_default* param_with_default* star_etc?"));
        asdl_arg_seq* a;
        asdl_arg_seq* b;
        asdl_seq * c;
        void *d;
        if (
            (a = slash_no_default_rule(p))  // slash_no_default
            &&
            (b = (asdl_arg_seq*)_loop0_69_rule(p))  // param_no_default*
            &&
            (c = _loop0_70_rule(p))  // param_with_default*
            &&
            (d = star_etc_rule(p), !p->error_indicator)  // star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_no_default param_no_default* param_with_default* star_etc?"));
            _res = CHECK_VERSION ( arguments_ty , 8 , "Positional-only parameters are" , _PyPegen_make_arguments ( p , a , NULL , b , c , d ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "slash_no_default param_no_default* param_with_default* star_etc?"));
    }
    { // slash_with_default param_with_default* star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_with_default param_with_default* star_etc?"));
        SlashWithDefault* a;
        asdl_seq * b;
        void *c;
        if (
            (a = slash_with_default_rule(p))  // slash_with_default
            &&
            (b = _loop0_71_rule(p))  // param_with_default*
            &&
            (c = star_etc_rule(p), !p->error_indicator)  // star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_with_default param_with_default* star_etc?"));
            _res = CHECK_VERSION ( arguments_ty , 8 , "Positional-only parameters are" , _PyPegen_make_arguments ( p , NULL , a , NULL , b , c ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "slash_with_default param_with_default* star_etc?"));
    }
    { // param_no_default+ param_with_default* star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default+ param_with_default* star_etc?"));
        asdl_arg_seq* a;
        asdl_seq * b;
        void *c;
        if (
            (a = (asdl_arg_seq*)_loop1_72_rule(p))  // param_no_default+
            &&
            (b = _loop0_73_rule(p))  // param_with_default*
            &&
            (c = star_etc_rule(p), !p->error_indicator)  // star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default+ param_with_default* star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default+ param_with_default* star_etc?"));
    }
    { // param_with_default+ star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_with_default+ star_etc?"));
        asdl_seq * a;
        void *b;
        if (
            (a = _loop1_74_rule(p))  // param_with_default+
            &&
            (b = star_etc_rule(p), !p->error_indicator)  // star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_with_default+ star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_with_default+ star_etc?"));
    }
    { // star_etc
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_etc"));
        StarEtc* a;
        if (
            (a = star_etc_rule(p))  // star_etc
        )
        {
            D(fprintf(stderr, "%*c+ parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_etc"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_etc"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &')'
static asdl_arg_seq*
slash_no_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_arg_seq* _res = NULL;
    int _mark = p->mark;
    { // param_no_default+ '/' ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slash_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default+ '/' ','"));
        Token * _literal;
        Token * _literal_1;
        asdl_arg_seq* a;
        if (
            (a = (asdl_arg_seq*)_loop1_75_rule(p))  // param_no_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ slash_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default+ '/' ','"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slash_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default+ '/' ','"));
    }
    { // param_no_default+ '/' &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slash_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default+ '/' &')'"));
        Token * _literal;
        asdl_arg_seq* a;
        if (
            (a = (asdl_arg_seq*)_loop1_76_rule(p))  // param_no_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ slash_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default+ '/' &')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slash_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default+ '/' &')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// slash_with_default:
//     | param_no_default* param_with_default+ '/' ','
//     | param_no_default* param_with_default+ '/' &')'
static SlashWithDefault*
slash_with_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    SlashWithDefault* _res = NULL;
    int _mark = p->mark;
    { // param_no_default* param_with_default+ '/' ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slash_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default* param_with_default+ '/' ','"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _loop0_77_rule(p))  // param_no_default*
            &&
            (b = _loop1_78_rule(p))  // param_with_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ slash_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default* param_with_default+ '/' ','"));
            _res = _PyPegen_slash_with_default ( p , ( asdl_arg_seq* ) a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slash_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default* param_with_default+ '/' ','"));
    }
    { // param_no_default* param_with_default+ '/' &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slash_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default* param_with_default+ '/' &')'"));
        Token * _literal;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _loop0_79_rule(p))  // param_no_default*
            &&
            (b = _loop1_80_rule(p))  // param_with_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ slash_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default* param_with_default+ '/' &')'"));
            _res = _PyPegen_slash_with_default ( p , ( asdl_arg_seq* ) a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slash_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default* param_with_default+ '/' &')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_etc:
//     | invalid_star_etc
//     | '*' param_no_default param_maybe_default* kwds?
//     | '*' param_no_default_star_annotation param_maybe_default* kwds?
//     | '*' ',' param_maybe_default+ kwds?
//     | kwds
static StarEtc*
star_etc_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    StarEtc* _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_star_etc
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_star_etc"));
        void *invalid_star_etc_var;
        if (
            (invalid_star_etc_var = invalid_star_etc_rule(p))  // invalid_star_etc
        )
        {
            D(fprintf(stderr, "%*c+ star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_star_etc"));
            _res = invalid_star_etc_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_star_etc"));
    }
    { // '*' param_no_default param_maybe_default* kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' param_no_default param_maybe_default* kwds?"));
        Token * _literal;
        arg_ty a;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = param_no_default_rule(p))  // param_no_default
            &&
            (b = _loop0_81_rule(p))  // param_maybe_default*
            &&
            (c = kwds_rule(p), !p->error_indicator)  // kwds?
        )
        {
            D(fprintf(stderr, "%*c+ star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' param_no_default param_maybe_default* kwds?"));
            _res = _PyPegen_star_etc ( p , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' param_no_default param_maybe_default* kwds?"));
    }
    { // '*' param_no_default_star_annotation param_maybe_default* kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' param_no_default_star_annotation param_maybe_default* kwds?"));
        Token * _literal;
        arg_ty a;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = param_no_default_star_annotation_rule(p))  // param_no_default_star_annotation
            &&
            (b = _loop0_82_rule(p))  // param_maybe_default*
            &&
            (c = kwds_rule(p), !p->error_indicator)  // kwds?
        )
        {
            D(fprintf(stderr, "%*c+ star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' param_no_default_star_annotation param_maybe_default* kwds?"));
            _res = _PyPegen_star_etc ( p , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' param_no_default_star_annotation param_maybe_default* kwds?"));
    }
    { // '*' ',' param_maybe_default+ kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' ',' param_maybe_default+ kwds?"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (b = _loop1_83_rule(p))  // param_maybe_default+
            &&
            (c = kwds_rule(p), !p->error_indicator)  // kwds?
        )
        {
            D(fprintf(stderr, "%*c+ star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' ',' param_maybe_default+ kwds?"));
            _res = _PyPegen_star_etc ( p , NULL , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' ',' param_maybe_default+ kwds?"));
    }
    { // kwds
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwds"));
        arg_ty a;
        if (
            (a = kwds_rule(p))  // kwds
        )
        {
            D(fprintf(stderr, "%*c+ star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwds"));
            _res = _PyPegen_star_etc ( p , NULL , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "kwds"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// kwds: invalid_kwds | '**' param_no_default
static arg_ty
kwds_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_kwds
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_kwds"));
        void *invalid_kwds_var;
        if (
            (invalid_kwds_var = invalid_kwds_rule(p))  // invalid_kwds
        )
        {
            D(fprintf(stderr, "%*c+ kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_kwds"));
            _res = invalid_kwds_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_kwds"));
    }
    { // '**' param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' param_no_default"));
        Token * _literal;
        arg_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = param_no_default_rule(p))  // param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' param_no_default"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' param_no_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// param_no_default: param ',' TYPE_COMMENT? | param TYPE_COMMENT? &')'
static arg_ty
param_no_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    { // param ',' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param ',' TYPE_COMMENT?"));
        Token * _literal;
        arg_ty a;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ param_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param ',' TYPE_COMMENT?"));
            _res = _PyPegen_add_type_comment_to_arg ( p , a , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param ',' TYPE_COMMENT?"));
    }
    { // param TYPE_COMMENT? &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param TYPE_COMMENT? &')'"));
        arg_ty a;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ param_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param TYPE_COMMENT? &')'"));
            _res = _PyPegen_add_type_comment_to_arg ( p , a , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param TYPE_COMMENT? &')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// param_no_default_star_annotation:
//     | param_star_annotation ',' TYPE_COMMENT?
//     | param_star_annotation TYPE_COMMENT? &')'
static arg_ty
param_no_default_star_annotation_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    { // param_star_annotation ',' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_no_default_star_annotation[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_star_annotation ',' TYPE_COMMENT?"));
        Token * _literal;
        arg_ty a;
        void *tc;
        if (
            (a = param_star_annotation_rule(p))  // param_star_annotation
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ param_no_default_star_annotation[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_star_annotation ',' TYPE_COMMENT?"));
            _res = _PyPegen_add_type_comment_to_arg ( p , a , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_no_default_star_annotation[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_star_annotation ',' TYPE_COMMENT?"));
    }
    { // param_star_annotation TYPE_COMMENT? &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_no_default_star_annotation[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_star_annotation TYPE_COMMENT? &')'"));
        arg_ty a;
        void *tc;
        if (
            (a = param_star_annotation_rule(p))  // param_star_annotation
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ param_no_default_star_annotation[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_star_annotation TYPE_COMMENT? &')'"));
            _res = _PyPegen_add_type_comment_to_arg ( p , a , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_no_default_star_annotation[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_star_annotation TYPE_COMMENT? &')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// param_with_default: param default ',' TYPE_COMMENT? | param default TYPE_COMMENT? &')'
static NameDefaultPair*
param_with_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    NameDefaultPair* _res = NULL;
    int _mark = p->mark;
    { // param default ',' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param default ',' TYPE_COMMENT?"));
        Token * _literal;
        arg_ty a;
        expr_ty c;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (c = default_rule(p))  // default
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ param_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param default ',' TYPE_COMMENT?"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param default ',' TYPE_COMMENT?"));
    }
    { // param default TYPE_COMMENT? &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param default TYPE_COMMENT? &')'"));
        arg_ty a;
        expr_ty c;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (c = default_rule(p))  // default
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ param_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param default TYPE_COMMENT? &')'"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param default TYPE_COMMENT? &')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// param_maybe_default:
//     | param default? ',' TYPE_COMMENT?
//     | param default? TYPE_COMMENT? &')'
static NameDefaultPair*
param_maybe_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    NameDefaultPair* _res = NULL;
    int _mark = p->mark;
    { // param default? ',' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_maybe_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param default? ',' TYPE_COMMENT?"));
        Token * _literal;
        arg_ty a;
        void *c;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (c = default_rule(p), !p->error_indicator)  // default?
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ param_maybe_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param default? ',' TYPE_COMMENT?"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_maybe_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param default? ',' TYPE_COMMENT?"));
    }
    { // param default? TYPE_COMMENT? &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_maybe_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param default? TYPE_COMMENT? &')'"));
        arg_ty a;
        void *c;
        void *tc;
        if (
            (a = param_rule(p))  // param
            &&
            (c = default_rule(p), !p->error_indicator)  // default?
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ param_maybe_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param default? TYPE_COMMENT? &')'"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_maybe_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param default? TYPE_COMMENT? &')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// param: NAME annotation?
static arg_ty
param_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME annotation?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME annotation?"));
        expr_ty a;
        void *b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = annotation_rule(p), !p->error_indicator)  // annotation?
        )
        {
            D(fprintf(stderr, "%*c+ param[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME annotation?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_arg ( a -> v . Name . id , b , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME annotation?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// param_star_annotation: NAME star_annotation
static arg_ty
param_star_annotation_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME star_annotation
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> param_star_annotation[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME star_annotation"));
        expr_ty a;
        expr_ty b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = star_annotation_rule(p))  // star_annotation
        )
        {
            D(fprintf(stderr, "%*c+ param_star_annotation[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME star_annotation"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_arg ( a -> v . Name . id , b , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s param_star_annotation[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME star_annotation"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// annotation: ':' expression
static expr_ty
annotation_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> annotation[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ annotation[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' expression"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s annotation[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_annotation: ':' star_expression
static expr_ty
star_annotation_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // ':' star_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_annotation[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' star_expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (a = star_expression_rule(p))  // star_expression
        )
        {
            D(fprintf(stderr, "%*c+ star_annotation[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' star_expression"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_annotation[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':' star_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// default: '=' expression | invalid_default
static expr_ty
default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // '=' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' expression"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'=' expression"));
    }
    if (p->call_invalid_rules) { // invalid_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_default"));
        void *invalid_default_var;
        if (
            (invalid_default_var = invalid_default_rule(p))  // invalid_default
        )
        {
            D(fprintf(stderr, "%*c+ default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_default"));
            _res = invalid_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// if_stmt:
//     | invalid_if_stmt
//     | 'if' named_expression block_entry elif_stmt
//     | 'if' named_expression block_entry else_block?
static stmt_ty
if_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_if_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> if_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_if_stmt"));
        void *invalid_if_stmt_var;
        if (
            (invalid_if_stmt_var = invalid_if_stmt_rule(p))  // invalid_if_stmt
        )
        {
            D(fprintf(stderr, "%*c+ if_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_if_stmt"));
            _res = invalid_if_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s if_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_if_stmt"));
    }
    { // 'if' named_expression block_entry elif_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> if_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry elif_stmt"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        stmt_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = block_entry_rule(p))  // block_entry
            &&
            (c = elif_stmt_rule(p))  // elif_stmt
        )
        {
            D(fprintf(stderr, "%*c+ if_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry elif_stmt"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , CHECK ( asdl_stmt_seq* , _PyPegen_singleton_seq ( p , c ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s if_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry elif_stmt"));
    }
    { // 'if' named_expression block_entry else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> if_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry else_block?"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = block_entry_rule(p))  // block_entry
            &&
            (c = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ if_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s if_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry else_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// elif_stmt:
//     | invalid_elif_stmt
//     | 'elif' named_expression block_entry elif_stmt
//     | 'elif' named_expression block_entry else_block?
static stmt_ty
elif_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_elif_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> elif_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_elif_stmt"));
        void *invalid_elif_stmt_var;
        if (
            (invalid_elif_stmt_var = invalid_elif_stmt_rule(p))  // invalid_elif_stmt
        )
        {
            D(fprintf(stderr, "%*c+ elif_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_elif_stmt"));
            _res = invalid_elif_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s elif_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_elif_stmt"));
    }
    { // 'elif' named_expression block_entry elif_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> elif_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry elif_stmt"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        stmt_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 774))  // token='elif'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = block_entry_rule(p))  // block_entry
            &&
            (c = elif_stmt_rule(p))  // elif_stmt
        )
        {
            D(fprintf(stderr, "%*c+ elif_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry elif_stmt"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , CHECK ( asdl_stmt_seq* , _PyPegen_singleton_seq ( p , c ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s elif_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry elif_stmt"));
    }
    { // 'elif' named_expression block_entry else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> elif_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry else_block?"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 774))  // token='elif'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = block_entry_rule(p))  // block_entry
            &&
            (c = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ elif_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s elif_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry else_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// else_block: invalid_else_stmt | 'else' (braced_block | &&':' block)
static asdl_stmt_seq*
else_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_else_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> else_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_else_stmt"));
        void *invalid_else_stmt_var;
        if (
            (invalid_else_stmt_var = invalid_else_stmt_rule(p))  // invalid_else_stmt
        )
        {
            D(fprintf(stderr, "%*c+ else_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_else_stmt"));
            _res = invalid_else_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s else_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_else_stmt"));
    }
    { // 'else' (braced_block | &&':' block)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> else_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'else' (braced_block | &&':' block)"));
        Token * _keyword;
        void *b;
        if (
            (_keyword = _PyPegen_expect_token(p, 775))  // token='else'
            &&
            (b = _tmp_84_rule(p))  // braced_block | &&':' block
        )
        {
            D(fprintf(stderr, "%*c+ else_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'else' (braced_block | &&':' block)"));
            _res = b;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s else_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'else' (braced_block | &&':' block)"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// if_stmt_nonewline:
//     | 'if' named_expression block_entry_nonewline elif_stmt_nonewline
//     | 'if' named_expression block_entry_nonewline else_block?
static stmt_ty
if_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'if' named_expression block_entry_nonewline elif_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> if_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry_nonewline elif_stmt_nonewline"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        stmt_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
            &&
            (c = elif_stmt_nonewline_rule(p))  // elif_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ if_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry_nonewline elif_stmt_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , CHECK ( asdl_stmt_seq* , _PyPegen_singleton_seq ( p , c ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s if_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry_nonewline elif_stmt_nonewline"));
    }
    { // 'if' named_expression block_entry_nonewline else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> if_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry_nonewline else_block?"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
            &&
            (c = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ if_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry_nonewline else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s if_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'if' named_expression block_entry_nonewline else_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// elif_stmt_nonewline:
//     | 'elif' named_expression block_entry_nonewline elif_stmt_nonewline
//     | 'elif' named_expression block_entry_nonewline else_block_nonewline?
static stmt_ty
elif_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'elif' named_expression block_entry_nonewline elif_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> elif_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry_nonewline elif_stmt_nonewline"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        stmt_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 774))  // token='elif'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
            &&
            (c = elif_stmt_nonewline_rule(p))  // elif_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ elif_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry_nonewline elif_stmt_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , CHECK ( asdl_stmt_seq* , _PyPegen_singleton_seq ( p , c ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s elif_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry_nonewline elif_stmt_nonewline"));
    }
    { // 'elif' named_expression block_entry_nonewline else_block_nonewline?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> elif_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry_nonewline else_block_nonewline?"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 774))  // token='elif'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
            &&
            (c = else_block_nonewline_rule(p), !p->error_indicator)  // else_block_nonewline?
        )
        {
            D(fprintf(stderr, "%*c+ elif_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry_nonewline else_block_nonewline?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s elif_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'elif' named_expression block_entry_nonewline else_block_nonewline?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// else_block_nonewline: 'else' (braced_block | &&':' block_nonewline)
static asdl_stmt_seq*
else_block_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // 'else' (braced_block | &&':' block_nonewline)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> else_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'else' (braced_block | &&':' block_nonewline)"));
        Token * _keyword;
        void *b;
        if (
            (_keyword = _PyPegen_expect_token(p, 775))  // token='else'
            &&
            (b = _tmp_85_rule(p))  // braced_block | &&':' block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ else_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'else' (braced_block | &&':' block_nonewline)"));
            _res = b;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s else_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'else' (braced_block | &&':' block_nonewline)"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// while_stmt: invalid_while_stmt | 'while' named_expression block_entry else_block?
static stmt_ty
while_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_while_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> while_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_while_stmt"));
        void *invalid_while_stmt_var;
        if (
            (invalid_while_stmt_var = invalid_while_stmt_rule(p))  // invalid_while_stmt
        )
        {
            D(fprintf(stderr, "%*c+ while_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_while_stmt"));
            _res = invalid_while_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s while_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_while_stmt"));
    }
    { // 'while' named_expression block_entry else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> while_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'while' named_expression block_entry else_block?"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 777))  // token='while'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = block_entry_rule(p))  // block_entry
            &&
            (c = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ while_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'while' named_expression block_entry else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_While ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s while_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'while' named_expression block_entry else_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// while_stmt_nonewline:
//     | 'while' named_expression block_entry_nonewline else_block_nonewline?
static stmt_ty
while_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'while' named_expression block_entry_nonewline else_block_nonewline?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> while_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'while' named_expression block_entry_nonewline else_block_nonewline?"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        void *c;
        if (
            (_keyword = _PyPegen_expect_token(p, 777))  // token='while'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
            &&
            (c = else_block_nonewline_rule(p), !p->error_indicator)  // else_block_nonewline?
        )
        {
            D(fprintf(stderr, "%*c+ while_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'while' named_expression block_entry_nonewline else_block_nonewline?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_While ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s while_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'while' named_expression block_entry_nonewline else_block_nonewline?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// for_stmt:
//     | invalid_for_stmt
//     | 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
//     | 'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
//     | 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block?
//     | 'async' 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block?
//     | invalid_for_target
static stmt_ty
for_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_for_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_for_stmt"));
        void *invalid_for_stmt_var;
        if (
            (invalid_for_stmt_var = invalid_for_stmt_rule(p))  // invalid_for_stmt
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_for_stmt"));
            _res = invalid_for_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_for_stmt"));
    }
    { // 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        asdl_stmt_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_For ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // 'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _keyword_2;
        Token * _literal;
        asdl_stmt_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_2 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 5 , "Async for loops are" , _PyAST_AsyncFor ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block else_block?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        Token * _literal_1;
        asdl_stmt_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? _PyAST_For ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // 'async' 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _keyword_2;
        Token * _literal;
        Token * _literal_1;
        asdl_stmt_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_2 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? CHECK_VERSION ( stmt_ty , 5 , "Async for loops are" , _PyAST_AsyncFor ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    if (p->call_invalid_rules) { // invalid_for_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_for_target"));
        void *invalid_for_target_var;
        if (
            (invalid_for_target_var = invalid_for_target_rule(p))  // invalid_for_target
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_for_target"));
            _res = invalid_for_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_for_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// for_stmt_nonewline:
//     | 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block_nonewline else_block_nonewline?
//     | 'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block_nonewline else_block_nonewline?
//     | 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block_nonewline?
//     | 'async' 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block_nonewline?
//     | invalid_for_target
static stmt_ty
for_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block_nonewline else_block_nonewline?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block_nonewline else_block_nonewline?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        asdl_stmt_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (el = else_block_nonewline_rule(p), !p->error_indicator)  // else_block_nonewline?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block_nonewline else_block_nonewline?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_For ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block_nonewline else_block_nonewline?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // 'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block_nonewline else_block_nonewline?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block_nonewline else_block_nonewline?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _keyword_2;
        Token * _literal;
        asdl_stmt_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_2 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (el = else_block_nonewline_rule(p), !p->error_indicator)  // else_block_nonewline?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block_nonewline else_block_nonewline?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 5 , "Async for loops are" , _PyAST_AsyncFor ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions ':' TYPE_COMMENT? block_nonewline else_block_nonewline?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block_nonewline?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block_nonewline?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        Token * _literal_1;
        asdl_stmt_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
            &&
            (el = else_block_nonewline_rule(p), !p->error_indicator)  // else_block_nonewline?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block_nonewline?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? _PyAST_For ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block_nonewline?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // 'async' 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block_nonewline?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block_nonewline?"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _keyword_2;
        Token * _literal;
        Token * _literal_1;
        asdl_stmt_seq* b;
        void *el;
        expr_ty ex;
        expr_ty t;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (t = star_targets_rule(p))  // star_targets
            &&
            (_keyword_2 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (ex = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
            &&
            (el = else_block_nonewline_rule(p), !p->error_indicator)  // else_block_nonewline?
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block_nonewline?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? CHECK_VERSION ( stmt_ty , 5 , "Async for loops are" , _PyAST_AsyncFor ( t , ex , b , el , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ star_expressions '{' TYPE_COMMENT? block_nonewline '}' else_block_nonewline?"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    if (p->call_invalid_rules) { // invalid_for_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_for_target"));
        void *invalid_for_target_var;
        if (
            (invalid_for_target_var = invalid_for_target_rule(p))  // invalid_for_target
        )
        {
            D(fprintf(stderr, "%*c+ for_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_for_target"));
            _res = invalid_for_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_for_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// with_stmt:
//     | invalid_with_stmt_indent
//     | 'with' '(' ','.with_item+ ','? ')' block_entry
//     | 'with' ','.with_item+ ':' TYPE_COMMENT? block
//     | 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'
//     | 'async' 'with' '(' ','.with_item+ ','? ')' block_entry
//     | 'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block
//     | 'async' 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'
//     | invalid_with_stmt
static stmt_ty
with_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_with_stmt_indent
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_with_stmt_indent"));
        void *invalid_with_stmt_indent_var;
        if (
            (invalid_with_stmt_indent_var = invalid_with_stmt_indent_rule(p))  // invalid_with_stmt_indent
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_with_stmt_indent"));
            _res = invalid_with_stmt_indent_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_with_stmt_indent"));
    }
    { // 'with' '(' ','.with_item+ ','? ')' block_entry
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' '(' ','.with_item+ ','? ')' block_entry"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = (asdl_withitem_seq*)_gather_86_rule(p))  // ','.with_item+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (b = block_entry_rule(p))  // block_entry
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' '(' ','.with_item+ ','? ')' block_entry"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 9 , "Parenthesized context managers are" , _PyAST_With ( a , b , NULL , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'with' '(' ','.with_item+ ','? ')' block_entry"));
    }
    { // 'with' ','.with_item+ ':' TYPE_COMMENT? block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ ':' TYPE_COMMENT? block"));
        Token * _keyword;
        Token * _literal;
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (a = (asdl_withitem_seq*)_gather_88_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ ':' TYPE_COMMENT? block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_With ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ ':' TYPE_COMMENT? block"));
    }
    { // 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (a = (asdl_withitem_seq*)_gather_90_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? _PyAST_With ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
    }
    { // 'async' 'with' '(' ','.with_item+ ','? ')' block_entry
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' '(' ','.with_item+ ','? ')' block_entry"));
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = (asdl_withitem_seq*)_gather_92_rule(p))  // ','.with_item+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (b = block_entry_rule(p))  // block_entry
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' '(' ','.with_item+ ','? ')' block_entry"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 5 , "Async with statements are" , _PyAST_AsyncWith ( a , b , NULL , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' 'with' '(' ','.with_item+ ','? ')' block_entry"));
    }
    { // 'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block"));
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (a = (asdl_withitem_seq*)_gather_94_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 5 , "Async with statements are" , _PyAST_AsyncWith ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block"));
    }
    { // 'async' 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        Token * _literal_1;
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (a = (asdl_withitem_seq*)_gather_96_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? CHECK_VERSION ( stmt_ty , 5 , "Async with statements are" , _PyAST_AsyncWith ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
    }
    if (p->call_invalid_rules) { // invalid_with_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_with_stmt"));
        void *invalid_with_stmt_var;
        if (
            (invalid_with_stmt_var = invalid_with_stmt_rule(p))  // invalid_with_stmt
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_with_stmt"));
            _res = invalid_with_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_with_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// with_stmt_nonewline:
//     | 'with' '(' ','.with_item+ ','? ')' block_entry_nonewline
//     | 'with' ','.with_item+ ':' TYPE_COMMENT? block_nonewline
//     | 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'
//     | 'async' 'with' '(' ','.with_item+ ','? ')' block_entry_nonewline
//     | 'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block_nonewline
//     | 'async' 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'
static stmt_ty
with_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'with' '(' ','.with_item+ ','? ')' block_entry_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' '(' ','.with_item+ ','? ')' block_entry_nonewline"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = (asdl_withitem_seq*)_gather_98_rule(p))  // ','.with_item+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' '(' ','.with_item+ ','? ')' block_entry_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 9 , "Parenthesized context managers are" , _PyAST_With ( a , b , NULL , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'with' '(' ','.with_item+ ','? ')' block_entry_nonewline"));
    }
    { // 'with' ','.with_item+ ':' TYPE_COMMENT? block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ ':' TYPE_COMMENT? block_nonewline"));
        Token * _keyword;
        Token * _literal;
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (a = (asdl_withitem_seq*)_gather_100_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ ':' TYPE_COMMENT? block_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_With ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ ':' TYPE_COMMENT? block_nonewline"));
    }
    { // 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (a = (asdl_withitem_seq*)_gather_102_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? _PyAST_With ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
    }
    { // 'async' 'with' '(' ','.with_item+ ','? ')' block_entry_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' '(' ','.with_item+ ','? ')' block_entry_nonewline"));
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = (asdl_withitem_seq*)_gather_104_rule(p))  // ','.with_item+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' '(' ','.with_item+ ','? ')' block_entry_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 5 , "Async with statements are" , _PyAST_AsyncWith ( a , b , NULL , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' 'with' '(' ','.with_item+ ','? ')' block_entry_nonewline"));
    }
    { // 'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block_nonewline"));
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (a = (asdl_withitem_seq*)_gather_106_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 5 , "Async with statements are" , _PyAST_AsyncWith ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ ':' TYPE_COMMENT? block_nonewline"));
    }
    { // 'async' 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
        Token * _keyword;
        Token * _keyword_1;
        Token * _literal;
        Token * _literal_1;
        asdl_withitem_seq* a;
        asdl_stmt_seq* b;
        void *tc;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (a = (asdl_withitem_seq*)_gather_108_rule(p))  // ','.with_item+
            &&
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ with_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_check_braces ( p ) ? CHECK_VERSION ( stmt_ty , 5 , "Async with statements are" , _PyAST_AsyncWith ( a , b , NEW_TYPE_COMMENT ( p , tc ) , EXTRA ) ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' 'with' ','.with_item+ '{' TYPE_COMMENT? block_nonewline '}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// with_item:
//     | expression 'as' star_target &(',' | ')' | ':')
//     | invalid_with_item
//     | expression
static withitem_ty
with_item_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    withitem_ty _res = NULL;
    int _mark = p->mark;
    { // expression 'as' star_target &(',' | ')' | ':')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_item[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression 'as' star_target &(',' | ')' | ':')"));
        Token * _keyword;
        expr_ty e;
        expr_ty t;
        if (
            (e = expression_rule(p))  // expression
            &&
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (t = star_target_rule(p))  // star_target
            &&
            _PyPegen_lookahead(1, _tmp_110_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ with_item[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression 'as' star_target &(',' | ')' | ':')"));
            _res = _PyAST_withitem ( e , t , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_item[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression 'as' star_target &(',' | ')' | ':')"));
    }
    if (p->call_invalid_rules) { // invalid_with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_item[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_with_item"));
        void *invalid_with_item_var;
        if (
            (invalid_with_item_var = invalid_with_item_rule(p))  // invalid_with_item
        )
        {
            D(fprintf(stderr, "%*c+ with_item[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_with_item"));
            _res = invalid_with_item_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_item[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_with_item"));
    }
    { // expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> with_item[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression"));
        expr_ty e;
        if (
            (e = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ with_item[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression"));
            _res = _PyAST_withitem ( e , NULL , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s with_item[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// try_stmt:
//     | invalid_try_stmt
//     | 'try' (&&':' block | braced_block) finally_block
//     | 'try' (&&':' block | braced_block) except_block+ else_block? finally_block?
//     | 'try' (&&':' block | braced_block) except_star_block+ else_block? finally_block?
static stmt_ty
try_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_try_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_try_stmt"));
        void *invalid_try_stmt_var;
        if (
            (invalid_try_stmt_var = invalid_try_stmt_rule(p))  // invalid_try_stmt
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_try_stmt"));
            _res = invalid_try_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_try_stmt"));
    }
    { // 'try' (&&':' block | braced_block) finally_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block | braced_block) finally_block"));
        Token * _keyword;
        void *b;
        asdl_stmt_seq* f;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (b = _tmp_111_rule(p))  // &&':' block | braced_block
            &&
            (f = finally_block_rule(p))  // finally_block
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block | braced_block) finally_block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Try ( b , NULL , NULL , f , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' (&&':' block | braced_block) finally_block"));
    }
    { // 'try' (&&':' block | braced_block) except_block+ else_block? finally_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block | braced_block) except_block+ else_block? finally_block?"));
        Token * _keyword;
        void *b;
        void *el;
        asdl_excepthandler_seq* ex;
        void *f;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (b = _tmp_112_rule(p))  // &&':' block | braced_block
            &&
            (ex = (asdl_excepthandler_seq*)_loop1_113_rule(p))  // except_block+
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
            &&
            (f = finally_block_rule(p), !p->error_indicator)  // finally_block?
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block | braced_block) except_block+ else_block? finally_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Try ( b , ex , el , f , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' (&&':' block | braced_block) except_block+ else_block? finally_block?"));
    }
    { // 'try' (&&':' block | braced_block) except_star_block+ else_block? finally_block?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block | braced_block) except_star_block+ else_block? finally_block?"));
        Token * _keyword;
        void *b;
        void *el;
        asdl_excepthandler_seq* ex;
        void *f;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (b = _tmp_114_rule(p))  // &&':' block | braced_block
            &&
            (ex = (asdl_excepthandler_seq*)_loop1_115_rule(p))  // except_star_block+
            &&
            (el = else_block_rule(p), !p->error_indicator)  // else_block?
            &&
            (f = finally_block_rule(p), !p->error_indicator)  // finally_block?
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block | braced_block) except_star_block+ else_block? finally_block?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 11 , "Exception groups are" , _PyAST_TryStar ( b , ex , el , f , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' (&&':' block | braced_block) except_star_block+ else_block? finally_block?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// try_stmt_nonewline:
//     | invalid_try_stmt_nonewline
//     | 'try' (&&':' block_nonewline | braced_block) finally_block_nonewline
//     | 'try' (&&':' block_nonewline | braced_block) except_block_nonewline+ else_block_nonewline? finally_block_nonewline?
//     | 'try' (&&':' block_nonewline | braced_block) except_star_block_nonewline+ else_block_nonewline? finally_block_nonewline?
static stmt_ty
try_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_try_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_try_stmt_nonewline"));
        void *invalid_try_stmt_nonewline_var;
        if (
            (invalid_try_stmt_nonewline_var = invalid_try_stmt_nonewline_rule(p))  // invalid_try_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_try_stmt_nonewline"));
            _res = invalid_try_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_try_stmt_nonewline"));
    }
    { // 'try' (&&':' block_nonewline | braced_block) finally_block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block_nonewline | braced_block) finally_block_nonewline"));
        Token * _keyword;
        void *b;
        asdl_stmt_seq* f;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (b = _tmp_116_rule(p))  // &&':' block_nonewline | braced_block
            &&
            (f = finally_block_nonewline_rule(p))  // finally_block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block_nonewline | braced_block) finally_block_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Try ( b , NULL , NULL , f , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' (&&':' block_nonewline | braced_block) finally_block_nonewline"));
    }
    { // 'try' (&&':' block_nonewline | braced_block) except_block_nonewline+ else_block_nonewline? finally_block_nonewline?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block_nonewline | braced_block) except_block_nonewline+ else_block_nonewline? finally_block_nonewline?"));
        Token * _keyword;
        void *b;
        void *el;
        asdl_excepthandler_seq* ex;
        void *f;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (b = _tmp_117_rule(p))  // &&':' block_nonewline | braced_block
            &&
            (ex = (asdl_excepthandler_seq*)_loop1_118_rule(p))  // except_block_nonewline+
            &&
            (el = else_block_nonewline_rule(p), !p->error_indicator)  // else_block_nonewline?
            &&
            (f = finally_block_nonewline_rule(p), !p->error_indicator)  // finally_block_nonewline?
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block_nonewline | braced_block) except_block_nonewline+ else_block_nonewline? finally_block_nonewline?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Try ( b , ex , el , f , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' (&&':' block_nonewline | braced_block) except_block_nonewline+ else_block_nonewline? finally_block_nonewline?"));
    }
    { // 'try' (&&':' block_nonewline | braced_block) except_star_block_nonewline+ else_block_nonewline? finally_block_nonewline?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> try_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block_nonewline | braced_block) except_star_block_nonewline+ else_block_nonewline? finally_block_nonewline?"));
        Token * _keyword;
        void *b;
        void *el;
        asdl_excepthandler_seq* ex;
        void *f;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (b = _tmp_119_rule(p))  // &&':' block_nonewline | braced_block
            &&
            (ex = (asdl_excepthandler_seq*)_loop1_120_rule(p))  // except_star_block_nonewline+
            &&
            (el = else_block_nonewline_rule(p), !p->error_indicator)  // else_block_nonewline?
            &&
            (f = finally_block_nonewline_rule(p), !p->error_indicator)  // finally_block_nonewline?
        )
        {
            D(fprintf(stderr, "%*c+ try_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' (&&':' block_nonewline | braced_block) except_star_block_nonewline+ else_block_nonewline? finally_block_nonewline?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 11 , "Exception groups are" , _PyAST_TryStar ( b , ex , el , f , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s try_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' (&&':' block_nonewline | braced_block) except_star_block_nonewline+ else_block_nonewline? finally_block_nonewline?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// except_block:
//     | invalid_except_stmt_indent
//     | 'except' expression ['as' NAME] block_entry
//     | 'except' block_entry
//     | invalid_except_stmt
static excepthandler_ty
except_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    excepthandler_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_except_stmt_indent
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_stmt_indent"));
        void *invalid_except_stmt_indent_var;
        if (
            (invalid_except_stmt_indent_var = invalid_except_stmt_indent_rule(p))  // invalid_except_stmt_indent
        )
        {
            D(fprintf(stderr, "%*c+ except_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_stmt_indent"));
            _res = invalid_except_stmt_indent_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_except_stmt_indent"));
    }
    { // 'except' expression ['as' NAME] block_entry
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' expression ['as' NAME] block_entry"));
        Token * _keyword;
        asdl_stmt_seq* b;
        expr_ty e;
        void *t;
        if (
            (_keyword = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (e = expression_rule(p))  // expression
            &&
            (t = _tmp_121_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (b = block_entry_rule(p))  // block_entry
        )
        {
            D(fprintf(stderr, "%*c+ except_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' expression ['as' NAME] block_entry"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ExceptHandler ( e , ( t ) ? ( ( expr_ty ) t ) -> v . Name . id : NULL , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' expression ['as' NAME] block_entry"));
    }
    { // 'except' block_entry
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' block_entry"));
        Token * _keyword;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (b = block_entry_rule(p))  // block_entry
        )
        {
            D(fprintf(stderr, "%*c+ except_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' block_entry"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ExceptHandler ( NULL , NULL , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' block_entry"));
    }
    if (p->call_invalid_rules) { // invalid_except_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_stmt"));
        void *invalid_except_stmt_var;
        if (
            (invalid_except_stmt_var = invalid_except_stmt_rule(p))  // invalid_except_stmt
        )
        {
            D(fprintf(stderr, "%*c+ except_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_stmt"));
            _res = invalid_except_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_except_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// except_star_block:
//     | invalid_except_star_stmt_indent
//     | 'except' '*' expression ['as' NAME] block_entry
//     | invalid_except_stmt
static excepthandler_ty
except_star_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    excepthandler_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_except_star_stmt_indent
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_star_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_star_stmt_indent"));
        void *invalid_except_star_stmt_indent_var;
        if (
            (invalid_except_star_stmt_indent_var = invalid_except_star_stmt_indent_rule(p))  // invalid_except_star_stmt_indent
        )
        {
            D(fprintf(stderr, "%*c+ except_star_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_star_stmt_indent"));
            _res = invalid_except_star_stmt_indent_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_star_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_except_star_stmt_indent"));
    }
    { // 'except' '*' expression ['as' NAME] block_entry
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_star_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*' expression ['as' NAME] block_entry"));
        Token * _keyword;
        Token * _literal;
        asdl_stmt_seq* b;
        expr_ty e;
        void *t;
        if (
            (_keyword = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (e = expression_rule(p))  // expression
            &&
            (t = _tmp_122_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (b = block_entry_rule(p))  // block_entry
        )
        {
            D(fprintf(stderr, "%*c+ except_star_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*' expression ['as' NAME] block_entry"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ExceptHandler ( e , ( t ) ? ( ( expr_ty ) t ) -> v . Name . id : NULL , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_star_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' '*' expression ['as' NAME] block_entry"));
    }
    if (p->call_invalid_rules) { // invalid_except_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_star_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_stmt"));
        void *invalid_except_stmt_var;
        if (
            (invalid_except_stmt_var = invalid_except_stmt_rule(p))  // invalid_except_stmt
        )
        {
            D(fprintf(stderr, "%*c+ except_star_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_stmt"));
            _res = invalid_except_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_star_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_except_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// finally_block: invalid_finally_stmt | 'finally' (&&':' block | braced_block)
static asdl_stmt_seq*
finally_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_finally_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> finally_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_finally_stmt"));
        void *invalid_finally_stmt_var;
        if (
            (invalid_finally_stmt_var = invalid_finally_stmt_rule(p))  // invalid_finally_stmt
        )
        {
            D(fprintf(stderr, "%*c+ finally_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_finally_stmt"));
            _res = invalid_finally_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s finally_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_finally_stmt"));
    }
    { // 'finally' (&&':' block | braced_block)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> finally_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally' (&&':' block | braced_block)"));
        Token * _keyword;
        void *a;
        if (
            (_keyword = _PyPegen_expect_token(p, 763))  // token='finally'
            &&
            (a = _tmp_123_rule(p))  // &&':' block | braced_block
        )
        {
            D(fprintf(stderr, "%*c+ finally_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally' (&&':' block | braced_block)"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s finally_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'finally' (&&':' block | braced_block)"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// except_block_nonewline:
//     | 'except' expression ['as' NAME] block_entry_nonewline
//     | 'except' block_entry_nonewline
//     | invalid_except_stmt_nonewline
static excepthandler_ty
except_block_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    excepthandler_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'except' expression ['as' NAME] block_entry_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' expression ['as' NAME] block_entry_nonewline"));
        Token * _keyword;
        asdl_stmt_seq* b;
        expr_ty e;
        void *t;
        if (
            (_keyword = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (e = expression_rule(p))  // expression
            &&
            (t = _tmp_124_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ except_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' expression ['as' NAME] block_entry_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ExceptHandler ( e , ( t ) ? ( ( expr_ty ) t ) -> v . Name . id : NULL , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' expression ['as' NAME] block_entry_nonewline"));
    }
    { // 'except' block_entry_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' block_entry_nonewline"));
        Token * _keyword;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ except_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' block_entry_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ExceptHandler ( NULL , NULL , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' block_entry_nonewline"));
    }
    if (p->call_invalid_rules) { // invalid_except_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_stmt_nonewline"));
        void *invalid_except_stmt_nonewline_var;
        if (
            (invalid_except_stmt_nonewline_var = invalid_except_stmt_nonewline_rule(p))  // invalid_except_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ except_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_stmt_nonewline"));
            _res = invalid_except_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_except_stmt_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// except_star_block_nonewline:
//     | 'except' '*' expression ['as' NAME] block_entry_nonewline
//     | invalid_except_stmt_nonewline
static excepthandler_ty
except_star_block_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    excepthandler_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'except' '*' expression ['as' NAME] block_entry_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_star_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*' expression ['as' NAME] block_entry_nonewline"));
        Token * _keyword;
        Token * _literal;
        asdl_stmt_seq* b;
        expr_ty e;
        void *t;
        if (
            (_keyword = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (e = expression_rule(p))  // expression
            &&
            (t = _tmp_125_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ except_star_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*' expression ['as' NAME] block_entry_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ExceptHandler ( e , ( t ) ? ( ( expr_ty ) t ) -> v . Name . id : NULL , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_star_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' '*' expression ['as' NAME] block_entry_nonewline"));
    }
    if (p->call_invalid_rules) { // invalid_except_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> except_star_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_stmt_nonewline"));
        void *invalid_except_stmt_nonewline_var;
        if (
            (invalid_except_stmt_nonewline_var = invalid_except_stmt_nonewline_rule(p))  // invalid_except_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ except_star_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_except_stmt_nonewline"));
            _res = invalid_except_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s except_star_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_except_stmt_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// finally_block_nonewline: 'finally' (&&':' block_nonewline | braced_block)
static asdl_stmt_seq*
finally_block_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_stmt_seq* _res = NULL;
    int _mark = p->mark;
    { // 'finally' (&&':' block_nonewline | braced_block)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> finally_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally' (&&':' block_nonewline | braced_block)"));
        Token * _keyword;
        void *a;
        if (
            (_keyword = _PyPegen_expect_token(p, 763))  // token='finally'
            &&
            (a = _tmp_126_rule(p))  // &&':' block_nonewline | braced_block
        )
        {
            D(fprintf(stderr, "%*c+ finally_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally' (&&':' block_nonewline | braced_block)"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s finally_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'finally' (&&':' block_nonewline | braced_block)"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// switch_stmt:
//     | "switch" named_expression ':' NEWLINE INDENT switchcase_block+ DEDENT
//     | "switch" named_expression ':' NEWLINE switchcase_block+
static stmt_ty
switch_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "switch" named_expression ':' NEWLINE INDENT switchcase_block+ DEDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> switch_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE INDENT switchcase_block+ DEDENT"));
        expr_ty _keyword;
        Token * _literal;
        asdl_switch_case_seq* cases;
        Token * dedent_var;
        Token * indent_var;
        Token * newline_var;
        expr_ty subject;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "switch"))  // soft_keyword='"switch"'
            &&
            (subject = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (indent_var = _PyPegen_expect_token(p, INDENT))  // token='INDENT'
            &&
            (cases = (asdl_switch_case_seq*)_loop1_127_rule(p))  // switchcase_block+
            &&
            (dedent_var = _PyPegen_expect_token(p, DEDENT))  // token='DEDENT'
        )
        {
            D(fprintf(stderr, "%*c+ switch_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE INDENT switchcase_block+ DEDENT"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Switch ( subject , cases , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s switch_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE INDENT switchcase_block+ DEDENT"));
    }
    { // "switch" named_expression ':' NEWLINE switchcase_block+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> switch_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE switchcase_block+"));
        expr_ty _keyword;
        Token * _literal;
        asdl_switch_case_seq* cases;
        Token * newline_var;
        expr_ty subject;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "switch"))  // soft_keyword='"switch"'
            &&
            (subject = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (cases = (asdl_switch_case_seq*)_loop1_128_rule(p))  // switchcase_block+
        )
        {
            D(fprintf(stderr, "%*c+ switch_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE switchcase_block+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Switch ( subject , cases , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s switch_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE switchcase_block+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// switchcase_block: "case" ','.(bitwiseor_pattern | 'None')+ block_entry
static switch_case_ty
switchcase_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    switch_case_ty _res = NULL;
    int _mark = p->mark;
    { // "case" ','.(bitwiseor_pattern | 'None')+ block_entry
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> switchcase_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" ','.(bitwiseor_pattern | 'None')+ block_entry"));
        expr_ty _keyword;
        asdl_stmt_seq* body;
        asdl_expr_seq* exprs;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "case"))  // soft_keyword='"case"'
            &&
            (exprs = (asdl_expr_seq*)_gather_129_rule(p))  // ','.(bitwiseor_pattern | 'None')+
            &&
            (body = block_entry_rule(p))  // block_entry
        )
        {
            D(fprintf(stderr, "%*c+ switchcase_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" ','.(bitwiseor_pattern | 'None')+ block_entry"));
            _res = _PyAST_switch_case ( exprs , body , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s switchcase_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"case\" ','.(bitwiseor_pattern | 'None')+ block_entry"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// switch_stmt_nonewline:
//     | "switch" named_expression ':' NEWLINE INDENT switchcase_block_nonewline+ DEDENT
//     | "switch" named_expression ':' NEWLINE switchcase_block_nonewline+
static stmt_ty
switch_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "switch" named_expression ':' NEWLINE INDENT switchcase_block_nonewline+ DEDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> switch_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE INDENT switchcase_block_nonewline+ DEDENT"));
        expr_ty _keyword;
        Token * _literal;
        asdl_switch_case_seq* cases;
        Token * dedent_var;
        Token * indent_var;
        Token * newline_var;
        expr_ty subject;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "switch"))  // soft_keyword='"switch"'
            &&
            (subject = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (indent_var = _PyPegen_expect_token(p, INDENT))  // token='INDENT'
            &&
            (cases = (asdl_switch_case_seq*)_loop1_131_rule(p))  // switchcase_block_nonewline+
            &&
            (dedent_var = _PyPegen_expect_token(p, DEDENT))  // token='DEDENT'
        )
        {
            D(fprintf(stderr, "%*c+ switch_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE INDENT switchcase_block_nonewline+ DEDENT"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Switch ( subject , cases , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s switch_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE INDENT switchcase_block_nonewline+ DEDENT"));
    }
    { // "switch" named_expression ':' NEWLINE switchcase_block_nonewline+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> switch_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE switchcase_block_nonewline+"));
        expr_ty _keyword;
        Token * _literal;
        asdl_switch_case_seq* cases;
        Token * newline_var;
        expr_ty subject;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "switch"))  // soft_keyword='"switch"'
            &&
            (subject = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (cases = (asdl_switch_case_seq*)_loop1_132_rule(p))  // switchcase_block_nonewline+
        )
        {
            D(fprintf(stderr, "%*c+ switch_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE switchcase_block_nonewline+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Switch ( subject , cases , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s switch_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"switch\" named_expression ':' NEWLINE switchcase_block_nonewline+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// switchcase_block_nonewline:
//     | "case" ','.(bitwiseor_pattern | 'None')+ block_entry_nonewline
static switch_case_ty
switchcase_block_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    switch_case_ty _res = NULL;
    int _mark = p->mark;
    { // "case" ','.(bitwiseor_pattern | 'None')+ block_entry_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> switchcase_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" ','.(bitwiseor_pattern | 'None')+ block_entry_nonewline"));
        expr_ty _keyword;
        asdl_stmt_seq* body;
        asdl_expr_seq* exprs;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "case"))  // soft_keyword='"case"'
            &&
            (exprs = (asdl_expr_seq*)_gather_133_rule(p))  // ','.(bitwiseor_pattern | 'None')+
            &&
            (body = block_entry_nonewline_rule(p))  // block_entry_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ switchcase_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" ','.(bitwiseor_pattern | 'None')+ block_entry_nonewline"));
            _res = _PyAST_switch_case ( exprs , body , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s switchcase_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"case\" ','.(bitwiseor_pattern | 'None')+ block_entry_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// bitwiseor_pattern: bitwiseor_pattern '|' bitwisexor_pattern | bitwisexor_pattern
static expr_ty bitwiseor_pattern_raw(Parser *);
static expr_ty
bitwiseor_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, bitwiseor_pattern_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_1 = _PyPegen_update_memo(p, _mark, bitwiseor_pattern_type, _res);
        if (tmpvar_1) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = bitwiseor_pattern_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
bitwiseor_pattern_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwiseor_pattern '|' bitwisexor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwiseor_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwiseor_pattern '|' bitwisexor_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = bitwiseor_pattern_rule(p))  // bitwiseor_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 18))  // token='|'
            &&
            (b = bitwisexor_pattern_rule(p))  // bitwisexor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ bitwiseor_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwiseor_pattern '|' bitwisexor_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , BitOr , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwiseor_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwiseor_pattern '|' bitwisexor_pattern"));
    }
    { // bitwisexor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwiseor_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwisexor_pattern"));
        expr_ty bitwisexor_pattern_var;
        if (
            (bitwisexor_pattern_var = bitwisexor_pattern_rule(p))  // bitwisexor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ bitwiseor_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwisexor_pattern"));
            _res = bitwisexor_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwiseor_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwisexor_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// bitwisexor_pattern: bitwisexor_pattern '^' bitwiseand_pattern | bitwiseand_pattern
static expr_ty bitwisexor_pattern_raw(Parser *);
static expr_ty
bitwisexor_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, bitwisexor_pattern_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_2 = _PyPegen_update_memo(p, _mark, bitwisexor_pattern_type, _res);
        if (tmpvar_2) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = bitwisexor_pattern_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
bitwisexor_pattern_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwisexor_pattern '^' bitwiseand_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwisexor_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwisexor_pattern '^' bitwiseand_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = bitwisexor_pattern_rule(p))  // bitwisexor_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 32))  // token='^'
            &&
            (b = bitwiseand_pattern_rule(p))  // bitwiseand_pattern
        )
        {
            D(fprintf(stderr, "%*c+ bitwisexor_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwisexor_pattern '^' bitwiseand_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , BitXor , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwisexor_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwisexor_pattern '^' bitwiseand_pattern"));
    }
    { // bitwiseand_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwisexor_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwiseand_pattern"));
        expr_ty bitwiseand_pattern_var;
        if (
            (bitwiseand_pattern_var = bitwiseand_pattern_rule(p))  // bitwiseand_pattern
        )
        {
            D(fprintf(stderr, "%*c+ bitwisexor_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwiseand_pattern"));
            _res = bitwiseand_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwisexor_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwiseand_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// bitwiseand_pattern: bitwiseand_pattern '&' shift_pattern | shift_pattern
static expr_ty bitwiseand_pattern_raw(Parser *);
static expr_ty
bitwiseand_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, bitwiseand_pattern_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_3 = _PyPegen_update_memo(p, _mark, bitwiseand_pattern_type, _res);
        if (tmpvar_3) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = bitwiseand_pattern_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
bitwiseand_pattern_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwiseand_pattern '&' shift_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwiseand_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwiseand_pattern '&' shift_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = bitwiseand_pattern_rule(p))  // bitwiseand_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 19))  // token='&'
            &&
            (b = shift_pattern_rule(p))  // shift_pattern
        )
        {
            D(fprintf(stderr, "%*c+ bitwiseand_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwiseand_pattern '&' shift_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , BitAnd , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwiseand_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwiseand_pattern '&' shift_pattern"));
    }
    { // shift_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwiseand_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_pattern"));
        expr_ty shift_pattern_var;
        if (
            (shift_pattern_var = shift_pattern_rule(p))  // shift_pattern
        )
        {
            D(fprintf(stderr, "%*c+ bitwiseand_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_pattern"));
            _res = shift_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwiseand_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "shift_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// shift_pattern:
//     | shift_pattern '<<' sum_pattern
//     | shift_pattern '>>' sum_pattern
//     | sum_pattern
static expr_ty shift_pattern_raw(Parser *);
static expr_ty
shift_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, shift_pattern_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_4 = _PyPegen_update_memo(p, _mark, shift_pattern_type, _res);
        if (tmpvar_4) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = shift_pattern_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
shift_pattern_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // shift_pattern '<<' sum_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> shift_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_pattern '<<' sum_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = shift_pattern_rule(p))  // shift_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 33))  // token='<<'
            &&
            (b = sum_pattern_rule(p))  // sum_pattern
        )
        {
            D(fprintf(stderr, "%*c+ shift_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_pattern '<<' sum_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , LShift , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s shift_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "shift_pattern '<<' sum_pattern"));
    }
    { // shift_pattern '>>' sum_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> shift_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_pattern '>>' sum_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = shift_pattern_rule(p))  // shift_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 34))  // token='>>'
            &&
            (b = sum_pattern_rule(p))  // sum_pattern
        )
        {
            D(fprintf(stderr, "%*c+ shift_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_pattern '>>' sum_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , RShift , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s shift_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "shift_pattern '>>' sum_pattern"));
    }
    { // sum_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> shift_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_pattern"));
        expr_ty sum_pattern_var;
        if (
            (sum_pattern_var = sum_pattern_rule(p))  // sum_pattern
        )
        {
            D(fprintf(stderr, "%*c+ shift_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_pattern"));
            _res = sum_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s shift_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// sum_pattern: sum_pattern '+' term_pattern | sum_pattern '-' term_pattern | term_pattern
static expr_ty sum_pattern_raw(Parser *);
static expr_ty
sum_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, sum_pattern_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_5 = _PyPegen_update_memo(p, _mark, sum_pattern_type, _res);
        if (tmpvar_5) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = sum_pattern_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
sum_pattern_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // sum_pattern '+' term_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_pattern '+' term_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = sum_pattern_rule(p))  // sum_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
            &&
            (b = term_pattern_rule(p))  // term_pattern
        )
        {
            D(fprintf(stderr, "%*c+ sum_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_pattern '+' term_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Add , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum_pattern '+' term_pattern"));
    }
    { // sum_pattern '-' term_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_pattern '-' term_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = sum_pattern_rule(p))  // sum_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (b = term_pattern_rule(p))  // term_pattern
        )
        {
            D(fprintf(stderr, "%*c+ sum_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_pattern '-' term_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Sub , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum_pattern '-' term_pattern"));
    }
    { // term_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern"));
        expr_ty term_pattern_var;
        if (
            (term_pattern_var = term_pattern_rule(p))  // term_pattern
        )
        {
            D(fprintf(stderr, "%*c+ sum_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern"));
            _res = term_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// term_pattern:
//     | term_pattern '*' factor_pattern
//     | term_pattern '/' factor_pattern
//     | term_pattern '//' factor_pattern
//     | term_pattern '%' factor_pattern
//     | term_pattern '@' factor_pattern
//     | factor_pattern
static expr_ty term_pattern_raw(Parser *);
static expr_ty
term_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, term_pattern_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_6 = _PyPegen_update_memo(p, _mark, term_pattern_type, _res);
        if (tmpvar_6) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = term_pattern_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
term_pattern_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // term_pattern '*' factor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern '*' factor_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_pattern_rule(p))  // term_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (b = factor_pattern_rule(p))  // factor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ term_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern '*' factor_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Mult , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term_pattern '*' factor_pattern"));
    }
    { // term_pattern '/' factor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern '/' factor_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_pattern_rule(p))  // term_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (b = factor_pattern_rule(p))  // factor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ term_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern '/' factor_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Div , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term_pattern '/' factor_pattern"));
    }
    { // term_pattern '//' factor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern '//' factor_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_pattern_rule(p))  // term_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 47))  // token='//'
            &&
            (b = factor_pattern_rule(p))  // factor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ term_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern '//' factor_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , FloorDiv , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term_pattern '//' factor_pattern"));
    }
    { // term_pattern '%' factor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern '%' factor_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_pattern_rule(p))  // term_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 24))  // token='%'
            &&
            (b = factor_pattern_rule(p))  // factor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ term_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern '%' factor_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Mod , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term_pattern '%' factor_pattern"));
    }
    { // term_pattern '@' factor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern '@' factor_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_pattern_rule(p))  // term_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 49))  // token='@'
            &&
            (b = factor_pattern_rule(p))  // factor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ term_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term_pattern '@' factor_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( expr_ty , 5 , "The '@' operator is" , _PyAST_BinOp ( a , MatMult , b , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term_pattern '@' factor_pattern"));
    }
    { // factor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "factor_pattern"));
        expr_ty factor_pattern_var;
        if (
            (factor_pattern_var = factor_pattern_rule(p))  // factor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ term_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "factor_pattern"));
            _res = factor_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "factor_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// factor_pattern:
//     | '+' factor_pattern
//     | '-' factor_pattern
//     | '~' factor_pattern
//     | '!' factor_pattern
//     | power_pattern
static expr_ty
factor_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, factor_pattern_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '+' factor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+' factor_pattern"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
            &&
            (a = factor_pattern_rule(p))  // factor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ factor_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+' factor_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( UAdd , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'+' factor_pattern"));
    }
    { // '-' factor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-' factor_pattern"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (a = factor_pattern_rule(p))  // factor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ factor_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-' factor_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( USub , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'-' factor_pattern"));
    }
    { // '~' factor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'~' factor_pattern"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 31))  // token='~'
            &&
            (a = factor_pattern_rule(p))  // factor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ factor_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'~' factor_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( Invert , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'~' factor_pattern"));
    }
    { // '!' factor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' factor_pattern"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 54))  // token='!'
            &&
            (a = factor_pattern_rule(p))  // factor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ factor_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' factor_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( Not , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!' factor_pattern"));
    }
    { // power_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "power_pattern"));
        expr_ty power_pattern_var;
        if (
            (power_pattern_var = power_pattern_rule(p))  // power_pattern
        )
        {
            D(fprintf(stderr, "%*c+ factor_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "power_pattern"));
            _res = power_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "power_pattern"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, factor_pattern_type, _res);
    p->level--;
    return _res;
}

// power_pattern: number_pattern '**' factor_pattern | number_pattern
static expr_ty
power_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // number_pattern '**' factor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> power_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "number_pattern '**' factor_pattern"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = number_pattern_rule(p))  // number_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (b = factor_pattern_rule(p))  // factor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ power_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "number_pattern '**' factor_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Pow , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s power_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "number_pattern '**' factor_pattern"));
    }
    { // number_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> power_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "number_pattern"));
        expr_ty number_pattern_var;
        if (
            (number_pattern_var = number_pattern_rule(p))  // number_pattern
        )
        {
            D(fprintf(stderr, "%*c+ power_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "number_pattern"));
            _res = number_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s power_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "number_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// number_pattern: 'True' | 'False' | NUMBER
static expr_ty
number_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'True'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> number_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 714))  // token='True'
        )
        {
            D(fprintf(stderr, "%*c+ number_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_True , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s number_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'True'"));
    }
    { // 'False'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> number_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 716))  // token='False'
        )
        {
            D(fprintf(stderr, "%*c+ number_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_False , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s number_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'False'"));
    }
    { // NUMBER
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> number_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NUMBER"));
        expr_ty intnum;
        if (
            (intnum = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ number_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NUMBER"));
            _res = intnum -> kind == Constant_kind ? PyLong_CheckExact ( intnum ) ? intnum : NULL : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s number_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NUMBER"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// match_stmt:
//     | "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT
//     | "match" subject_expr ':' NEWLINE case_block+
//     | invalid_match_stmt
static stmt_ty
match_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "match" subject_expr ':' NEWLINE INDENT case_block+ DEDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> match_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT"));
        expr_ty _keyword;
        Token * _literal;
        asdl_match_case_seq* cases;
        Token * dedent_var;
        Token * indent_var;
        Token * newline_var;
        expr_ty subject;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "match"))  // soft_keyword='"match"'
            &&
            (subject = subject_expr_rule(p))  // subject_expr
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (indent_var = _PyPegen_expect_token(p, INDENT))  // token='INDENT'
            &&
            (cases = (asdl_match_case_seq*)_loop1_135_rule(p))  // case_block+
            &&
            (dedent_var = _PyPegen_expect_token(p, DEDENT))  // token='DEDENT'
        )
        {
            D(fprintf(stderr, "%*c+ match_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 10 , "Pattern matching is" , _PyAST_Match ( subject , cases , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s match_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE INDENT case_block+ DEDENT"));
    }
    { // "match" subject_expr ':' NEWLINE case_block+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> match_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE case_block+"));
        expr_ty _keyword;
        Token * _literal;
        asdl_match_case_seq* cases;
        Token * newline_var;
        expr_ty subject;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "match"))  // soft_keyword='"match"'
            &&
            (subject = subject_expr_rule(p))  // subject_expr
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (cases = (asdl_match_case_seq*)_loop1_136_rule(p))  // case_block+
        )
        {
            D(fprintf(stderr, "%*c+ match_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE case_block+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 10 , "Pattern matching is" , _PyAST_Match ( subject , cases , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s match_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE case_block+"));
    }
    if (p->call_invalid_rules) { // invalid_match_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> match_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_match_stmt"));
        void *invalid_match_stmt_var;
        if (
            (invalid_match_stmt_var = invalid_match_stmt_rule(p))  // invalid_match_stmt
        )
        {
            D(fprintf(stderr, "%*c+ match_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_match_stmt"));
            _res = invalid_match_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s match_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_match_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// match_stmt_nonewline:
//     | "match" subject_expr ':' NEWLINE INDENT case_block_nonewline+ DEDENT
//     | "match" subject_expr ':' NEWLINE case_block_nonewline+
static stmt_ty
match_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "match" subject_expr ':' NEWLINE INDENT case_block_nonewline+ DEDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> match_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE INDENT case_block_nonewline+ DEDENT"));
        expr_ty _keyword;
        Token * _literal;
        asdl_match_case_seq* cases;
        Token * dedent_var;
        Token * indent_var;
        Token * newline_var;
        expr_ty subject;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "match"))  // soft_keyword='"match"'
            &&
            (subject = subject_expr_rule(p))  // subject_expr
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (indent_var = _PyPegen_expect_token(p, INDENT))  // token='INDENT'
            &&
            (cases = (asdl_match_case_seq*)_loop1_137_rule(p))  // case_block_nonewline+
            &&
            (dedent_var = _PyPegen_expect_token(p, DEDENT))  // token='DEDENT'
        )
        {
            D(fprintf(stderr, "%*c+ match_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE INDENT case_block_nonewline+ DEDENT"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 10 , "Pattern matching is" , _PyAST_Match ( subject , cases , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s match_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE INDENT case_block_nonewline+ DEDENT"));
    }
    { // "match" subject_expr ':' NEWLINE case_block_nonewline+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> match_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE case_block_nonewline+"));
        expr_ty _keyword;
        Token * _literal;
        asdl_match_case_seq* cases;
        Token * newline_var;
        expr_ty subject;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "match"))  // soft_keyword='"match"'
            &&
            (subject = subject_expr_rule(p))  // subject_expr
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (cases = (asdl_match_case_seq*)_loop1_138_rule(p))  // case_block_nonewline+
        )
        {
            D(fprintf(stderr, "%*c+ match_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE case_block_nonewline+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 10 , "Pattern matching is" , _PyAST_Match ( subject , cases , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s match_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE case_block_nonewline+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// subject_expr: star_named_expression ',' star_named_expressions? | named_expression
static expr_ty
subject_expr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // star_named_expression ',' star_named_expressions?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> subject_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_named_expression ',' star_named_expressions?"));
        Token * _literal;
        expr_ty value;
        void *values;
        if (
            (value = star_named_expression_rule(p))  // star_named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (values = star_named_expressions_rule(p), !p->error_indicator)  // star_named_expressions?
        )
        {
            D(fprintf(stderr, "%*c+ subject_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_named_expression ',' star_named_expressions?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Tuple ( CHECK ( asdl_expr_seq* , _PyPegen_seq_insert_in_front ( p , value , values ) ) , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s subject_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_named_expression ',' star_named_expressions?"));
    }
    { // named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> subject_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "named_expression"));
        expr_ty named_expression_var;
        if (
            (named_expression_var = named_expression_rule(p))  // named_expression
        )
        {
            D(fprintf(stderr, "%*c+ subject_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "named_expression"));
            _res = named_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s subject_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "named_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// case_block: invalid_case_block | "case" patterns guard? block_entry
static match_case_ty
case_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    match_case_ty _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_case_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> case_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_case_block"));
        void *invalid_case_block_var;
        if (
            (invalid_case_block_var = invalid_case_block_rule(p))  // invalid_case_block
        )
        {
            D(fprintf(stderr, "%*c+ case_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_case_block"));
            _res = invalid_case_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s case_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_case_block"));
    }
    { // "case" patterns guard? block_entry
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> case_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? block_entry"));
        expr_ty _keyword;
        asdl_stmt_seq* body;
        void *guard;
        pattern_ty pattern;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "case"))  // soft_keyword='"case"'
            &&
            (pattern = patterns_rule(p))  // patterns
            &&
            (guard = guard_rule(p), !p->error_indicator)  // guard?
            &&
            (body = block_entry_rule(p))  // block_entry
        )
        {
            D(fprintf(stderr, "%*c+ case_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? block_entry"));
            _res = _PyAST_match_case ( pattern , guard , body , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s case_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? block_entry"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// case_block_nonewline: "case" patterns guard? block_entry_nonewline
static match_case_ty
case_block_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    match_case_ty _res = NULL;
    int _mark = p->mark;
    { // "case" patterns guard? block_entry_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> case_block_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? block_entry_nonewline"));
        expr_ty _keyword;
        asdl_stmt_seq* body;
        void *guard;
        pattern_ty pattern;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "case"))  // soft_keyword='"case"'
            &&
            (pattern = patterns_rule(p))  // patterns
            &&
            (guard = guard_rule(p), !p->error_indicator)  // guard?
            &&
            (body = block_entry_nonewline_rule(p))  // block_entry_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ case_block_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? block_entry_nonewline"));
            _res = _PyAST_match_case ( pattern , guard , body , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s case_block_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? block_entry_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// guard: 'if' named_expression
static expr_ty
guard_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // 'if' named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> guard[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression"));
        Token * _keyword;
        expr_ty guard;
        if (
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (guard = named_expression_rule(p))  // named_expression
        )
        {
            D(fprintf(stderr, "%*c+ guard[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression"));
            _res = guard;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s guard[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'if' named_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// patterns: open_sequence_pattern | pattern
static pattern_ty
patterns_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // open_sequence_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> patterns[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "open_sequence_pattern"));
        asdl_pattern_seq* patterns;
        if (
            (patterns = (asdl_pattern_seq*)open_sequence_pattern_rule(p))  // open_sequence_pattern
        )
        {
            D(fprintf(stderr, "%*c+ patterns[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "open_sequence_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchSequence ( patterns , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s patterns[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "open_sequence_pattern"));
    }
    { // pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> patterns[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "pattern"));
        pattern_ty pattern_var;
        if (
            (pattern_var = pattern_rule(p))  // pattern
        )
        {
            D(fprintf(stderr, "%*c+ patterns[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "pattern"));
            _res = pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s patterns[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// pattern: as_pattern | or_pattern
static pattern_ty
pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    { // as_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "as_pattern"));
        pattern_ty as_pattern_var;
        if (
            (as_pattern_var = as_pattern_rule(p))  // as_pattern
        )
        {
            D(fprintf(stderr, "%*c+ pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "as_pattern"));
            _res = as_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "as_pattern"));
    }
    { // or_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "or_pattern"));
        pattern_ty or_pattern_var;
        if (
            (or_pattern_var = or_pattern_rule(p))  // or_pattern
        )
        {
            D(fprintf(stderr, "%*c+ pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "or_pattern"));
            _res = or_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "or_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// as_pattern: or_pattern 'as' pattern_capture_target | invalid_as_pattern
static pattern_ty
as_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // or_pattern 'as' pattern_capture_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> as_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "or_pattern 'as' pattern_capture_target"));
        Token * _keyword;
        pattern_ty pattern;
        expr_ty target;
        if (
            (pattern = or_pattern_rule(p))  // or_pattern
            &&
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (target = pattern_capture_target_rule(p))  // pattern_capture_target
        )
        {
            D(fprintf(stderr, "%*c+ as_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "or_pattern 'as' pattern_capture_target"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchAs ( pattern , target -> v . Name . id , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s as_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "or_pattern 'as' pattern_capture_target"));
    }
    if (p->call_invalid_rules) { // invalid_as_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> as_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_as_pattern"));
        void *invalid_as_pattern_var;
        if (
            (invalid_as_pattern_var = invalid_as_pattern_rule(p))  // invalid_as_pattern
        )
        {
            D(fprintf(stderr, "%*c+ as_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_as_pattern"));
            _res = invalid_as_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s as_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_as_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// or_pattern: '|'.closed_pattern+
static pattern_ty
or_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '|'.closed_pattern+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> or_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|'.closed_pattern+"));
        asdl_pattern_seq* patterns;
        if (
            (patterns = (asdl_pattern_seq*)_gather_139_rule(p))  // '|'.closed_pattern+
        )
        {
            D(fprintf(stderr, "%*c+ or_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|'.closed_pattern+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = asdl_seq_LEN ( patterns ) == 1 ? asdl_seq_GET ( patterns , 0 ) : _PyAST_MatchOr ( patterns , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s or_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|'.closed_pattern+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// closed_pattern:
//     | literal_pattern
//     | capture_pattern
//     | wildcard_pattern
//     | value_pattern
//     | group_pattern
//     | sequence_pattern
//     | mapping_pattern
//     | class_pattern
static pattern_ty
closed_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    if (_PyPegen_is_memoized(p, closed_pattern_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    { // literal_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "literal_pattern"));
        pattern_ty literal_pattern_var;
        if (
            (literal_pattern_var = literal_pattern_rule(p))  // literal_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "literal_pattern"));
            _res = literal_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "literal_pattern"));
    }
    { // capture_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "capture_pattern"));
        pattern_ty capture_pattern_var;
        if (
            (capture_pattern_var = capture_pattern_rule(p))  // capture_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "capture_pattern"));
            _res = capture_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "capture_pattern"));
    }
    { // wildcard_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "wildcard_pattern"));
        pattern_ty wildcard_pattern_var;
        if (
            (wildcard_pattern_var = wildcard_pattern_rule(p))  // wildcard_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "wildcard_pattern"));
            _res = wildcard_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "wildcard_pattern"));
    }
    { // value_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "value_pattern"));
        pattern_ty value_pattern_var;
        if (
            (value_pattern_var = value_pattern_rule(p))  // value_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "value_pattern"));
            _res = value_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "value_pattern"));
    }
    { // group_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "group_pattern"));
        pattern_ty group_pattern_var;
        if (
            (group_pattern_var = group_pattern_rule(p))  // group_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "group_pattern"));
            _res = group_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "group_pattern"));
    }
    { // sequence_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sequence_pattern"));
        pattern_ty sequence_pattern_var;
        if (
            (sequence_pattern_var = sequence_pattern_rule(p))  // sequence_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sequence_pattern"));
            _res = sequence_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sequence_pattern"));
    }
    { // mapping_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "mapping_pattern"));
        pattern_ty mapping_pattern_var;
        if (
            (mapping_pattern_var = mapping_pattern_rule(p))  // mapping_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "mapping_pattern"));
            _res = mapping_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "mapping_pattern"));
    }
    { // class_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> closed_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "class_pattern"));
        pattern_ty class_pattern_var;
        if (
            (class_pattern_var = class_pattern_rule(p))  // class_pattern
        )
        {
            D(fprintf(stderr, "%*c+ closed_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "class_pattern"));
            _res = class_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s closed_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "class_pattern"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, closed_pattern_type, _res);
    p->level--;
    return _res;
}

// literal_pattern:
//     | signed_number !('+' | '-')
//     | complex_number
//     | strings
//     | 'None'
//     | 'True'
//     | 'False'
static pattern_ty
literal_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // signed_number !('+' | '-')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "signed_number !('+' | '-')"));
        expr_ty value;
        if (
            (value = signed_number_rule(p))  // signed_number
            &&
            _PyPegen_lookahead(0, _tmp_141_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "signed_number !('+' | '-')"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchValue ( value , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "signed_number !('+' | '-')"));
    }
    { // complex_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "complex_number"));
        expr_ty value;
        if (
            (value = complex_number_rule(p))  // complex_number
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "complex_number"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchValue ( value , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "complex_number"));
    }
    { // strings
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "strings"));
        expr_ty value;
        if (
            (value = strings_rule(p))  // strings
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "strings"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchValue ( value , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "strings"));
    }
    { // 'None'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 715))  // token='None'
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchSingleton ( Py_None , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'None'"));
    }
    { // 'True'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 714))  // token='True'
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchSingleton ( Py_True , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'True'"));
    }
    { // 'False'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 716))  // token='False'
        )
        {
            D(fprintf(stderr, "%*c+ literal_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchSingleton ( Py_False , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'False'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// literal_expr:
//     | signed_number !('+' | '-')
//     | complex_number
//     | strings
//     | 'None'
//     | 'True'
//     | 'False'
static expr_ty
literal_expr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // signed_number !('+' | '-')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "signed_number !('+' | '-')"));
        expr_ty signed_number_var;
        if (
            (signed_number_var = signed_number_rule(p))  // signed_number
            &&
            _PyPegen_lookahead(0, _tmp_142_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "signed_number !('+' | '-')"));
            _res = signed_number_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "signed_number !('+' | '-')"));
    }
    { // complex_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "complex_number"));
        expr_ty complex_number_var;
        if (
            (complex_number_var = complex_number_rule(p))  // complex_number
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "complex_number"));
            _res = complex_number_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "complex_number"));
    }
    { // strings
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "strings"));
        expr_ty strings_var;
        if (
            (strings_var = strings_rule(p))  // strings
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "strings"));
            _res = strings_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "strings"));
    }
    { // 'None'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 715))  // token='None'
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_None , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'None'"));
    }
    { // 'True'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 714))  // token='True'
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_True , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'True'"));
    }
    { // 'False'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> literal_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 716))  // token='False'
        )
        {
            D(fprintf(stderr, "%*c+ literal_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_False , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s literal_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'False'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// complex_number:
//     | signed_real_number '+' imaginary_number
//     | signed_real_number '-' imaginary_number
static expr_ty
complex_number_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // signed_real_number '+' imaginary_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> complex_number[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "signed_real_number '+' imaginary_number"));
        Token * _literal;
        expr_ty imag;
        expr_ty real;
        if (
            (real = signed_real_number_rule(p))  // signed_real_number
            &&
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
            &&
            (imag = imaginary_number_rule(p))  // imaginary_number
        )
        {
            D(fprintf(stderr, "%*c+ complex_number[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "signed_real_number '+' imaginary_number"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( real , Add , imag , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s complex_number[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "signed_real_number '+' imaginary_number"));
    }
    { // signed_real_number '-' imaginary_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> complex_number[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "signed_real_number '-' imaginary_number"));
        Token * _literal;
        expr_ty imag;
        expr_ty real;
        if (
            (real = signed_real_number_rule(p))  // signed_real_number
            &&
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (imag = imaginary_number_rule(p))  // imaginary_number
        )
        {
            D(fprintf(stderr, "%*c+ complex_number[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "signed_real_number '-' imaginary_number"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( real , Sub , imag , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s complex_number[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "signed_real_number '-' imaginary_number"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// signed_number: NUMBER | '-' NUMBER
static expr_ty
signed_number_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NUMBER
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> signed_number[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NUMBER"));
        expr_ty number_var;
        if (
            (number_var = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ signed_number[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NUMBER"));
            _res = number_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s signed_number[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NUMBER"));
    }
    { // '-' NUMBER
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> signed_number[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-' NUMBER"));
        Token * _literal;
        expr_ty number;
        if (
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (number = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ signed_number[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-' NUMBER"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( USub , number , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s signed_number[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'-' NUMBER"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// signed_real_number: real_number | '-' real_number
static expr_ty
signed_real_number_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // real_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> signed_real_number[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "real_number"));
        expr_ty real_number_var;
        if (
            (real_number_var = real_number_rule(p))  // real_number
        )
        {
            D(fprintf(stderr, "%*c+ signed_real_number[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "real_number"));
            _res = real_number_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s signed_real_number[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "real_number"));
    }
    { // '-' real_number
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> signed_real_number[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-' real_number"));
        Token * _literal;
        expr_ty real;
        if (
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (real = real_number_rule(p))  // real_number
        )
        {
            D(fprintf(stderr, "%*c+ signed_real_number[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-' real_number"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( USub , real , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s signed_real_number[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'-' real_number"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// real_number: NUMBER
static expr_ty
real_number_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // NUMBER
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> real_number[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NUMBER"));
        expr_ty real;
        if (
            (real = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ real_number[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NUMBER"));
            _res = _PyPegen_ensure_real ( p , real );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s real_number[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NUMBER"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// imaginary_number: NUMBER
static expr_ty
imaginary_number_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // NUMBER
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> imaginary_number[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NUMBER"));
        expr_ty imag;
        if (
            (imag = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ imaginary_number[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NUMBER"));
            _res = _PyPegen_ensure_imaginary ( p , imag );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s imaginary_number[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NUMBER"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// capture_pattern: pattern_capture_target
static pattern_ty
capture_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // pattern_capture_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> capture_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "pattern_capture_target"));
        expr_ty target;
        if (
            (target = pattern_capture_target_rule(p))  // pattern_capture_target
        )
        {
            D(fprintf(stderr, "%*c+ capture_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "pattern_capture_target"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchAs ( NULL , target -> v . Name . id , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s capture_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "pattern_capture_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// pattern_capture_target: !"_" NAME !('.' | '(' | '=')
static expr_ty
pattern_capture_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // !"_" NAME !('.' | '(' | '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> pattern_capture_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!\"_\" NAME !('.' | '(' | '=')"));
        expr_ty name;
        if (
            _PyPegen_lookahead_with_string(0, _PyPegen_expect_soft_keyword, p, "_")
            &&
            (name = _PyPegen_name_token(p))  // NAME
            &&
            _PyPegen_lookahead(0, _tmp_143_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ pattern_capture_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!\"_\" NAME !('.' | '(' | '=')"));
            _res = _PyPegen_set_expr_context ( p , name , Store );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s pattern_capture_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "!\"_\" NAME !('.' | '(' | '=')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// wildcard_pattern: "_"
static pattern_ty
wildcard_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "_"
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> wildcard_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"_\""));
        expr_ty _keyword;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "_"))  // soft_keyword='"_"'
        )
        {
            D(fprintf(stderr, "%*c+ wildcard_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"_\""));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchAs ( NULL , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s wildcard_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"_\""));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// value_pattern: attr !('.' | '(' | '=')
static pattern_ty
value_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // attr !('.' | '(' | '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> value_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "attr !('.' | '(' | '=')"));
        expr_ty attr;
        if (
            (attr = attr_rule(p))  // attr
            &&
            _PyPegen_lookahead(0, _tmp_144_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ value_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "attr !('.' | '(' | '=')"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchValue ( attr , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s value_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "attr !('.' | '(' | '=')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// attr: name_or_attr '.' NAME
static expr_ty attr_raw(Parser *);
static expr_ty
attr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, attr_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_7 = _PyPegen_update_memo(p, _mark, attr_type, _res);
        if (tmpvar_7) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = attr_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
attr_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // name_or_attr '.' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> attr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '.' NAME"));
        Token * _literal;
        expr_ty attr;
        expr_ty value;
        if (
            (value = name_or_attr_rule(p))  // name_or_attr
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (attr = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ attr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '.' NAME"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Attribute ( value , attr -> v . Name . id , Load , 0 , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s attr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "name_or_attr '.' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// name_or_attr: attr | NAME
static expr_ty
name_or_attr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // attr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> name_or_attr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "attr"));
        expr_ty attr_var;
        if (
            (attr_var = attr_rule(p))  // attr
        )
        {
            D(fprintf(stderr, "%*c+ name_or_attr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "attr"));
            _res = attr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s name_or_attr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "attr"));
    }
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> name_or_attr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
        expr_ty name_var;
        if (
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ name_or_attr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
            _res = name_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s name_or_attr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// group_pattern: '(' pattern ')'
static pattern_ty
group_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    { // '(' pattern ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> group_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' pattern ')'"));
        Token * _literal;
        Token * _literal_1;
        pattern_ty pattern;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (pattern = pattern_rule(p))  // pattern
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ group_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' pattern ')'"));
            _res = pattern;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s group_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' pattern ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// sequence_pattern: '[' maybe_sequence_pattern? ']' | '(' open_sequence_pattern? ')'
static pattern_ty
sequence_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '[' maybe_sequence_pattern? ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sequence_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' maybe_sequence_pattern? ']'"));
        Token * _literal;
        Token * _literal_1;
        void *patterns;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (patterns = maybe_sequence_pattern_rule(p), !p->error_indicator)  // maybe_sequence_pattern?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ sequence_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' maybe_sequence_pattern? ']'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchSequence ( patterns , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sequence_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'[' maybe_sequence_pattern? ']'"));
    }
    { // '(' open_sequence_pattern? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sequence_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' open_sequence_pattern? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *patterns;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (patterns = open_sequence_pattern_rule(p), !p->error_indicator)  // open_sequence_pattern?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ sequence_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' open_sequence_pattern? ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchSequence ( patterns , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sequence_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' open_sequence_pattern? ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// open_sequence_pattern: maybe_star_pattern ',' maybe_sequence_pattern?
static asdl_seq*
open_sequence_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // maybe_star_pattern ',' maybe_sequence_pattern?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> open_sequence_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "maybe_star_pattern ',' maybe_sequence_pattern?"));
        Token * _literal;
        pattern_ty pattern;
        void *patterns;
        if (
            (pattern = maybe_star_pattern_rule(p))  // maybe_star_pattern
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (patterns = maybe_sequence_pattern_rule(p), !p->error_indicator)  // maybe_sequence_pattern?
        )
        {
            D(fprintf(stderr, "%*c+ open_sequence_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "maybe_star_pattern ',' maybe_sequence_pattern?"));
            _res = _PyPegen_seq_insert_in_front ( p , pattern , patterns );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s open_sequence_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "maybe_star_pattern ',' maybe_sequence_pattern?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// maybe_sequence_pattern: ','.maybe_star_pattern+ ','?
static asdl_seq*
maybe_sequence_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.maybe_star_pattern+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> maybe_sequence_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.maybe_star_pattern+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq * patterns;
        if (
            (patterns = _gather_145_rule(p))  // ','.maybe_star_pattern+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ maybe_sequence_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.maybe_star_pattern+ ','?"));
            _res = patterns;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s maybe_sequence_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.maybe_star_pattern+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// maybe_star_pattern: star_pattern | pattern
static pattern_ty
maybe_star_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    { // star_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> maybe_star_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_pattern"));
        pattern_ty star_pattern_var;
        if (
            (star_pattern_var = star_pattern_rule(p))  // star_pattern
        )
        {
            D(fprintf(stderr, "%*c+ maybe_star_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_pattern"));
            _res = star_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s maybe_star_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_pattern"));
    }
    { // pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> maybe_star_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "pattern"));
        pattern_ty pattern_var;
        if (
            (pattern_var = pattern_rule(p))  // pattern
        )
        {
            D(fprintf(stderr, "%*c+ maybe_star_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "pattern"));
            _res = pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s maybe_star_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_pattern: '*' pattern_capture_target | '*' wildcard_pattern
static pattern_ty
star_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    if (_PyPegen_is_memoized(p, star_pattern_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '*' pattern_capture_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' pattern_capture_target"));
        Token * _literal;
        expr_ty target;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (target = pattern_capture_target_rule(p))  // pattern_capture_target
        )
        {
            D(fprintf(stderr, "%*c+ star_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' pattern_capture_target"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchStar ( target -> v . Name . id , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' pattern_capture_target"));
    }
    { // '*' wildcard_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' wildcard_pattern"));
        Token * _literal;
        pattern_ty wildcard_pattern_var;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (wildcard_pattern_var = wildcard_pattern_rule(p))  // wildcard_pattern
        )
        {
            D(fprintf(stderr, "%*c+ star_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' wildcard_pattern"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchStar ( NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' wildcard_pattern"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, star_pattern_type, _res);
    p->level--;
    return _res;
}

// mapping_pattern:
//     | '{' '}'
//     | '{' double_star_pattern ','? '}'
//     | '{' items_pattern ',' double_star_pattern ','? '}'
//     | '{' items_pattern ','? '}'
static pattern_ty
mapping_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '{' '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> mapping_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' '}'"));
        Token * _literal;
        Token * _literal_1;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ mapping_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchMapping ( NULL , NULL , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s mapping_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' '}'"));
    }
    { // '{' double_star_pattern ','? '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> mapping_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' double_star_pattern ','? '}'"));
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty rest;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (rest = double_star_pattern_rule(p))  // double_star_pattern
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ mapping_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' double_star_pattern ','? '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchMapping ( NULL , NULL , rest -> v . Name . id , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s mapping_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' double_star_pattern ','? '}'"));
    }
    { // '{' items_pattern ',' double_star_pattern ','? '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> mapping_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' items_pattern ',' double_star_pattern ','? '}'"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq* items;
        expr_ty rest;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (items = items_pattern_rule(p))  // items_pattern
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (rest = double_star_pattern_rule(p))  // double_star_pattern
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_2 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ mapping_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' items_pattern ',' double_star_pattern ','? '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchMapping ( CHECK ( asdl_expr_seq* , _PyPegen_get_pattern_keys ( p , items ) ) , CHECK ( asdl_pattern_seq* , _PyPegen_get_patterns ( p , items ) ) , rest -> v . Name . id , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s mapping_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' items_pattern ',' double_star_pattern ','? '}'"));
    }
    { // '{' items_pattern ','? '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> mapping_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' items_pattern ','? '}'"));
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq* items;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (items = items_pattern_rule(p))  // items_pattern
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ mapping_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' items_pattern ','? '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchMapping ( CHECK ( asdl_expr_seq* , _PyPegen_get_pattern_keys ( p , items ) ) , CHECK ( asdl_pattern_seq* , _PyPegen_get_patterns ( p , items ) ) , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s mapping_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' items_pattern ','? '}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// items_pattern: ','.key_value_pattern+
static asdl_seq*
items_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.key_value_pattern+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> items_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.key_value_pattern+"));
        asdl_seq * _gather_147_var;
        if (
            (_gather_147_var = _gather_147_rule(p))  // ','.key_value_pattern+
        )
        {
            D(fprintf(stderr, "%*c+ items_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.key_value_pattern+"));
            _res = _gather_147_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s items_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.key_value_pattern+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// key_value_pattern: (literal_expr | attr) ':' pattern
static KeyPatternPair*
key_value_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    KeyPatternPair* _res = NULL;
    int _mark = p->mark;
    { // (literal_expr | attr) ':' pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> key_value_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(literal_expr | attr) ':' pattern"));
        Token * _literal;
        void *key;
        pattern_ty pattern;
        if (
            (key = _tmp_149_rule(p))  // literal_expr | attr
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (pattern = pattern_rule(p))  // pattern
        )
        {
            D(fprintf(stderr, "%*c+ key_value_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(literal_expr | attr) ':' pattern"));
            _res = _PyPegen_key_pattern_pair ( p , key , pattern );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s key_value_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(literal_expr | attr) ':' pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// double_star_pattern: '**' pattern_capture_target
static expr_ty
double_star_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // '**' pattern_capture_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> double_star_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' pattern_capture_target"));
        Token * _literal;
        expr_ty target;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (target = pattern_capture_target_rule(p))  // pattern_capture_target
        )
        {
            D(fprintf(stderr, "%*c+ double_star_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' pattern_capture_target"));
            _res = target;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s double_star_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' pattern_capture_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// class_pattern:
//     | name_or_attr '(' ')'
//     | name_or_attr '(' positional_patterns ','? ')'
//     | name_or_attr '(' keyword_patterns ','? ')'
//     | name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'
//     | invalid_class_pattern
static pattern_ty
class_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    pattern_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // name_or_attr '(' ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '(' ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty cls;
        if (
            (cls = name_or_attr_rule(p))  // name_or_attr
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ class_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '(' ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchClass ( cls , NULL , NULL , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "name_or_attr '(' ')'"));
    }
    { // name_or_attr '(' positional_patterns ','? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '(' positional_patterns ','? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty cls;
        asdl_pattern_seq* patterns;
        if (
            (cls = name_or_attr_rule(p))  // name_or_attr
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (patterns = positional_patterns_rule(p))  // positional_patterns
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ class_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '(' positional_patterns ','? ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchClass ( cls , patterns , NULL , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "name_or_attr '(' positional_patterns ','? ')'"));
    }
    { // name_or_attr '(' keyword_patterns ','? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '(' keyword_patterns ','? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty cls;
        asdl_seq* keywords;
        if (
            (cls = name_or_attr_rule(p))  // name_or_attr
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (keywords = keyword_patterns_rule(p))  // keyword_patterns
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ class_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '(' keyword_patterns ','? ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchClass ( cls , NULL , CHECK ( asdl_identifier_seq* , _PyPegen_map_names_to_ids ( p , CHECK ( asdl_expr_seq* , _PyPegen_get_pattern_keys ( p , keywords ) ) ) ) , CHECK ( asdl_pattern_seq* , _PyPegen_get_patterns ( p , keywords ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "name_or_attr '(' keyword_patterns ','? ')'"));
    }
    { // name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty cls;
        asdl_seq* keywords;
        asdl_pattern_seq* patterns;
        if (
            (cls = name_or_attr_rule(p))  // name_or_attr
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (patterns = positional_patterns_rule(p))  // positional_patterns
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (keywords = keyword_patterns_rule(p))  // keyword_patterns
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_2 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ class_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_MatchClass ( cls , patterns , CHECK ( asdl_identifier_seq* , _PyPegen_map_names_to_ids ( p , CHECK ( asdl_expr_seq* , _PyPegen_get_pattern_keys ( p , keywords ) ) ) ) , CHECK ( asdl_pattern_seq* , _PyPegen_get_patterns ( p , keywords ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "name_or_attr '(' positional_patterns ',' keyword_patterns ','? ')'"));
    }
    if (p->call_invalid_rules) { // invalid_class_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> class_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_class_pattern"));
        void *invalid_class_pattern_var;
        if (
            (invalid_class_pattern_var = invalid_class_pattern_rule(p))  // invalid_class_pattern
        )
        {
            D(fprintf(stderr, "%*c+ class_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_class_pattern"));
            _res = invalid_class_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s class_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_class_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// positional_patterns: ','.pattern+
static asdl_pattern_seq*
positional_patterns_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_pattern_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.pattern+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> positional_patterns[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.pattern+"));
        asdl_pattern_seq* args;
        if (
            (args = (asdl_pattern_seq*)_gather_150_rule(p))  // ','.pattern+
        )
        {
            D(fprintf(stderr, "%*c+ positional_patterns[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.pattern+"));
            _res = args;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s positional_patterns[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.pattern+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// keyword_patterns: ','.keyword_pattern+
static asdl_seq*
keyword_patterns_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.keyword_pattern+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> keyword_patterns[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.keyword_pattern+"));
        asdl_seq * _gather_152_var;
        if (
            (_gather_152_var = _gather_152_rule(p))  // ','.keyword_pattern+
        )
        {
            D(fprintf(stderr, "%*c+ keyword_patterns[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.keyword_pattern+"));
            _res = _gather_152_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s keyword_patterns[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.keyword_pattern+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// keyword_pattern: NAME '=' pattern
static KeyPatternPair*
keyword_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    KeyPatternPair* _res = NULL;
    int _mark = p->mark;
    { // NAME '=' pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> keyword_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' pattern"));
        Token * _literal;
        expr_ty arg;
        pattern_ty value;
        if (
            (arg = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (value = pattern_rule(p))  // pattern
        )
        {
            D(fprintf(stderr, "%*c+ keyword_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' pattern"));
            _res = _PyPegen_key_pattern_pair ( p , arg , value );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s keyword_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME '=' pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// unless_stmt:
//     | ':' (';'.simple_stmt+ ';'? | block) 'unless' named_expression
//     | braced_block 'unless' named_expression
static stmt_ty
unless_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // ':' (';'.simple_stmt+ ';'? | block) 'unless' named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> unless_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' (';'.simple_stmt+ ';'? | block) 'unless' named_expression"));
        Token * _keyword;
        Token * _literal;
        expr_ty a;
        void *b;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = _tmp_154_rule(p))  // ';'.simple_stmt+ ';'? | block
            &&
            (_keyword = _PyPegen_expect_token(p, 671))  // token='unless'
            &&
            (a = named_expression_rule(p))  // named_expression
        )
        {
            D(fprintf(stderr, "%*c+ unless_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' (';'.simple_stmt+ ';'? | block) 'unless' named_expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( _PyAST_UnaryOp ( Not , a , EXTRA ) , b , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s unless_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':' (';'.simple_stmt+ ';'? | block) 'unless' named_expression"));
    }
    { // braced_block 'unless' named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> unless_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block 'unless' named_expression"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        if (
            (b = braced_block_rule(p))  // braced_block
            &&
            (_keyword = _PyPegen_expect_token(p, 671))  // token='unless'
            &&
            (a = named_expression_rule(p))  // named_expression
        )
        {
            D(fprintf(stderr, "%*c+ unless_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block 'unless' named_expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( _PyAST_UnaryOp ( Not , a , EXTRA ) , b , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s unless_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block 'unless' named_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// unless_stmt_nonewline: block_entry_nonewline 'unless' named_expression
static stmt_ty
unless_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // block_entry_nonewline 'unless' named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> unless_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block_entry_nonewline 'unless' named_expression"));
        Token * _keyword;
        expr_ty a;
        asdl_stmt_seq* b;
        if (
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
            &&
            (_keyword = _PyPegen_expect_token(p, 671))  // token='unless'
            &&
            (a = named_expression_rule(p))  // named_expression
        )
        {
            D(fprintf(stderr, "%*c+ unless_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block_entry_nonewline 'unless' named_expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_If ( _PyAST_UnaryOp ( Not , a , EXTRA ) , b , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s unless_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "block_entry_nonewline 'unless' named_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// type_alias: "type" NAME type_params? '=' expression
static stmt_ty
type_alias_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    stmt_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "type" NAME type_params? '=' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_alias[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"type\" NAME type_params? '=' expression"));
        expr_ty _keyword;
        Token * _literal;
        expr_ty b;
        expr_ty n;
        void *t;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "type"))  // soft_keyword='"type"'
            &&
            (n = _PyPegen_name_token(p))  // NAME
            &&
            (t = type_params_rule(p), !p->error_indicator)  // type_params?
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_alias[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"type\" NAME type_params? '=' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( stmt_ty , 12 , "Type statement is" , _PyAST_TypeAlias ( CHECK ( expr_ty , _PyPegen_set_expr_context ( p , n , Store ) ) , t , b , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_alias[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"type\" NAME type_params? '=' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// type_params: '[' type_param_seq ']'
static asdl_type_param_seq*
type_params_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_type_param_seq* _res = NULL;
    int _mark = p->mark;
    { // '[' type_param_seq ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_params[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' type_param_seq ']'"));
        Token * _literal;
        Token * _literal_1;
        asdl_type_param_seq* t;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (t = type_param_seq_rule(p))  // type_param_seq
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ type_params[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' type_param_seq ']'"));
            _res = CHECK_VERSION ( asdl_type_param_seq* , 12 , "Type parameter lists are" , t );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_params[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'[' type_param_seq ']'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// type_param_seq: ','.type_param+ ','?
static asdl_type_param_seq*
type_param_seq_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_type_param_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.type_param+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_param_seq[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.type_param+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_type_param_seq* a;
        if (
            (a = (asdl_type_param_seq*)_gather_155_rule(p))  // ','.type_param+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ type_param_seq[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.type_param+ ','?"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_param_seq[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.type_param+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// type_param:
//     | NAME type_param_bound?
//     | '*' NAME ":" expression
//     | '*' NAME
//     | '**' NAME ":" expression
//     | '**' NAME
static type_param_ty
type_param_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    type_param_ty _res = NULL;
    if (_PyPegen_is_memoized(p, type_param_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME type_param_bound?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_param[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME type_param_bound?"));
        expr_ty a;
        void *b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = type_param_bound_rule(p), !p->error_indicator)  // type_param_bound?
        )
        {
            D(fprintf(stderr, "%*c+ type_param[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME type_param_bound?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_TypeVar ( a -> v . Name . id , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_param[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME type_param_bound?"));
    }
    { // '*' NAME ":" expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_param[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' NAME \":\" expression"));
        Token * _literal;
        expr_ty a;
        Token * colon;
        expr_ty e;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (colon = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (e = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_param[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' NAME \":\" expression"));
            _res = RAISE_SYNTAX_ERROR_STARTING_FROM ( colon , e -> kind == Tuple_kind ? "cannot use constraints with TypeVarTuple" : "cannot use bound with TypeVarTuple" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_param[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' NAME \":\" expression"));
    }
    { // '*' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_param[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' NAME"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ type_param[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' NAME"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_TypeVarTuple ( a -> v . Name . id , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_param[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' NAME"));
    }
    { // '**' NAME ":" expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_param[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' NAME \":\" expression"));
        Token * _literal;
        expr_ty a;
        Token * colon;
        expr_ty e;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (colon = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (e = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_param[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' NAME \":\" expression"));
            _res = RAISE_SYNTAX_ERROR_STARTING_FROM ( colon , e -> kind == Tuple_kind ? "cannot use constraints with ParamSpec" : "cannot use bound with ParamSpec" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_param[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' NAME \":\" expression"));
    }
    { // '**' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_param[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' NAME"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ type_param[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' NAME"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ParamSpec ( a -> v . Name . id , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_param[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' NAME"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, type_param_type, _res);
    p->level--;
    return _res;
}

// type_param_bound: ":" expression
static expr_ty
type_param_bound_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // ":" expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_param_bound[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\":\" expression"));
        Token * _literal;
        expr_ty e;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (e = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_param_bound[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\":\" expression"));
            _res = e;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_param_bound[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\":\" expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// expressions: expression ((',' expression))+ ','? | expression ',' | expression
static expr_ty
expressions_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // expression ((',' expression))+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ((',' expression))+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        asdl_seq * b;
        if (
            (a = expression_rule(p))  // expression
            &&
            (b = _loop1_157_rule(p))  // ((',' expression))+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ((',' expression))+ ','?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Tuple ( CHECK ( asdl_expr_seq* , _PyPegen_seq_insert_in_front ( p , a , b ) ) , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ((',' expression))+ ','?"));
    }
    { // expression ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ','"));
        Token * _literal;
        expr_ty a;
        if (
            (a = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ','"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Tuple ( CHECK ( asdl_expr_seq* , _PyPegen_singleton_seq ( p , a ) ) , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ','"));
    }
    { // expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression"));
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression"));
            _res = expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// expression:
//     | invalid_expression
//     | invalid_legacy_expression
//     | lambdef
//     | "block" braced_block
//     | disjunction 'if' disjunction 'else' expression
//     | disjunction
static expr_ty
expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, expression_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_expression"));
        void *invalid_expression_var;
        if (
            (invalid_expression_var = invalid_expression_rule(p))  // invalid_expression
        )
        {
            D(fprintf(stderr, "%*c+ expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_expression"));
            _res = invalid_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_expression"));
    }
    if (p->call_invalid_rules) { // invalid_legacy_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_legacy_expression"));
        void *invalid_legacy_expression_var;
        if (
            (invalid_legacy_expression_var = invalid_legacy_expression_rule(p))  // invalid_legacy_expression
        )
        {
            D(fprintf(stderr, "%*c+ expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_legacy_expression"));
            _res = invalid_legacy_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_legacy_expression"));
    }
    { // lambdef
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambdef"));
        expr_ty lambdef_var;
        if (
            (lambdef_var = lambdef_rule(p))  // lambdef
        )
        {
            D(fprintf(stderr, "%*c+ expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambdef"));
            _res = lambdef_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambdef"));
    }
    { // "block" braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"block\" braced_block"));
        expr_ty _keyword;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "block"))  // soft_keyword='"block"'
            &&
            (b = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"block\" braced_block"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BlockExpr ( b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"block\" braced_block"));
    }
    { // disjunction 'if' disjunction 'else' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "disjunction 'if' disjunction 'else' expression"));
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        expr_ty b;
        expr_ty c;
        if (
            (a = disjunction_rule(p))  // disjunction
            &&
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (b = disjunction_rule(p))  // disjunction
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 775))  // token='else'
            &&
            (c = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "disjunction 'if' disjunction 'else' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_IfExp ( b , a , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "disjunction 'if' disjunction 'else' expression"));
    }
    { // disjunction
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "disjunction"));
        expr_ty disjunction_var;
        if (
            (disjunction_var = disjunction_rule(p))  // disjunction
        )
        {
            D(fprintf(stderr, "%*c+ expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "disjunction"));
            _res = disjunction_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "disjunction"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, expression_type, _res);
    p->level--;
    return _res;
}

// yield_expr: 'yield' 'from' expression | 'yield' star_expressions?
static expr_ty
yield_expr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'yield' 'from' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> yield_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'yield' 'from' expression"));
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 676))  // token='yield'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 722))  // token='from'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ yield_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'yield' 'from' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_YieldFrom ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s yield_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'yield' 'from' expression"));
    }
    { // 'yield' star_expressions?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> yield_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'yield' star_expressions?"));
        Token * _keyword;
        void *a;
        if (
            (_keyword = _PyPegen_expect_token(p, 676))  // token='yield'
            &&
            (a = star_expressions_rule(p), !p->error_indicator)  // star_expressions?
        )
        {
            D(fprintf(stderr, "%*c+ yield_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'yield' star_expressions?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Yield ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s yield_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'yield' star_expressions?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// block_expr: "block" block_entry
static expr_ty
block_expr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "block" block_entry
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"block\" block_entry"));
        expr_ty _keyword;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "block"))  // soft_keyword='"block"'
            &&
            (b = block_entry_rule(p))  // block_entry
        )
        {
            D(fprintf(stderr, "%*c+ block_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"block\" block_entry"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BlockExpr ( b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"block\" block_entry"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// block_expr_nonewline: "block" block_entry_nonewline
static expr_ty
block_expr_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // "block" block_entry_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> block_expr_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"block\" block_entry_nonewline"));
        expr_ty _keyword;
        asdl_stmt_seq* b;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "block"))  // soft_keyword='"block"'
            &&
            (b = block_entry_nonewline_rule(p))  // block_entry_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ block_expr_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"block\" block_entry_nonewline"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BlockExpr ( b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s block_expr_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"block\" block_entry_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_expressions:
//     | star_expression ((',' star_expression))+ ','?
//     | star_expression ','
//     | star_expression
static expr_ty
star_expressions_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // star_expression ((',' star_expression))+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expression ((',' star_expression))+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        asdl_seq * b;
        if (
            (a = star_expression_rule(p))  // star_expression
            &&
            (b = _loop1_158_rule(p))  // ((',' star_expression))+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ star_expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expression ((',' star_expression))+ ','?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Tuple ( CHECK ( asdl_expr_seq* , _PyPegen_seq_insert_in_front ( p , a , b ) ) , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_expression ((',' star_expression))+ ','?"));
    }
    { // star_expression ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expression ','"));
        Token * _literal;
        expr_ty a;
        if (
            (a = star_expression_rule(p))  // star_expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ star_expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expression ','"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Tuple ( CHECK ( asdl_expr_seq* , _PyPegen_singleton_seq ( p , a ) ) , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_expression ','"));
    }
    { // star_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expression"));
        expr_ty star_expression_var;
        if (
            (star_expression_var = star_expression_rule(p))  // star_expression
        )
        {
            D(fprintf(stderr, "%*c+ star_expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expression"));
            _res = star_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_expression: '*' bitwise_or | expression
static expr_ty
star_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, star_expression_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '*' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ star_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' bitwise_or"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Starred ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' bitwise_or"));
    }
    { // expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression"));
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ star_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression"));
            _res = expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, star_expression_type, _res);
    p->level--;
    return _res;
}

// star_sum: '*' sum | sum
static expr_ty
star_sum_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, star_sum_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '*' sum
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_sum[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' sum"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = sum_rule(p))  // sum
        )
        {
            D(fprintf(stderr, "%*c+ star_sum[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' sum"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Starred ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_sum[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' sum"));
    }
    { // sum
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_sum[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum"));
        expr_ty sum_var;
        if (
            (sum_var = sum_rule(p))  // sum
        )
        {
            D(fprintf(stderr, "%*c+ star_sum[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum"));
            _res = sum_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_sum[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, star_sum_type, _res);
    p->level--;
    return _res;
}

// star_named_expressions: ','.star_named_expression+ ','?
static asdl_expr_seq*
star_named_expressions_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_expr_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.star_named_expression+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_named_expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.star_named_expression+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_expr_seq* a;
        if (
            (a = (asdl_expr_seq*)_gather_159_rule(p))  // ','.star_named_expression+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ star_named_expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.star_named_expression+ ','?"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_named_expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.star_named_expression+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_named_expression: '*' bitwise_or | simple_slice | named_expression
static expr_ty
star_named_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '*' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_named_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ star_named_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' bitwise_or"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Starred ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_named_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' bitwise_or"));
    }
    { // simple_slice
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_named_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
        expr_ty simple_slice_var;
        if (
            (simple_slice_var = simple_slice_rule(p))  // simple_slice
        )
        {
            D(fprintf(stderr, "%*c+ star_named_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
            _res = simple_slice_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_named_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_slice"));
    }
    { // named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_named_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "named_expression"));
        expr_ty named_expression_var;
        if (
            (named_expression_var = named_expression_rule(p))  // named_expression
        )
        {
            D(fprintf(stderr, "%*c+ star_named_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "named_expression"));
            _res = named_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_named_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "named_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_assignment_expression: '*' bitwise_or | simple_slice | assignment_expression
static expr_ty
star_assignment_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '*' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_assignment_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ star_assignment_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' bitwise_or"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Starred ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_assignment_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' bitwise_or"));
    }
    { // simple_slice
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_assignment_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
        expr_ty simple_slice_var;
        if (
            (simple_slice_var = simple_slice_rule(p))  // simple_slice
        )
        {
            D(fprintf(stderr, "%*c+ star_assignment_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
            _res = simple_slice_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_assignment_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_slice"));
    }
    { // assignment_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_assignment_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_expression"));
        expr_ty assignment_expression_var;
        if (
            (assignment_expression_var = assignment_expression_rule(p))  // assignment_expression
        )
        {
            D(fprintf(stderr, "%*c+ star_assignment_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_expression"));
            _res = assignment_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_assignment_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "assignment_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// assignment_expression: star_target ':=' ~ expression
static expr_ty
assignment_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // star_target ':=' ~ expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> assignment_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_target ':=' ~ expression"));
        int _cut_var = 0;
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = star_target_rule(p))  // star_target
            &&
            (_literal = _PyPegen_expect_token(p, 53))  // token=':='
            &&
            (_cut_var = 1)
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ assignment_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_target ':=' ~ expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( expr_ty , 8 , "Assignment expressions are" , _PyAST_NamedExpr ( a , b , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s assignment_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_target ':=' ~ expression"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// named_expression: assignment_expression | invalid_named_expression | expression !':='
static expr_ty
named_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // assignment_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> named_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_expression"));
        expr_ty assignment_expression_var;
        if (
            (assignment_expression_var = assignment_expression_rule(p))  // assignment_expression
        )
        {
            D(fprintf(stderr, "%*c+ named_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_expression"));
            _res = assignment_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s named_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "assignment_expression"));
    }
    if (p->call_invalid_rules) { // invalid_named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> named_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_named_expression"));
        void *invalid_named_expression_var;
        if (
            (invalid_named_expression_var = invalid_named_expression_rule(p))  // invalid_named_expression
        )
        {
            D(fprintf(stderr, "%*c+ named_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_named_expression"));
            _res = invalid_named_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s named_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_named_expression"));
    }
    { // expression !':='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> named_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression !':='"));
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 53)  // token=':='
        )
        {
            D(fprintf(stderr, "%*c+ named_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression !':='"));
            _res = expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s named_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression !':='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// disjunction: conjunction (('or' conjunction))+ | conjunction
static expr_ty
disjunction_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, disjunction_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // conjunction (('or' conjunction))+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> disjunction[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "conjunction (('or' conjunction))+"));
        expr_ty a;
        asdl_seq * b;
        if (
            (a = conjunction_rule(p))  // conjunction
            &&
            (b = _loop1_161_rule(p))  // (('or' conjunction))+
        )
        {
            D(fprintf(stderr, "%*c+ disjunction[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "conjunction (('or' conjunction))+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BoolOp ( Or , CHECK ( asdl_expr_seq* , _PyPegen_seq_insert_in_front ( p , a , b ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s disjunction[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "conjunction (('or' conjunction))+"));
    }
    { // conjunction
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> disjunction[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "conjunction"));
        expr_ty conjunction_var;
        if (
            (conjunction_var = conjunction_rule(p))  // conjunction
        )
        {
            D(fprintf(stderr, "%*c+ disjunction[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "conjunction"));
            _res = conjunction_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s disjunction[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "conjunction"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, disjunction_type, _res);
    p->level--;
    return _res;
}

// conjunction: inversion (('and' inversion))+ | inversion
static expr_ty
conjunction_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, conjunction_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // inversion (('and' inversion))+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> conjunction[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "inversion (('and' inversion))+"));
        expr_ty a;
        asdl_seq * b;
        if (
            (a = inversion_rule(p))  // inversion
            &&
            (b = _loop1_162_rule(p))  // (('and' inversion))+
        )
        {
            D(fprintf(stderr, "%*c+ conjunction[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "inversion (('and' inversion))+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BoolOp ( And , CHECK ( asdl_expr_seq* , _PyPegen_seq_insert_in_front ( p , a , b ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s conjunction[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "inversion (('and' inversion))+"));
    }
    { // inversion
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> conjunction[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "inversion"));
        expr_ty inversion_var;
        if (
            (inversion_var = inversion_rule(p))  // inversion
        )
        {
            D(fprintf(stderr, "%*c+ conjunction[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "inversion"));
            _res = inversion_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s conjunction[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "inversion"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, conjunction_type, _res);
    p->level--;
    return _res;
}

// inversion: 'not' inversion | comparison
static expr_ty
inversion_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, inversion_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'not' inversion
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> inversion[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'not' inversion"));
        Token * _keyword;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 689))  // token='not'
            &&
            (a = inversion_rule(p))  // inversion
        )
        {
            D(fprintf(stderr, "%*c+ inversion[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'not' inversion"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( Not , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s inversion[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'not' inversion"));
    }
    { // comparison
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> inversion[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "comparison"));
        expr_ty comparison_var;
        if (
            (comparison_var = comparison_rule(p))  // comparison
        )
        {
            D(fprintf(stderr, "%*c+ inversion[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "comparison"));
            _res = comparison_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s inversion[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "comparison"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, inversion_type, _res);
    p->level--;
    return _res;
}

// comparison: composition compare_op_composition_pair+ | composition
static expr_ty
comparison_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // composition compare_op_composition_pair+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> comparison[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "composition compare_op_composition_pair+"));
        expr_ty a;
        asdl_seq * b;
        if (
            (a = composition_rule(p))  // composition
            &&
            (b = _loop1_163_rule(p))  // compare_op_composition_pair+
        )
        {
            D(fprintf(stderr, "%*c+ comparison[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "composition compare_op_composition_pair+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Compare ( a , CHECK ( asdl_int_seq* , _PyPegen_get_cmpops ( p , b ) ) , CHECK ( asdl_expr_seq* , _PyPegen_get_exprs ( p , b ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s comparison[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "composition compare_op_composition_pair+"));
    }
    { // composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> comparison[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "composition"));
        expr_ty composition_var;
        if (
            (composition_var = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ comparison[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "composition"));
            _res = composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s comparison[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// compare_op_composition_pair:
//     | eq_composition
//     | noteq_composition
//     | lte_composition
//     | lt_composition
//     | gte_composition
//     | gt_composition
//     | notin_composition
//     | in_composition
//     | isnotin_composition
//     | isin_composition
//     | isnot_composition
//     | is_composition
static CmpopExprPair*
compare_op_composition_pair_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // eq_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "eq_composition"));
        CmpopExprPair* eq_composition_var;
        if (
            (eq_composition_var = eq_composition_rule(p))  // eq_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "eq_composition"));
            _res = eq_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "eq_composition"));
    }
    { // noteq_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "noteq_composition"));
        CmpopExprPair* noteq_composition_var;
        if (
            (noteq_composition_var = noteq_composition_rule(p))  // noteq_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "noteq_composition"));
            _res = noteq_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "noteq_composition"));
    }
    { // lte_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lte_composition"));
        CmpopExprPair* lte_composition_var;
        if (
            (lte_composition_var = lte_composition_rule(p))  // lte_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lte_composition"));
            _res = lte_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lte_composition"));
    }
    { // lt_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lt_composition"));
        CmpopExprPair* lt_composition_var;
        if (
            (lt_composition_var = lt_composition_rule(p))  // lt_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lt_composition"));
            _res = lt_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lt_composition"));
    }
    { // gte_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "gte_composition"));
        CmpopExprPair* gte_composition_var;
        if (
            (gte_composition_var = gte_composition_rule(p))  // gte_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "gte_composition"));
            _res = gte_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "gte_composition"));
    }
    { // gt_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "gt_composition"));
        CmpopExprPair* gt_composition_var;
        if (
            (gt_composition_var = gt_composition_rule(p))  // gt_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "gt_composition"));
            _res = gt_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "gt_composition"));
    }
    { // notin_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "notin_composition"));
        CmpopExprPair* notin_composition_var;
        if (
            (notin_composition_var = notin_composition_rule(p))  // notin_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "notin_composition"));
            _res = notin_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "notin_composition"));
    }
    { // in_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "in_composition"));
        CmpopExprPair* in_composition_var;
        if (
            (in_composition_var = in_composition_rule(p))  // in_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "in_composition"));
            _res = in_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "in_composition"));
    }
    { // isnotin_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "isnotin_composition"));
        CmpopExprPair* isnotin_composition_var;
        if (
            (isnotin_composition_var = isnotin_composition_rule(p))  // isnotin_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "isnotin_composition"));
            _res = isnotin_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "isnotin_composition"));
    }
    { // isin_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "isin_composition"));
        CmpopExprPair* isin_composition_var;
        if (
            (isin_composition_var = isin_composition_rule(p))  // isin_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "isin_composition"));
            _res = isin_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "isin_composition"));
    }
    { // isnot_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "isnot_composition"));
        CmpopExprPair* isnot_composition_var;
        if (
            (isnot_composition_var = isnot_composition_rule(p))  // isnot_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "isnot_composition"));
            _res = isnot_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "isnot_composition"));
    }
    { // is_composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compare_op_composition_pair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "is_composition"));
        CmpopExprPair* is_composition_var;
        if (
            (is_composition_var = is_composition_rule(p))  // is_composition
        )
        {
            D(fprintf(stderr, "%*c+ compare_op_composition_pair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "is_composition"));
            _res = is_composition_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compare_op_composition_pair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "is_composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// eq_composition: '==' composition
static CmpopExprPair*
eq_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // '==' composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> eq_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'==' composition"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 27))  // token='=='
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ eq_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'==' composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , Eq , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s eq_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'==' composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// noteq_composition: ('!=') composition
static CmpopExprPair*
noteq_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // ('!=') composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> noteq_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('!=') composition"));
        void *_tmp_164_var;
        expr_ty a;
        if (
            (_tmp_164_var = _tmp_164_rule(p))  // '!='
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ noteq_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('!=') composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , NotEq , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s noteq_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('!=') composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lte_composition: '<=' composition
static CmpopExprPair*
lte_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // '<=' composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lte_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'<=' composition"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 29))  // token='<='
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ lte_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'<=' composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , LtE , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lte_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'<=' composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lt_composition: '<' composition
static CmpopExprPair*
lt_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // '<' composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lt_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'<' composition"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 20))  // token='<'
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ lt_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'<' composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , Lt , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lt_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'<' composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// gte_composition: '>=' composition
static CmpopExprPair*
gte_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // '>=' composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> gte_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'>=' composition"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 30))  // token='>='
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ gte_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'>=' composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , GtE , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s gte_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'>=' composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// gt_composition: '>' composition
static CmpopExprPair*
gt_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // '>' composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> gt_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'>' composition"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 21))  // token='>'
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ gt_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'>' composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , Gt , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s gt_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'>' composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// notin_composition: 'not' 'in' composition
static CmpopExprPair*
notin_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // 'not' 'in' composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> notin_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'not' 'in' composition"));
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 689))  // token='not'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ notin_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'not' 'in' composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , NotIn , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s notin_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'not' 'in' composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// in_composition: 'in' composition
static CmpopExprPair*
in_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // 'in' composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> in_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'in' composition"));
        Token * _keyword;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ in_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'in' composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , In , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s in_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'in' composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// isnotin_composition: 'is' 'not' 'in' composition
static CmpopExprPair*
isnotin_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // 'is' 'not' 'in' composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> isnotin_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'is' 'not' 'in' composition"));
        Token * _keyword;
        Token * _keyword_1;
        Token * _keyword_2;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 690))  // token='is'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 689))  // token='not'
            &&
            (_keyword_2 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ isnotin_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'is' 'not' 'in' composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , IsNotIn , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s isnotin_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'is' 'not' 'in' composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// isin_composition: 'is' 'in' composition
static CmpopExprPair*
isin_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // 'is' 'in' composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> isin_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'is' 'in' composition"));
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 690))  // token='is'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ isin_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'is' 'in' composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , IsIn , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s isin_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'is' 'in' composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// isnot_composition: 'is' 'not' composition
static CmpopExprPair*
isnot_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // 'is' 'not' composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> isnot_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'is' 'not' composition"));
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 690))  // token='is'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 689))  // token='not'
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ isnot_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'is' 'not' composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , IsNot , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s isnot_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'is' 'not' composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// is_composition: 'is' composition
static CmpopExprPair*
is_composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    CmpopExprPair* _res = NULL;
    int _mark = p->mark;
    { // 'is' composition
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> is_composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'is' composition"));
        Token * _keyword;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 690))  // token='is'
            &&
            (a = composition_rule(p))  // composition
        )
        {
            D(fprintf(stderr, "%*c+ is_composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'is' composition"));
            _res = _PyPegen_cmpop_expr_pair ( p , Is , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s is_composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'is' composition"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// composition: composition ('|>') (bitwise_or?) | bitwise_or
static expr_ty composition_raw(Parser *);
static expr_ty
composition_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, composition_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_8 = _PyPegen_update_memo(p, _mark, composition_type, _res);
        if (tmpvar_8) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = composition_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
composition_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // composition ('|>') (bitwise_or?)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "composition ('|>') (bitwise_or?)"));
        expr_ty a;
        void *b;
        void *t;
        if (
            (a = composition_rule(p))  // composition
            &&
            (t = _tmp_165_rule(p))  // '|>'
            &&
            (b = _tmp_166_rule(p))  // bitwise_or?
        )
        {
            D(fprintf(stderr, "%*c+ composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "composition ('|>') (bitwise_or?)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Composition ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "composition ('|>') (bitwise_or?)"));
    }
    { // bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> composition[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_or"));
        expr_ty bitwise_or_var;
        if (
            (bitwise_or_var = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ composition[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_or"));
            _res = bitwise_or_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s composition[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwise_or"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// bitwise_or: bitwise_or '|' bitwise_xor | bitwise_xor
static expr_ty bitwise_or_raw(Parser *);
static expr_ty
bitwise_or_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, bitwise_or_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_9 = _PyPegen_update_memo(p, _mark, bitwise_or_type, _res);
        if (tmpvar_9) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = bitwise_or_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
bitwise_or_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwise_or '|' bitwise_xor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_or[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_or '|' bitwise_xor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = bitwise_or_rule(p))  // bitwise_or
            &&
            (_literal = _PyPegen_expect_token(p, 18))  // token='|'
            &&
            (b = bitwise_xor_rule(p))  // bitwise_xor
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_or[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_or '|' bitwise_xor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , BitOr , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_or[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwise_or '|' bitwise_xor"));
    }
    { // bitwise_xor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_or[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_xor"));
        expr_ty bitwise_xor_var;
        if (
            (bitwise_xor_var = bitwise_xor_rule(p))  // bitwise_xor
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_or[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_xor"));
            _res = bitwise_xor_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_or[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwise_xor"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// bitwise_xor: bitwise_xor '^' bitwise_and | bitwise_and
static expr_ty bitwise_xor_raw(Parser *);
static expr_ty
bitwise_xor_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, bitwise_xor_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_10 = _PyPegen_update_memo(p, _mark, bitwise_xor_type, _res);
        if (tmpvar_10) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = bitwise_xor_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
bitwise_xor_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwise_xor '^' bitwise_and
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_xor[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_xor '^' bitwise_and"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = bitwise_xor_rule(p))  // bitwise_xor
            &&
            (_literal = _PyPegen_expect_token(p, 32))  // token='^'
            &&
            (b = bitwise_and_rule(p))  // bitwise_and
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_xor[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_xor '^' bitwise_and"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , BitXor , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_xor[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwise_xor '^' bitwise_and"));
    }
    { // bitwise_and
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_xor[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_and"));
        expr_ty bitwise_and_var;
        if (
            (bitwise_and_var = bitwise_and_rule(p))  // bitwise_and
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_xor[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_and"));
            _res = bitwise_and_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_xor[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwise_and"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// bitwise_and: bitwise_and '&' shift_expr | shift_expr
static expr_ty bitwise_and_raw(Parser *);
static expr_ty
bitwise_and_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, bitwise_and_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_11 = _PyPegen_update_memo(p, _mark, bitwise_and_type, _res);
        if (tmpvar_11) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = bitwise_and_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
bitwise_and_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwise_and '&' shift_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_and[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_and '&' shift_expr"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = bitwise_and_rule(p))  // bitwise_and
            &&
            (_literal = _PyPegen_expect_token(p, 19))  // token='&'
            &&
            (b = shift_expr_rule(p))  // shift_expr
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_and[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_and '&' shift_expr"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , BitAnd , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_and[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwise_and '&' shift_expr"));
    }
    { // shift_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> bitwise_and[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_expr"));
        expr_ty shift_expr_var;
        if (
            (shift_expr_var = shift_expr_rule(p))  // shift_expr
        )
        {
            D(fprintf(stderr, "%*c+ bitwise_and[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_expr"));
            _res = shift_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s bitwise_and[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "shift_expr"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// shift_expr: shift_expr '<<' sum | shift_expr '>>' sum | sum
static expr_ty shift_expr_raw(Parser *);
static expr_ty
shift_expr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, shift_expr_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_12 = _PyPegen_update_memo(p, _mark, shift_expr_type, _res);
        if (tmpvar_12) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = shift_expr_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
shift_expr_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // shift_expr '<<' sum
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> shift_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_expr '<<' sum"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = shift_expr_rule(p))  // shift_expr
            &&
            (_literal = _PyPegen_expect_token(p, 33))  // token='<<'
            &&
            (b = sum_rule(p))  // sum
        )
        {
            D(fprintf(stderr, "%*c+ shift_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_expr '<<' sum"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , LShift , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s shift_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "shift_expr '<<' sum"));
    }
    { // shift_expr '>>' sum
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> shift_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_expr '>>' sum"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = shift_expr_rule(p))  // shift_expr
            &&
            (_literal = _PyPegen_expect_token(p, 34))  // token='>>'
            &&
            (b = sum_rule(p))  // sum
        )
        {
            D(fprintf(stderr, "%*c+ shift_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "shift_expr '>>' sum"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , RShift , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s shift_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "shift_expr '>>' sum"));
    }
    { // sum
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> shift_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum"));
        expr_ty sum_var;
        if (
            (sum_var = sum_rule(p))  // sum
        )
        {
            D(fprintf(stderr, "%*c+ shift_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum"));
            _res = sum_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s shift_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// sum: sum '+' term | sum '-' term | term
static expr_ty sum_raw(Parser *);
static expr_ty
sum_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, sum_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_13 = _PyPegen_update_memo(p, _mark, sum_type, _res);
        if (tmpvar_13) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = sum_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
sum_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // sum '+' term
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum '+' term"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = sum_rule(p))  // sum
            &&
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
            &&
            (b = term_rule(p))  // term
        )
        {
            D(fprintf(stderr, "%*c+ sum[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum '+' term"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Add , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum '+' term"));
    }
    { // sum '-' term
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum '-' term"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = sum_rule(p))  // sum
            &&
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (b = term_rule(p))  // term
        )
        {
            D(fprintf(stderr, "%*c+ sum[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum '-' term"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Sub , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum '-' term"));
    }
    { // term
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term"));
        expr_ty term_var;
        if (
            (term_var = term_rule(p))  // term
        )
        {
            D(fprintf(stderr, "%*c+ sum[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term"));
            _res = term_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// term:
//     | term '*' factor
//     | term '/' factor
//     | term '//' factor
//     | term '%' factor
//     | term '@' factor
//     | factor
static expr_ty term_raw(Parser *);
static expr_ty
term_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, term_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_14 = _PyPegen_update_memo(p, _mark, term_type, _res);
        if (tmpvar_14) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = term_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
term_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // term '*' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term '*' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term '*' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Mult , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term '*' factor"));
    }
    { // term '/' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term '/' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term '/' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Div , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term '/' factor"));
    }
    { // term '//' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term '//' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 47))  // token='//'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term '//' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , FloorDiv , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term '//' factor"));
    }
    { // term '%' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term '%' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 24))  // token='%'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term '%' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Mod , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term '%' factor"));
    }
    { // term '@' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term '@' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = term_rule(p))  // term
            &&
            (_literal = _PyPegen_expect_token(p, 49))  // token='@'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "term '@' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( expr_ty , 5 , "The '@' operator is" , _PyAST_BinOp ( a , MatMult , b , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "term '@' factor"));
    }
    { // factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> term[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "factor"));
        expr_ty factor_var;
        if (
            (factor_var = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ term[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "factor"));
            _res = factor_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s term[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "factor"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// factor: '+' factor | '-' factor | '~' factor | '!' factor | coalesce | power
static expr_ty
factor_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, factor_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '+' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+' factor"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
            &&
            (a = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ factor[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( UAdd , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'+' factor"));
    }
    { // '-' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-' factor"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (a = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ factor[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( USub , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'-' factor"));
    }
    { // '~' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'~' factor"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 31))  // token='~'
            &&
            (a = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ factor[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'~' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( Invert , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'~' factor"));
    }
    { // '!' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' factor"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 54))  // token='!'
            &&
            (a = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ factor[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_UnaryOp ( Not , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!' factor"));
    }
    { // coalesce
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "coalesce"));
        expr_ty coalesce_var;
        if (
            (coalesce_var = coalesce_rule(p))  // coalesce
        )
        {
            D(fprintf(stderr, "%*c+ factor[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "coalesce"));
            _res = coalesce_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "coalesce"));
    }
    { // power
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> factor[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "power"));
        expr_ty power_var;
        if (
            (power_var = power_rule(p))  // power
        )
        {
            D(fprintf(stderr, "%*c+ factor[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "power"));
            _res = power_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s factor[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "power"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, factor_type, _res);
    p->level--;
    return _res;
}

// coalesce: await_primary '??' factor
static expr_ty
coalesce_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // await_primary '??' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> coalesce[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "await_primary '??' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = await_primary_rule(p))  // await_primary
            &&
            (_literal = _PyPegen_expect_token(p, 59))  // token='??'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ coalesce[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "await_primary '??' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Clsc , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s coalesce[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "await_primary '??' factor"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// power: await_primary '**' factor | await_primary
static expr_ty
power_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // await_primary '**' factor
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> power[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "await_primary '**' factor"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = await_primary_rule(p))  // await_primary
            &&
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (b = factor_rule(p))  // factor
        )
        {
            D(fprintf(stderr, "%*c+ power[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "await_primary '**' factor"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_BinOp ( a , Pow , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s power[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "await_primary '**' factor"));
    }
    { // await_primary
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> power[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "await_primary"));
        expr_ty await_primary_var;
        if (
            (await_primary_var = await_primary_rule(p))  // await_primary
        )
        {
            D(fprintf(stderr, "%*c+ power[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "await_primary"));
            _res = await_primary_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s power[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "await_primary"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// await_primary: 'await' primary | primary
static expr_ty
await_primary_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, await_primary_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'await' primary
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> await_primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'await' primary"));
        Token * _keyword;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 691))  // token='await'
            &&
            (a = primary_rule(p))  // primary
        )
        {
            D(fprintf(stderr, "%*c+ await_primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'await' primary"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = CHECK_VERSION ( expr_ty , 5 , "Await expressions are" , _PyAST_Await ( a , EXTRA ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s await_primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'await' primary"));
    }
    { // primary
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> await_primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "primary"));
        expr_ty primary_var;
        if (
            (primary_var = primary_rule(p))  // primary
        )
        {
            D(fprintf(stderr, "%*c+ await_primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "primary"));
            _res = primary_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s await_primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "primary"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, await_primary_type, _res);
    p->level--;
    return _res;
}

// Left-recursive
// primary:
//     | primary '?'? '.' NAME
//     | primary '?'? (compound_expr | tuplecomp | genexp)
//     | primary '?'? '(' arguments? ')'
//     | primary '?'? '[' slices ']'
//     | atom
static expr_ty primary_raw(Parser *);
static expr_ty
primary_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, primary_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_15 = _PyPegen_update_memo(p, _mark, primary_type, _res);
        if (tmpvar_15) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = primary_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
primary_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // primary '?'? '.' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "primary '?'? '.' NAME"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        void *n;
        if (
            (a = primary_rule(p))  // primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "primary '?'? '.' NAME"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Attribute ( a , b -> v . Name . id , Load , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "primary '?'? '.' NAME"));
    }
    { // primary '?'? (compound_expr | tuplecomp | genexp)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "primary '?'? (compound_expr | tuplecomp | genexp)"));
        expr_ty a;
        void *b;
        void *n;
        if (
            (a = primary_rule(p))  // primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (b = _tmp_167_rule(p))  // compound_expr | tuplecomp | genexp
        )
        {
            D(fprintf(stderr, "%*c+ primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "primary '?'? (compound_expr | tuplecomp | genexp)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Call ( a , CHECK ( asdl_expr_seq* , ( asdl_expr_seq* ) _PyPegen_singleton_seq ( p , b ) ) , NULL , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "primary '?'? (compound_expr | tuplecomp | genexp)"));
    }
    { // primary '?'? '(' arguments? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "primary '?'? '(' arguments? ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        void *b;
        void *n;
        if (
            (a = primary_rule(p))  // primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (b = arguments_rule(p), !p->error_indicator)  // arguments?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "primary '?'? '(' arguments? ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Call ( a , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "primary '?'? '(' arguments? ')'"));
    }
    { // primary '?'? '[' slices ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "primary '?'? '[' slices ']'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        expr_ty b;
        void *n;
        if (
            (a = primary_rule(p))  // primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (b = slices_rule(p))  // slices
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "primary '?'? '[' slices ']'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Subscript ( a , b , Load , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "primary '?'? '[' slices ']'"));
    }
    { // atom
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "atom"));
        expr_ty atom_var;
        if (
            (atom_var = atom_rule(p))  // atom
        )
        {
            D(fprintf(stderr, "%*c+ primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "atom"));
            _res = atom_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "atom"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// slices: slice !',' | ','.(slice | starred_expression)+ ','?
static expr_ty
slices_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // slice !','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slices[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slice !','"));
        expr_ty a;
        if (
            (a = slice_rule(p))  // slice
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ slices[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slice !','"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slices[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "slice !','"));
    }
    { // ','.(slice | starred_expression)+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slices[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.(slice | starred_expression)+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_expr_seq* a;
        if (
            (a = (asdl_expr_seq*)_gather_168_rule(p))  // ','.(slice | starred_expression)+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ slices[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.(slice | starred_expression)+ ','?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Tuple ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slices[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.(slice | starred_expression)+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// slice: simple_slice | named_expression
static expr_ty
slice_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // simple_slice
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slice[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
        expr_ty simple_slice_var;
        if (
            (simple_slice_var = simple_slice_rule(p))  // simple_slice
        )
        {
            D(fprintf(stderr, "%*c+ slice[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
            _res = simple_slice_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slice[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_slice"));
    }
    { // named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> slice[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "named_expression"));
        expr_ty named_expression_var;
        if (
            (named_expression_var = named_expression_rule(p))  // named_expression
        )
        {
            D(fprintf(stderr, "%*c+ slice[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "named_expression"));
            _res = named_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s slice[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "named_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// simple_slice: expression? ':' expression? [':' expression?]
static expr_ty
simple_slice_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // expression? ':' expression? [':' expression?]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> simple_slice[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression? ':' expression? [':' expression?]"));
        Token * _literal;
        void *a;
        void *b;
        void *c;
        if (
            (a = expression_rule(p), !p->error_indicator)  // expression?
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p), !p->error_indicator)  // expression?
            &&
            (c = _tmp_170_rule(p), !p->error_indicator)  // [':' expression?]
        )
        {
            D(fprintf(stderr, "%*c+ simple_slice[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression? ':' expression? [':' expression?]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Slice ( a , b , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s simple_slice[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression? ':' expression? [':' expression?]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// atom:
//     | NAME
//     | 'True'
//     | 'False'
//     | 'None'
//     | '$'
//     | &(STRING | FSTRING_START) strings
//     | NUMBER
//     | &'(' (compound_expr | tuple | group | tuplecomp | genexp)
//     | &'[' (list | listcomp)
//     | &'{' (dict | set | dictcomp | setcomp)
//     | '...'
static expr_ty
atom_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
        expr_ty name_var;
        if (
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
            _res = name_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME"));
    }
    { // 'True'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 714))  // token='True'
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_True , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'True'"));
    }
    { // 'False'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 716))  // token='False'
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_False , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'False'"));
    }
    { // 'None'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 715))  // token='None'
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_None , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'None'"));
    }
    { // '$'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'$'"));
        Token * a;
        if (
            (a = _PyPegen_expect_token(p, 56))  // token='$'
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'$'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = p -> subn > 0 ? _PyAST_Template ( 0 , EXTRA ) : RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "template not in righthand side of pipe operation" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'$'"));
    }
    { // &(STRING | FSTRING_START) strings
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&(STRING | FSTRING_START) strings"));
        expr_ty strings_var;
        if (
            _PyPegen_lookahead(1, _tmp_171_rule, p)
            &&
            (strings_var = strings_rule(p))  // strings
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&(STRING | FSTRING_START) strings"));
            _res = strings_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&(STRING | FSTRING_START) strings"));
    }
    { // NUMBER
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NUMBER"));
        expr_ty number_var;
        if (
            (number_var = _PyPegen_number_token(p))  // NUMBER
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NUMBER"));
            _res = number_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NUMBER"));
    }
    { // &'(' (compound_expr | tuple | group | tuplecomp | genexp)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'(' (compound_expr | tuple | group | tuplecomp | genexp)"));
        void *_tmp_172_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 7)  // token='('
            &&
            (_tmp_172_var = _tmp_172_rule(p))  // compound_expr | tuple | group | tuplecomp | genexp
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'(' (compound_expr | tuple | group | tuplecomp | genexp)"));
            _res = _tmp_172_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'(' (compound_expr | tuple | group | tuplecomp | genexp)"));
    }
    { // &'[' (list | listcomp)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'[' (list | listcomp)"));
        void *_tmp_173_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 9)  // token='['
            &&
            (_tmp_173_var = _tmp_173_rule(p))  // list | listcomp
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'[' (list | listcomp)"));
            _res = _tmp_173_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'[' (list | listcomp)"));
    }
    { // &'{' (dict | set | dictcomp | setcomp)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'{' (dict | set | dictcomp | setcomp)"));
        void *_tmp_174_var;
        if (
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 25)  // token='{'
            &&
            (_tmp_174_var = _tmp_174_rule(p))  // dict | set | dictcomp | setcomp
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&'{' (dict | set | dictcomp | setcomp)"));
            _res = _tmp_174_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&'{' (dict | set | dictcomp | setcomp)"));
    }
    { // '...'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'...'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 52))  // token='...'
        )
        {
            D(fprintf(stderr, "%*c+ atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'...'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_Ellipsis , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'...'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// group: '(' (yield_expr | slice) ')' | invalid_group
static expr_ty
group_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // '(' (yield_expr | slice) ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> group[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' (yield_expr | slice) ')'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = _tmp_175_rule(p))  // yield_expr | slice
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ group[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' (yield_expr | slice) ')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s group[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' (yield_expr | slice) ')'"));
    }
    if (p->call_invalid_rules) { // invalid_group
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> group[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_group"));
        void *invalid_group_var;
        if (
            (invalid_group_var = invalid_group_rule(p))  // invalid_group
        )
        {
            D(fprintf(stderr, "%*c+ group[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_group"));
            _res = invalid_group_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s group[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_group"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// compound_expr:
//     | '(' (&("def" | '@' | 'async') function_def_nonewline | &('class' | '@') class_def_nonewline | &"block" block_expr_nonewline) ')'
static expr_ty
compound_expr_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '(' (&("def" | '@' | 'async') function_def_nonewline | &('class' | '@') class_def_nonewline | &"block" block_expr_nonewline) ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> compound_expr[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' (&(\"def\" | '@' | 'async') function_def_nonewline | &('class' | '@') class_def_nonewline | &\"block\" block_expr_nonewline) ')'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = _tmp_176_rule(p))  // &("def" | '@' | 'async') function_def_nonewline | &('class' | '@') class_def_nonewline | &"block" block_expr_nonewline
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ compound_expr[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' (&(\"def\" | '@' | 'async') function_def_nonewline | &('class' | '@') class_def_nonewline | &\"block\" block_expr_nonewline) ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_CompoundExpr ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s compound_expr[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' (&(\"def\" | '@' | 'async') function_def_nonewline | &('class' | '@') class_def_nonewline | &\"block\" block_expr_nonewline) ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambdef:
//     | 'lambda' lambda_params? ':' expression
//     | '|' lambda_sum_params? '|' expression
//     | '(' params? ')' '=>' expression
static expr_ty
lambdef_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'lambda' lambda_params? ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambdef[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'lambda' lambda_params? ':' expression"));
        Token * _keyword;
        Token * _literal;
        void *a;
        expr_ty b;
        if (
            (_keyword = _PyPegen_expect_token(p, 713))  // token='lambda'
            &&
            (a = lambda_params_rule(p), !p->error_indicator)  // lambda_params?
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ lambdef[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'lambda' lambda_params? ':' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Lambda ( ( a ) ? a : CHECK ( arguments_ty , _PyPegen_empty_arguments ( p ) ) , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambdef[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'lambda' lambda_params? ':' expression"));
    }
    { // '|' lambda_sum_params? '|' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambdef[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|' lambda_sum_params? '|' expression"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        expr_ty b;
        if (
            (_literal = _PyPegen_expect_token(p, 18))  // token='|'
            &&
            (a = lambda_sum_params_rule(p), !p->error_indicator)  // lambda_sum_params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 18))  // token='|'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ lambdef[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|' lambda_sum_params? '|' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Lambda ( ( a ) ? a : CHECK ( arguments_ty , _PyPegen_empty_arguments ( p ) ) , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambdef[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|' lambda_sum_params? '|' expression"));
    }
    { // '(' params? ')' '=>' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambdef[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' params? ')' '=>' expression"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *a;
        expr_ty b;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (_literal_2 = _PyPegen_expect_token(p, 61))  // token='=>'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ lambdef[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' params? ')' '=>' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Lambda ( ( a ) ? a : CHECK ( arguments_ty , _PyPegen_empty_arguments ( p ) ) , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambdef[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' params? ')' '=>' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_params: invalid_lambda_parameters | lambda_parameters
static arguments_ty
lambda_params_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arguments_ty _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_lambda_parameters
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_params[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_lambda_parameters"));
        void *invalid_lambda_parameters_var;
        if (
            (invalid_lambda_parameters_var = invalid_lambda_parameters_rule(p))  // invalid_lambda_parameters
        )
        {
            D(fprintf(stderr, "%*c+ lambda_params[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_lambda_parameters"));
            _res = invalid_lambda_parameters_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_params[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_lambda_parameters"));
    }
    { // lambda_parameters
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_params[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_parameters"));
        arguments_ty lambda_parameters_var;
        if (
            (lambda_parameters_var = lambda_parameters_rule(p))  // lambda_parameters
        )
        {
            D(fprintf(stderr, "%*c+ lambda_params[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_parameters"));
            _res = lambda_parameters_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_params[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_parameters"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_sum_params: invalid_lambda_sum_parameters | lambda_sum_parameters
static arguments_ty
lambda_sum_params_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arguments_ty _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_lambda_sum_parameters
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_params[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_lambda_sum_parameters"));
        void *invalid_lambda_sum_parameters_var;
        if (
            (invalid_lambda_sum_parameters_var = invalid_lambda_sum_parameters_rule(p))  // invalid_lambda_sum_parameters
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_params[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_lambda_sum_parameters"));
            _res = invalid_lambda_sum_parameters_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_params[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_lambda_sum_parameters"));
    }
    { // lambda_sum_parameters
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_params[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_parameters"));
        arguments_ty lambda_sum_parameters_var;
        if (
            (lambda_sum_parameters_var = lambda_sum_parameters_rule(p))  // lambda_sum_parameters
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_params[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_parameters"));
            _res = lambda_sum_parameters_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_params[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_parameters"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_parameters:
//     | lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?
//     | lambda_slash_with_default lambda_param_with_default* lambda_star_etc?
//     | lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?
//     | lambda_param_with_default+ lambda_star_etc?
//     | lambda_star_etc
static arguments_ty
lambda_parameters_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arguments_ty _res = NULL;
    int _mark = p->mark;
    { // lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?"));
        asdl_arg_seq* a;
        asdl_arg_seq* b;
        asdl_seq * c;
        void *d;
        if (
            (a = lambda_slash_no_default_rule(p))  // lambda_slash_no_default
            &&
            (b = (asdl_arg_seq*)_loop0_177_rule(p))  // lambda_param_no_default*
            &&
            (c = _loop0_178_rule(p))  // lambda_param_with_default*
            &&
            (d = lambda_star_etc_rule(p), !p->error_indicator)  // lambda_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?"));
            _res = CHECK_VERSION ( arguments_ty , 8 , "Positional-only parameters are" , _PyPegen_make_arguments ( p , a , NULL , b , c , d ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_slash_no_default lambda_param_no_default* lambda_param_with_default* lambda_star_etc?"));
    }
    { // lambda_slash_with_default lambda_param_with_default* lambda_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_with_default lambda_param_with_default* lambda_star_etc?"));
        SlashWithDefault* a;
        asdl_seq * b;
        void *c;
        if (
            (a = lambda_slash_with_default_rule(p))  // lambda_slash_with_default
            &&
            (b = _loop0_179_rule(p))  // lambda_param_with_default*
            &&
            (c = lambda_star_etc_rule(p), !p->error_indicator)  // lambda_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_with_default lambda_param_with_default* lambda_star_etc?"));
            _res = CHECK_VERSION ( arguments_ty , 8 , "Positional-only parameters are" , _PyPegen_make_arguments ( p , NULL , a , NULL , b , c ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_slash_with_default lambda_param_with_default* lambda_star_etc?"));
    }
    { // lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?"));
        asdl_arg_seq* a;
        asdl_seq * b;
        void *c;
        if (
            (a = (asdl_arg_seq*)_loop1_180_rule(p))  // lambda_param_no_default+
            &&
            (b = _loop0_181_rule(p))  // lambda_param_with_default*
            &&
            (c = lambda_star_etc_rule(p), !p->error_indicator)  // lambda_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default+ lambda_param_with_default* lambda_star_etc?"));
    }
    { // lambda_param_with_default+ lambda_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_with_default+ lambda_star_etc?"));
        asdl_seq * a;
        void *b;
        if (
            (a = _loop1_182_rule(p))  // lambda_param_with_default+
            &&
            (b = lambda_star_etc_rule(p), !p->error_indicator)  // lambda_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_with_default+ lambda_star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_with_default+ lambda_star_etc?"));
    }
    { // lambda_star_etc
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_star_etc"));
        StarEtc* a;
        if (
            (a = lambda_star_etc_rule(p))  // lambda_star_etc
        )
        {
            D(fprintf(stderr, "%*c+ lambda_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_star_etc"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_star_etc"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_slash_no_default:
//     | lambda_param_no_default+ '/' ','
//     | lambda_param_no_default+ '/' &':'
static asdl_arg_seq*
lambda_slash_no_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_arg_seq* _res = NULL;
    int _mark = p->mark;
    { // lambda_param_no_default+ '/' ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_slash_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default+ '/' ','"));
        Token * _literal;
        Token * _literal_1;
        asdl_arg_seq* a;
        if (
            (a = (asdl_arg_seq*)_loop1_183_rule(p))  // lambda_param_no_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_slash_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default+ '/' ','"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_slash_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default+ '/' ','"));
    }
    { // lambda_param_no_default+ '/' &':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_slash_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default+ '/' &':'"));
        Token * _literal;
        asdl_arg_seq* a;
        if (
            (a = (asdl_arg_seq*)_loop1_184_rule(p))  // lambda_param_no_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_slash_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default+ '/' &':'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_slash_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default+ '/' &':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_slash_with_default:
//     | lambda_param_no_default* lambda_param_with_default+ '/' ','
//     | lambda_param_no_default* lambda_param_with_default+ '/' &':'
static SlashWithDefault*
lambda_slash_with_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    SlashWithDefault* _res = NULL;
    int _mark = p->mark;
    { // lambda_param_no_default* lambda_param_with_default+ '/' ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_slash_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default* lambda_param_with_default+ '/' ','"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _loop0_185_rule(p))  // lambda_param_no_default*
            &&
            (b = _loop1_186_rule(p))  // lambda_param_with_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_slash_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default* lambda_param_with_default+ '/' ','"));
            _res = _PyPegen_slash_with_default ( p , ( asdl_arg_seq* ) a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_slash_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default* lambda_param_with_default+ '/' ','"));
    }
    { // lambda_param_no_default* lambda_param_with_default+ '/' &':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_slash_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default* lambda_param_with_default+ '/' &':'"));
        Token * _literal;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _loop0_187_rule(p))  // lambda_param_no_default*
            &&
            (b = _loop1_188_rule(p))  // lambda_param_with_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_slash_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default* lambda_param_with_default+ '/' &':'"));
            _res = _PyPegen_slash_with_default ( p , ( asdl_arg_seq* ) a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_slash_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default* lambda_param_with_default+ '/' &':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_star_etc:
//     | invalid_lambda_star_etc
//     | '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?
//     | '*' ',' lambda_param_maybe_default+ lambda_kwds?
//     | lambda_kwds
static StarEtc*
lambda_star_etc_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    StarEtc* _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_lambda_star_etc
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_lambda_star_etc"));
        void *invalid_lambda_star_etc_var;
        if (
            (invalid_lambda_star_etc_var = invalid_lambda_star_etc_rule(p))  // invalid_lambda_star_etc
        )
        {
            D(fprintf(stderr, "%*c+ lambda_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_lambda_star_etc"));
            _res = invalid_lambda_star_etc_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_lambda_star_etc"));
    }
    { // '*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?"));
        Token * _literal;
        arg_ty a;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = lambda_param_no_default_rule(p))  // lambda_param_no_default
            &&
            (b = _loop0_189_rule(p))  // lambda_param_maybe_default*
            &&
            (c = lambda_kwds_rule(p), !p->error_indicator)  // lambda_kwds?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?"));
            _res = _PyPegen_star_etc ( p , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' lambda_param_no_default lambda_param_maybe_default* lambda_kwds?"));
    }
    { // '*' ',' lambda_param_maybe_default+ lambda_kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' ',' lambda_param_maybe_default+ lambda_kwds?"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (b = _loop1_190_rule(p))  // lambda_param_maybe_default+
            &&
            (c = lambda_kwds_rule(p), !p->error_indicator)  // lambda_kwds?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' ',' lambda_param_maybe_default+ lambda_kwds?"));
            _res = _PyPegen_star_etc ( p , NULL , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' ',' lambda_param_maybe_default+ lambda_kwds?"));
    }
    { // lambda_kwds
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_kwds"));
        arg_ty a;
        if (
            (a = lambda_kwds_rule(p))  // lambda_kwds
        )
        {
            D(fprintf(stderr, "%*c+ lambda_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_kwds"));
            _res = _PyPegen_star_etc ( p , NULL , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_kwds"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_kwds: invalid_lambda_kwds | '**' lambda_param_no_default
static arg_ty
lambda_kwds_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_lambda_kwds
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_lambda_kwds"));
        void *invalid_lambda_kwds_var;
        if (
            (invalid_lambda_kwds_var = invalid_lambda_kwds_rule(p))  // invalid_lambda_kwds
        )
        {
            D(fprintf(stderr, "%*c+ lambda_kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_lambda_kwds"));
            _res = invalid_lambda_kwds_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_lambda_kwds"));
    }
    { // '**' lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' lambda_param_no_default"));
        Token * _literal;
        arg_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ lambda_kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' lambda_param_no_default"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' lambda_param_no_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_param_no_default: lambda_param ',' | lambda_param &':'
static arg_ty
lambda_param_no_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    { // lambda_param ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param ','"));
        Token * _literal;
        arg_ty a;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param ','"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param ','"));
    }
    { // lambda_param &':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param &':'"));
        arg_ty a;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param &':'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param &':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_param_with_default: lambda_param default ',' | lambda_param default &':'
static NameDefaultPair*
lambda_param_with_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    NameDefaultPair* _res = NULL;
    int _mark = p->mark;
    { // lambda_param default ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param default ','"));
        Token * _literal;
        arg_ty a;
        expr_ty c;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            (c = default_rule(p))  // default
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param default ','"));
            _res = _PyPegen_name_default_pair ( p , a , c , NULL );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param default ','"));
    }
    { // lambda_param default &':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param default &':'"));
        arg_ty a;
        expr_ty c;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            (c = default_rule(p))  // default
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param default &':'"));
            _res = _PyPegen_name_default_pair ( p , a , c , NULL );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param default &':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_param_maybe_default: lambda_param default? ',' | lambda_param default? &':'
static NameDefaultPair*
lambda_param_maybe_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    NameDefaultPair* _res = NULL;
    int _mark = p->mark;
    { // lambda_param default? ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_maybe_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param default? ','"));
        Token * _literal;
        arg_ty a;
        void *c;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            (c = default_rule(p), !p->error_indicator)  // default?
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_maybe_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param default? ','"));
            _res = _PyPegen_name_default_pair ( p , a , c , NULL );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_maybe_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param default? ','"));
    }
    { // lambda_param default? &':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param_maybe_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param default? &':'"));
        arg_ty a;
        void *c;
        if (
            (a = lambda_param_rule(p))  // lambda_param
            &&
            (c = default_rule(p), !p->error_indicator)  // default?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 11)  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param_maybe_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param default? &':'"));
            _res = _PyPegen_name_default_pair ( p , a , c , NULL );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param_maybe_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param default? &':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_param: NAME
static arg_ty
lambda_param_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_param[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ lambda_param[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_arg ( a -> v . Name . id , NULL , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_param[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_sum_parameters:
//     | lambda_sum_slash_no_default lambda_sum_param_no_default* lambda_sum_param_with_default* lambda_sum_star_etc?
//     | lambda_sum_slash_with_default lambda_sum_param_with_default* lambda_sum_star_etc?
//     | lambda_sum_param_no_default+ lambda_sum_param_with_default* lambda_sum_star_etc?
//     | lambda_sum_param_with_default+ lambda_sum_star_etc?
//     | lambda_sum_star_etc
static arguments_ty
lambda_sum_parameters_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arguments_ty _res = NULL;
    int _mark = p->mark;
    { // lambda_sum_slash_no_default lambda_sum_param_no_default* lambda_sum_param_with_default* lambda_sum_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default lambda_sum_param_no_default* lambda_sum_param_with_default* lambda_sum_star_etc?"));
        asdl_arg_seq* a;
        asdl_arg_seq* b;
        asdl_seq * c;
        void *d;
        if (
            (a = lambda_sum_slash_no_default_rule(p))  // lambda_sum_slash_no_default
            &&
            (b = (asdl_arg_seq*)_loop0_191_rule(p))  // lambda_sum_param_no_default*
            &&
            (c = _loop0_192_rule(p))  // lambda_sum_param_with_default*
            &&
            (d = lambda_sum_star_etc_rule(p), !p->error_indicator)  // lambda_sum_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default lambda_sum_param_no_default* lambda_sum_param_with_default* lambda_sum_star_etc?"));
            _res = CHECK_VERSION ( arguments_ty , 8 , "Positional-only parameters are" , _PyPegen_make_arguments ( p , a , NULL , b , c , d ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default lambda_sum_param_no_default* lambda_sum_param_with_default* lambda_sum_star_etc?"));
    }
    { // lambda_sum_slash_with_default lambda_sum_param_with_default* lambda_sum_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default lambda_sum_param_with_default* lambda_sum_star_etc?"));
        SlashWithDefault* a;
        asdl_seq * b;
        void *c;
        if (
            (a = lambda_sum_slash_with_default_rule(p))  // lambda_sum_slash_with_default
            &&
            (b = _loop0_193_rule(p))  // lambda_sum_param_with_default*
            &&
            (c = lambda_sum_star_etc_rule(p), !p->error_indicator)  // lambda_sum_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default lambda_sum_param_with_default* lambda_sum_star_etc?"));
            _res = CHECK_VERSION ( arguments_ty , 8 , "Positional-only parameters are" , _PyPegen_make_arguments ( p , NULL , a , NULL , b , c ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default lambda_sum_param_with_default* lambda_sum_star_etc?"));
    }
    { // lambda_sum_param_no_default+ lambda_sum_param_with_default* lambda_sum_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default+ lambda_sum_param_with_default* lambda_sum_star_etc?"));
        asdl_arg_seq* a;
        asdl_seq * b;
        void *c;
        if (
            (a = (asdl_arg_seq*)_loop1_194_rule(p))  // lambda_sum_param_no_default+
            &&
            (b = _loop0_195_rule(p))  // lambda_sum_param_with_default*
            &&
            (c = lambda_sum_star_etc_rule(p), !p->error_indicator)  // lambda_sum_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default+ lambda_sum_param_with_default* lambda_sum_star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default+ lambda_sum_param_with_default* lambda_sum_star_etc?"));
    }
    { // lambda_sum_param_with_default+ lambda_sum_star_etc?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default+ lambda_sum_star_etc?"));
        asdl_seq * a;
        void *b;
        if (
            (a = _loop1_196_rule(p))  // lambda_sum_param_with_default+
            &&
            (b = lambda_sum_star_etc_rule(p), !p->error_indicator)  // lambda_sum_star_etc?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default+ lambda_sum_star_etc?"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default+ lambda_sum_star_etc?"));
    }
    { // lambda_sum_star_etc
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_star_etc"));
        StarEtc* a;
        if (
            (a = lambda_sum_star_etc_rule(p))  // lambda_sum_star_etc
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_star_etc"));
            _res = _PyPegen_make_arguments ( p , NULL , NULL , NULL , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_star_etc"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_sum_slash_no_default: param_no_default+ '/' ',' | param_no_default+ '/' &'|'
static asdl_arg_seq*
lambda_sum_slash_no_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_arg_seq* _res = NULL;
    int _mark = p->mark;
    { // param_no_default+ '/' ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_slash_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default+ '/' ','"));
        Token * _literal;
        Token * _literal_1;
        asdl_arg_seq* a;
        if (
            (a = (asdl_arg_seq*)_loop1_197_rule(p))  // param_no_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_slash_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default+ '/' ','"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_slash_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default+ '/' ','"));
    }
    { // param_no_default+ '/' &'|'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_slash_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default+ '/' &'|'"));
        Token * _literal;
        asdl_arg_seq* a;
        if (
            (a = (asdl_arg_seq*)_loop1_198_rule(p))  // param_no_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 18)  // token='|'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_slash_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default+ '/' &'|'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_slash_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default+ '/' &'|'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_sum_slash_with_default:
//     | lambda_sum_param_no_default* lambda_sum_param_with_default+ '/' ','
//     | lambda_sum_param_no_default* lambda_sum_param_with_default+ '/' &'|'
static SlashWithDefault*
lambda_sum_slash_with_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    SlashWithDefault* _res = NULL;
    int _mark = p->mark;
    { // lambda_sum_param_no_default* lambda_sum_param_with_default+ '/' ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_slash_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default* lambda_sum_param_with_default+ '/' ','"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _loop0_199_rule(p))  // lambda_sum_param_no_default*
            &&
            (b = _loop1_200_rule(p))  // lambda_sum_param_with_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_slash_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default* lambda_sum_param_with_default+ '/' ','"));
            _res = _PyPegen_slash_with_default ( p , ( asdl_arg_seq* ) a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_slash_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default* lambda_sum_param_with_default+ '/' ','"));
    }
    { // lambda_sum_param_no_default* lambda_sum_param_with_default+ '/' &'|'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_slash_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default* lambda_sum_param_with_default+ '/' &'|'"));
        Token * _literal;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _loop0_201_rule(p))  // lambda_sum_param_no_default*
            &&
            (b = _loop1_202_rule(p))  // lambda_sum_param_with_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 18)  // token='|'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_slash_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default* lambda_sum_param_with_default+ '/' &'|'"));
            _res = _PyPegen_slash_with_default ( p , ( asdl_arg_seq* ) a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_slash_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default* lambda_sum_param_with_default+ '/' &'|'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_sum_star_etc:
//     | invalid_lambda_sum_star_etc
//     | '*' lambda_sum_param_no_default lambda_sum_param_maybe_default* lambda_sum_kwds?
//     | '*' lambda_sum_param_no_default_star_annotation lambda_sum_param_maybe_default* lambda_sum_kwds?
//     | '*' ',' lambda_sum_param_maybe_default+ lambda_sum_kwds?
//     | lambda_sum_kwds
static StarEtc*
lambda_sum_star_etc_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    StarEtc* _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_lambda_sum_star_etc
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_lambda_sum_star_etc"));
        void *invalid_lambda_sum_star_etc_var;
        if (
            (invalid_lambda_sum_star_etc_var = invalid_lambda_sum_star_etc_rule(p))  // invalid_lambda_sum_star_etc
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_lambda_sum_star_etc"));
            _res = invalid_lambda_sum_star_etc_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_lambda_sum_star_etc"));
    }
    { // '*' lambda_sum_param_no_default lambda_sum_param_maybe_default* lambda_sum_kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' lambda_sum_param_no_default lambda_sum_param_maybe_default* lambda_sum_kwds?"));
        Token * _literal;
        arg_ty a;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
            &&
            (b = _loop0_203_rule(p))  // lambda_sum_param_maybe_default*
            &&
            (c = lambda_sum_kwds_rule(p), !p->error_indicator)  // lambda_sum_kwds?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' lambda_sum_param_no_default lambda_sum_param_maybe_default* lambda_sum_kwds?"));
            _res = _PyPegen_star_etc ( p , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' lambda_sum_param_no_default lambda_sum_param_maybe_default* lambda_sum_kwds?"));
    }
    { // '*' lambda_sum_param_no_default_star_annotation lambda_sum_param_maybe_default* lambda_sum_kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' lambda_sum_param_no_default_star_annotation lambda_sum_param_maybe_default* lambda_sum_kwds?"));
        Token * _literal;
        arg_ty a;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = lambda_sum_param_no_default_star_annotation_rule(p))  // lambda_sum_param_no_default_star_annotation
            &&
            (b = _loop0_204_rule(p))  // lambda_sum_param_maybe_default*
            &&
            (c = lambda_sum_kwds_rule(p), !p->error_indicator)  // lambda_sum_kwds?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' lambda_sum_param_no_default_star_annotation lambda_sum_param_maybe_default* lambda_sum_kwds?"));
            _res = _PyPegen_star_etc ( p , a , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' lambda_sum_param_no_default_star_annotation lambda_sum_param_maybe_default* lambda_sum_kwds?"));
    }
    { // '*' ',' lambda_sum_param_maybe_default+ lambda_sum_kwds?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' ',' lambda_sum_param_maybe_default+ lambda_sum_kwds?"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * b;
        void *c;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (b = _loop1_205_rule(p))  // lambda_sum_param_maybe_default+
            &&
            (c = lambda_sum_kwds_rule(p), !p->error_indicator)  // lambda_sum_kwds?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' ',' lambda_sum_param_maybe_default+ lambda_sum_kwds?"));
            _res = _PyPegen_star_etc ( p , NULL , b , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' ',' lambda_sum_param_maybe_default+ lambda_sum_kwds?"));
    }
    { // lambda_sum_kwds
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_kwds"));
        arg_ty a;
        if (
            (a = lambda_sum_kwds_rule(p))  // lambda_sum_kwds
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_kwds"));
            _res = _PyPegen_star_etc ( p , NULL , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_kwds"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_sum_kwds: invalid_kwds | '**' lambda_sum_param_no_default
static arg_ty
lambda_sum_kwds_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_kwds
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_kwds"));
        void *invalid_kwds_var;
        if (
            (invalid_kwds_var = invalid_kwds_rule(p))  // invalid_kwds
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_kwds"));
            _res = invalid_kwds_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_kwds"));
    }
    { // '**' lambda_sum_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' lambda_sum_param_no_default"));
        Token * _literal;
        arg_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' lambda_sum_param_no_default"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' lambda_sum_param_no_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_sum_param_no_default: sum_param ',' TYPE_COMMENT? | sum_param TYPE_COMMENT? &'|'
static arg_ty
lambda_sum_param_no_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    { // sum_param ',' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_param_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param ',' TYPE_COMMENT?"));
        Token * _literal;
        arg_ty a;
        void *tc;
        if (
            (a = sum_param_rule(p))  // sum_param
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_param_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param ',' TYPE_COMMENT?"));
            _res = _PyPegen_add_type_comment_to_arg ( p , a , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_param_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum_param ',' TYPE_COMMENT?"));
    }
    { // sum_param TYPE_COMMENT? &'|'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_param_no_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param TYPE_COMMENT? &'|'"));
        arg_ty a;
        void *tc;
        if (
            (a = sum_param_rule(p))  // sum_param
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 18)  // token='|'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_param_no_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param TYPE_COMMENT? &'|'"));
            _res = _PyPegen_add_type_comment_to_arg ( p , a , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_param_no_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum_param TYPE_COMMENT? &'|'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_sum_param_no_default_star_annotation:
//     | sum_param_star_annotation ',' TYPE_COMMENT?
//     | sum_param_star_annotation TYPE_COMMENT? &'|'
static arg_ty
lambda_sum_param_no_default_star_annotation_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    { // sum_param_star_annotation ',' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_param_no_default_star_annotation[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param_star_annotation ',' TYPE_COMMENT?"));
        Token * _literal;
        arg_ty a;
        void *tc;
        if (
            (a = sum_param_star_annotation_rule(p))  // sum_param_star_annotation
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_param_no_default_star_annotation[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param_star_annotation ',' TYPE_COMMENT?"));
            _res = _PyPegen_add_type_comment_to_arg ( p , a , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_param_no_default_star_annotation[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum_param_star_annotation ',' TYPE_COMMENT?"));
    }
    { // sum_param_star_annotation TYPE_COMMENT? &'|'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_param_no_default_star_annotation[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param_star_annotation TYPE_COMMENT? &'|'"));
        arg_ty a;
        void *tc;
        if (
            (a = sum_param_star_annotation_rule(p))  // sum_param_star_annotation
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 18)  // token='|'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_param_no_default_star_annotation[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param_star_annotation TYPE_COMMENT? &'|'"));
            _res = _PyPegen_add_type_comment_to_arg ( p , a , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_param_no_default_star_annotation[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum_param_star_annotation TYPE_COMMENT? &'|'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_sum_param_with_default:
//     | sum_param sum_default ',' TYPE_COMMENT?
//     | sum_param sum_default TYPE_COMMENT? &'|'
static NameDefaultPair*
lambda_sum_param_with_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    NameDefaultPair* _res = NULL;
    int _mark = p->mark;
    { // sum_param sum_default ',' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_param_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param sum_default ',' TYPE_COMMENT?"));
        Token * _literal;
        arg_ty a;
        expr_ty c;
        void *tc;
        if (
            (a = sum_param_rule(p))  // sum_param
            &&
            (c = sum_default_rule(p))  // sum_default
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_param_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param sum_default ',' TYPE_COMMENT?"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_param_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum_param sum_default ',' TYPE_COMMENT?"));
    }
    { // sum_param sum_default TYPE_COMMENT? &'|'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_param_with_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param sum_default TYPE_COMMENT? &'|'"));
        arg_ty a;
        expr_ty c;
        void *tc;
        if (
            (a = sum_param_rule(p))  // sum_param
            &&
            (c = sum_default_rule(p))  // sum_default
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 18)  // token='|'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_param_with_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param sum_default TYPE_COMMENT? &'|'"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_param_with_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum_param sum_default TYPE_COMMENT? &'|'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// lambda_sum_param_maybe_default:
//     | sum_param sum_default? ',' TYPE_COMMENT?
//     | sum_param sum_default? TYPE_COMMENT? &'|'
static NameDefaultPair*
lambda_sum_param_maybe_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    NameDefaultPair* _res = NULL;
    int _mark = p->mark;
    { // sum_param sum_default? ',' TYPE_COMMENT?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_param_maybe_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param sum_default? ',' TYPE_COMMENT?"));
        Token * _literal;
        arg_ty a;
        void *c;
        void *tc;
        if (
            (a = sum_param_rule(p))  // sum_param
            &&
            (c = sum_default_rule(p), !p->error_indicator)  // sum_default?
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_param_maybe_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param sum_default? ',' TYPE_COMMENT?"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_param_maybe_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum_param sum_default? ',' TYPE_COMMENT?"));
    }
    { // sum_param sum_default? TYPE_COMMENT? &'|'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> lambda_sum_param_maybe_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param sum_default? TYPE_COMMENT? &'|'"));
        arg_ty a;
        void *c;
        void *tc;
        if (
            (a = sum_param_rule(p))  // sum_param
            &&
            (c = sum_default_rule(p), !p->error_indicator)  // sum_default?
            &&
            (tc = _PyPegen_expect_token(p, TYPE_COMMENT), !p->error_indicator)  // TYPE_COMMENT?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 18)  // token='|'
        )
        {
            D(fprintf(stderr, "%*c+ lambda_sum_param_maybe_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "sum_param sum_default? TYPE_COMMENT? &'|'"));
            _res = _PyPegen_name_default_pair ( p , a , c , tc );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s lambda_sum_param_maybe_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "sum_param sum_default? TYPE_COMMENT? &'|'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// sum_param: NAME sum_annotation?
static arg_ty
sum_param_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME sum_annotation?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum_param[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME sum_annotation?"));
        expr_ty a;
        void *b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = sum_annotation_rule(p), !p->error_indicator)  // sum_annotation?
        )
        {
            D(fprintf(stderr, "%*c+ sum_param[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME sum_annotation?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_arg ( a -> v . Name . id , b , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum_param[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME sum_annotation?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// sum_param_star_annotation: NAME star_sum_annotation
static arg_ty
sum_param_star_annotation_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    arg_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME star_sum_annotation
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum_param_star_annotation[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME star_sum_annotation"));
        expr_ty a;
        expr_ty b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = star_sum_annotation_rule(p))  // star_sum_annotation
        )
        {
            D(fprintf(stderr, "%*c+ sum_param_star_annotation[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME star_sum_annotation"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_arg ( a -> v . Name . id , b , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum_param_star_annotation[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME star_sum_annotation"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// sum_annotation: ':' sum
static expr_ty
sum_annotation_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // ':' sum
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum_annotation[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' sum"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (a = sum_rule(p))  // sum
        )
        {
            D(fprintf(stderr, "%*c+ sum_annotation[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' sum"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum_annotation[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':' sum"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_sum_annotation: ':' star_sum
static expr_ty
star_sum_annotation_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // ':' star_sum
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_sum_annotation[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' star_sum"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (a = star_sum_rule(p))  // star_sum
        )
        {
            D(fprintf(stderr, "%*c+ star_sum_annotation[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' star_sum"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_sum_annotation[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':' star_sum"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// sum_default: '=' sum | invalid_sum_default
static expr_ty
sum_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // '=' sum
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' sum"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (a = sum_rule(p))  // sum
        )
        {
            D(fprintf(stderr, "%*c+ sum_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' sum"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'=' sum"));
    }
    if (p->call_invalid_rules) { // invalid_sum_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> sum_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_sum_default"));
        void *invalid_sum_default_var;
        if (
            (invalid_sum_default_var = invalid_sum_default_rule(p))  // invalid_sum_default
        )
        {
            D(fprintf(stderr, "%*c+ sum_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_sum_default"));
            _res = invalid_sum_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s sum_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_sum_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// fstring_middle: fstring_replacement_field | FSTRING_MIDDLE
static expr_ty
fstring_middle_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // fstring_replacement_field
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> fstring_middle[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "fstring_replacement_field"));
        expr_ty fstring_replacement_field_var;
        if (
            (fstring_replacement_field_var = fstring_replacement_field_rule(p))  // fstring_replacement_field
        )
        {
            D(fprintf(stderr, "%*c+ fstring_middle[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "fstring_replacement_field"));
            _res = fstring_replacement_field_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s fstring_middle[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "fstring_replacement_field"));
    }
    { // FSTRING_MIDDLE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> fstring_middle[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "FSTRING_MIDDLE"));
        Token * t;
        if (
            (t = _PyPegen_expect_token(p, FSTRING_MIDDLE))  // token='FSTRING_MIDDLE'
        )
        {
            D(fprintf(stderr, "%*c+ fstring_middle[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "FSTRING_MIDDLE"));
            _res = _PyPegen_constant_from_token ( p , t );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s fstring_middle[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "FSTRING_MIDDLE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// fstring_replacement_field:
//     | '{' top_rhs "="? fstring_conversion? fstring_full_format_spec? '}'
//     | invalid_replacement_field
static expr_ty
fstring_replacement_field_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '{' top_rhs "="? fstring_conversion? fstring_full_format_spec? '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> fstring_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs \"=\"? fstring_conversion? fstring_full_format_spec? '}'"));
        Token * _literal;
        expr_ty a;
        void *conversion;
        void *debug_expr;
        void *format;
        Token * rbrace;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = top_rhs_rule(p))  // top_rhs
            &&
            (debug_expr = _PyPegen_expect_token(p, 22), !p->error_indicator)  // "="?
            &&
            (conversion = fstring_conversion_rule(p), !p->error_indicator)  // fstring_conversion?
            &&
            (format = fstring_full_format_spec_rule(p), !p->error_indicator)  // fstring_full_format_spec?
            &&
            (rbrace = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ fstring_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs \"=\"? fstring_conversion? fstring_full_format_spec? '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_formatted_value ( p , a , debug_expr , conversion , format , rbrace , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s fstring_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' top_rhs \"=\"? fstring_conversion? fstring_full_format_spec? '}'"));
    }
    if (p->call_invalid_rules) { // invalid_replacement_field
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> fstring_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_replacement_field"));
        void *invalid_replacement_field_var;
        if (
            (invalid_replacement_field_var = invalid_replacement_field_rule(p))  // invalid_replacement_field
        )
        {
            D(fprintf(stderr, "%*c+ fstring_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_replacement_field"));
            _res = invalid_replacement_field_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s fstring_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_replacement_field"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// fstring_conversion: "!" NAME
static ResultTokenWithMetadata*
fstring_conversion_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    ResultTokenWithMetadata* _res = NULL;
    int _mark = p->mark;
    { // "!" NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> fstring_conversion[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"!\" NAME"));
        expr_ty conv;
        Token * conv_token;
        if (
            (conv_token = _PyPegen_expect_token(p, 54))  // token='!'
            &&
            (conv = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ fstring_conversion[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"!\" NAME"));
            _res = _PyPegen_check_fstring_conversion ( p , conv_token , conv );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s fstring_conversion[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"!\" NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// fstring_full_format_spec: ':' fstring_format_spec*
static ResultTokenWithMetadata*
fstring_full_format_spec_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    ResultTokenWithMetadata* _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // ':' fstring_format_spec*
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> fstring_full_format_spec[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' fstring_format_spec*"));
        Token * colon;
        asdl_seq * spec;
        if (
            (colon = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (spec = _loop0_206_rule(p))  // fstring_format_spec*
        )
        {
            D(fprintf(stderr, "%*c+ fstring_full_format_spec[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' fstring_format_spec*"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_setup_full_format_spec ( p , colon , ( asdl_expr_seq* ) spec , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s fstring_full_format_spec[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':' fstring_format_spec*"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// fstring_format_spec: FSTRING_MIDDLE | fstring_replacement_field
static expr_ty
fstring_format_spec_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // FSTRING_MIDDLE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> fstring_format_spec[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "FSTRING_MIDDLE"));
        Token * t;
        if (
            (t = _PyPegen_expect_token(p, FSTRING_MIDDLE))  // token='FSTRING_MIDDLE'
        )
        {
            D(fprintf(stderr, "%*c+ fstring_format_spec[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "FSTRING_MIDDLE"));
            _res = _PyPegen_decoded_constant_from_token ( p , t );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s fstring_format_spec[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "FSTRING_MIDDLE"));
    }
    { // fstring_replacement_field
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> fstring_format_spec[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "fstring_replacement_field"));
        expr_ty fstring_replacement_field_var;
        if (
            (fstring_replacement_field_var = fstring_replacement_field_rule(p))  // fstring_replacement_field
        )
        {
            D(fprintf(stderr, "%*c+ fstring_format_spec[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "fstring_replacement_field"));
            _res = fstring_replacement_field_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s fstring_format_spec[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "fstring_replacement_field"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// string: STRING
static expr_ty
string_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // STRING
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> string[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "STRING"));
        Token* s;
        if (
            (s = (Token*)_PyPegen_string_token(p))  // STRING
        )
        {
            D(fprintf(stderr, "%*c+ string[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "STRING"));
            _res = _PyPegen_constant_from_string ( p , s );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s string[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "STRING"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// strings: ((fstring | string))+
static expr_ty
strings_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, strings_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // ((fstring | string))+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> strings[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((fstring | string))+"));
        asdl_expr_seq* a;
        if (
            (a = (asdl_expr_seq*)_loop1_207_rule(p))  // ((fstring | string))+
        )
        {
            D(fprintf(stderr, "%*c+ strings[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((fstring | string))+"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_concatenate_strings ( p , a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s strings[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "((fstring | string))+"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, strings_type, _res);
    p->level--;
    return _res;
}

// list: '[' star_named_expressions? ']'
static expr_ty
list_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '[' star_named_expressions? ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> list[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' star_named_expressions? ']'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (a = star_named_expressions_rule(p), !p->error_indicator)  // star_named_expressions?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ list[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' star_named_expressions? ']'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_List ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s list[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'[' star_named_expressions? ']'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// tuple: '(' [star_named_expression ',' star_named_expressions?] ')'
static expr_ty
tuple_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '(' [star_named_expression ',' star_named_expressions?] ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> tuple[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' [star_named_expression ',' star_named_expressions?] ')'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = _tmp_208_rule(p), !p->error_indicator)  // [star_named_expression ',' star_named_expressions?]
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ tuple[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' [star_named_expression ',' star_named_expressions?] ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Tuple ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s tuple[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' [star_named_expression ',' star_named_expressions?] ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// set: '{' star_named_expressions '}'
static expr_ty
set_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '{' star_named_expressions '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> set[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' star_named_expressions '}'"));
        Token * _literal;
        Token * _literal_1;
        asdl_expr_seq* a;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = star_named_expressions_rule(p))  // star_named_expressions
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ set[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' star_named_expressions '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Set ( a , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s set[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' star_named_expressions '}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// dict: '{' double_starred_kvpairs? '}' | '{' invalid_double_starred_kvpairs '}'
static expr_ty
dict_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '{' double_starred_kvpairs? '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dict[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' double_starred_kvpairs? '}'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = double_starred_kvpairs_rule(p), !p->error_indicator)  // double_starred_kvpairs?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ dict[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' double_starred_kvpairs? '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Dict ( CHECK ( asdl_expr_seq* , _PyPegen_get_keys ( p , a ) ) , CHECK ( asdl_expr_seq* , _PyPegen_get_values ( p , a ) ) , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dict[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' double_starred_kvpairs? '}'"));
    }
    { // '{' invalid_double_starred_kvpairs '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dict[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' invalid_double_starred_kvpairs '}'"));
        Token * _literal;
        Token * _literal_1;
        void *invalid_double_starred_kvpairs_var;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (invalid_double_starred_kvpairs_var = invalid_double_starred_kvpairs_rule(p))  // invalid_double_starred_kvpairs
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ dict[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' invalid_double_starred_kvpairs '}'"));
            _res = _PyPegen_dummy_name(p, _literal, invalid_double_starred_kvpairs_var, _literal_1);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dict[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' invalid_double_starred_kvpairs '}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// double_starred_kvpairs: ','.double_starred_kvpair+ ','?
static asdl_seq*
double_starred_kvpairs_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.double_starred_kvpair+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> double_starred_kvpairs[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.double_starred_kvpair+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_seq * a;
        if (
            (a = _gather_209_rule(p))  // ','.double_starred_kvpair+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ double_starred_kvpairs[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.double_starred_kvpair+ ','?"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s double_starred_kvpairs[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.double_starred_kvpair+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// double_starred_kvpair: '**' bitwise_or | kvpair
static KeyValuePair*
double_starred_kvpair_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    KeyValuePair* _res = NULL;
    int _mark = p->mark;
    { // '**' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> double_starred_kvpair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' bitwise_or"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ double_starred_kvpair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' bitwise_or"));
            _res = _PyPegen_key_value_pair ( p , NULL , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s double_starred_kvpair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' bitwise_or"));
    }
    { // kvpair
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> double_starred_kvpair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kvpair"));
        KeyValuePair* kvpair_var;
        if (
            (kvpair_var = kvpair_rule(p))  // kvpair
        )
        {
            D(fprintf(stderr, "%*c+ double_starred_kvpair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kvpair"));
            _res = kvpair_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s double_starred_kvpair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "kvpair"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// kvpair: expression ':' expression
static KeyValuePair*
kvpair_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    KeyValuePair* _res = NULL;
    int _mark = p->mark;
    { // expression ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kvpair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' expression"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ kvpair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' expression"));
            _res = _PyPegen_key_value_pair ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kvpair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ':' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// for_if_clauses: for_if_clause+
static asdl_comprehension_seq*
for_if_clauses_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_comprehension_seq* _res = NULL;
    int _mark = p->mark;
    { // for_if_clause+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_if_clauses[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "for_if_clause+"));
        asdl_comprehension_seq* a;
        if (
            (a = (asdl_comprehension_seq*)_loop1_211_rule(p))  // for_if_clause+
        )
        {
            D(fprintf(stderr, "%*c+ for_if_clauses[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "for_if_clause+"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_if_clauses[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "for_if_clause+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// for_if_clause:
//     | 'async' 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
//     | 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
//     | "where" star_targets '=' disjunction (('if' disjunction))*
//     | invalid_for_target
static comprehension_ty
for_if_clause_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    comprehension_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'async' 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_if_clause[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        Token * _keyword_2;
        expr_ty a;
        expr_ty b;
        asdl_expr_seq* c;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (a = star_targets_rule(p))  // star_targets
            &&
            (_keyword_2 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (b = disjunction_rule(p))  // disjunction
            &&
            (c = (asdl_expr_seq*)_loop0_212_rule(p))  // (('if' disjunction))*
        )
        {
            D(fprintf(stderr, "%*c+ for_if_clause[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
            _res = CHECK_VERSION ( comprehension_ty , 6 , "Async comprehensions are" , _PyAST_comprehension ( a , b , c , 1 , p -> arena ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_if_clause[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async' 'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // 'for' star_targets 'in' ~ disjunction (('if' disjunction))*
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_if_clause[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
        int _cut_var = 0;
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        expr_ty b;
        asdl_expr_seq* c;
        if (
            (_keyword = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (a = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (_cut_var = 1)
            &&
            (b = disjunction_rule(p))  // disjunction
            &&
            (c = (asdl_expr_seq*)_loop0_213_rule(p))  // (('if' disjunction))*
        )
        {
            D(fprintf(stderr, "%*c+ for_if_clause[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
            _res = _PyAST_comprehension ( a , b , c , 0 , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_if_clause[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'for' star_targets 'in' ~ disjunction (('if' disjunction))*"));
        if (_cut_var) {
            p->level--;
            return NULL;
        }
    }
    { // "where" star_targets '=' disjunction (('if' disjunction))*
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_if_clause[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"where\" star_targets '=' disjunction (('if' disjunction))*"));
        expr_ty _keyword;
        Token * _literal;
        expr_ty a;
        expr_ty b;
        asdl_expr_seq* c;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "where"))  // soft_keyword='"where"'
            &&
            (a = star_targets_rule(p))  // star_targets
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (b = disjunction_rule(p))  // disjunction
            &&
            (c = (asdl_expr_seq*)_loop0_214_rule(p))  // (('if' disjunction))*
        )
        {
            D(fprintf(stderr, "%*c+ for_if_clause[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"where\" star_targets '=' disjunction (('if' disjunction))*"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_comprehension ( a , _PyAST_List ( CHECK ( asdl_expr_seq* , _PyPegen_singleton_seq ( p , b ) ) , Load , EXTRA ) , c , 0 , p -> arena );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_if_clause[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"where\" star_targets '=' disjunction (('if' disjunction))*"));
    }
    if (p->call_invalid_rules) { // invalid_for_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> for_if_clause[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_for_target"));
        void *invalid_for_target_var;
        if (
            (invalid_for_target_var = invalid_for_target_rule(p))  // invalid_for_target
        )
        {
            D(fprintf(stderr, "%*c+ for_if_clause[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_for_target"));
            _res = invalid_for_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s for_if_clause[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_for_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// listcomp: '[' named_expression for_if_clauses ']' | invalid_comprehension
static expr_ty
listcomp_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '[' named_expression for_if_clauses ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> listcomp[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' named_expression for_if_clauses ']'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        asdl_comprehension_seq* b;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ listcomp[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' named_expression for_if_clauses ']'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_ListComp ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s listcomp[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'[' named_expression for_if_clauses ']'"));
    }
    if (p->call_invalid_rules) { // invalid_comprehension
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> listcomp[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
        void *invalid_comprehension_var;
        if (
            (invalid_comprehension_var = invalid_comprehension_rule(p))  // invalid_comprehension
        )
        {
            D(fprintf(stderr, "%*c+ listcomp[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
            _res = invalid_comprehension_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s listcomp[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// tuplecomp:
//     | '(' (assignment_expression | expression !':=') for_if_clauses ',' ')'
//     | invalid_comprehension
static expr_ty
tuplecomp_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '(' (assignment_expression | expression !':=') for_if_clauses ',' ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> tuplecomp[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' (assignment_expression | expression !':=') for_if_clauses ',' ')'"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *a;
        asdl_comprehension_seq* b;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = _tmp_215_rule(p))  // assignment_expression | expression !':='
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_2 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ tuplecomp[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' (assignment_expression | expression !':=') for_if_clauses ',' ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_TupleComp ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s tuplecomp[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' (assignment_expression | expression !':=') for_if_clauses ',' ')'"));
    }
    if (p->call_invalid_rules) { // invalid_comprehension
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> tuplecomp[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
        void *invalid_comprehension_var;
        if (
            (invalid_comprehension_var = invalid_comprehension_rule(p))  // invalid_comprehension
        )
        {
            D(fprintf(stderr, "%*c+ tuplecomp[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
            _res = invalid_comprehension_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s tuplecomp[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// setcomp: '{' named_expression for_if_clauses '}' | invalid_comprehension
static expr_ty
setcomp_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '{' named_expression for_if_clauses '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> setcomp[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' named_expression for_if_clauses '}'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        asdl_comprehension_seq* b;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = named_expression_rule(p))  // named_expression
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ setcomp[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' named_expression for_if_clauses '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_SetComp ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s setcomp[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' named_expression for_if_clauses '}'"));
    }
    if (p->call_invalid_rules) { // invalid_comprehension
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> setcomp[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
        void *invalid_comprehension_var;
        if (
            (invalid_comprehension_var = invalid_comprehension_rule(p))  // invalid_comprehension
        )
        {
            D(fprintf(stderr, "%*c+ setcomp[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
            _res = invalid_comprehension_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s setcomp[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// genexp:
//     | '(' (assignment_expression | expression !':=') for_if_clauses ')'
//     | invalid_comprehension
static expr_ty
genexp_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '(' (assignment_expression | expression !':=') for_if_clauses ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> genexp[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' (assignment_expression | expression !':=') for_if_clauses ')'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        asdl_comprehension_seq* b;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = _tmp_216_rule(p))  // assignment_expression | expression !':='
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ genexp[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' (assignment_expression | expression !':=') for_if_clauses ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_GeneratorExp ( a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s genexp[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' (assignment_expression | expression !':=') for_if_clauses ')'"));
    }
    if (p->call_invalid_rules) { // invalid_comprehension
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> genexp[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
        void *invalid_comprehension_var;
        if (
            (invalid_comprehension_var = invalid_comprehension_rule(p))  // invalid_comprehension
        )
        {
            D(fprintf(stderr, "%*c+ genexp[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
            _res = invalid_comprehension_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s genexp[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_comprehension"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// dictcomp: '{' kvpair for_if_clauses '}' | invalid_dict_comprehension
static expr_ty
dictcomp_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '{' kvpair for_if_clauses '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dictcomp[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' kvpair for_if_clauses '}'"));
        Token * _literal;
        Token * _literal_1;
        KeyValuePair* a;
        asdl_comprehension_seq* b;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = kvpair_rule(p))  // kvpair
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ dictcomp[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' kvpair for_if_clauses '}'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_DictComp ( a -> key , a -> value , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dictcomp[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' kvpair for_if_clauses '}'"));
    }
    if (p->call_invalid_rules) { // invalid_dict_comprehension
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> dictcomp[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_dict_comprehension"));
        void *invalid_dict_comprehension_var;
        if (
            (invalid_dict_comprehension_var = invalid_dict_comprehension_rule(p))  // invalid_dict_comprehension
        )
        {
            D(fprintf(stderr, "%*c+ dictcomp[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_dict_comprehension"));
            _res = invalid_dict_comprehension_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s dictcomp[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_dict_comprehension"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// arguments: args ','? &')' | invalid_arguments
static expr_ty
arguments_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, arguments_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    { // args ','? &')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> arguments[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args ','? &')'"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        if (
            (a = args_rule(p))  // args
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            _PyPegen_lookahead_with_int(1, _PyPegen_expect_token, p, 8)  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ arguments[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args ','? &')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s arguments[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "args ','? &')'"));
    }
    if (p->call_invalid_rules) { // invalid_arguments
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> arguments[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_arguments"));
        void *invalid_arguments_var;
        if (
            (invalid_arguments_var = invalid_arguments_rule(p))  // invalid_arguments
        )
        {
            D(fprintf(stderr, "%*c+ arguments[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_arguments"));
            _res = invalid_arguments_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s arguments[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_arguments"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, arguments_type, _res);
    p->level--;
    return _res;
}

// args:
//     | ','.(starred_expression | simple_slice | (assignment_expression | expression !':=') !'=')+ [',' kwargs]
//     | kwargs
static expr_ty
args_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // ','.(starred_expression | simple_slice | (assignment_expression | expression !':=') !'=')+ [',' kwargs]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> args[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.(starred_expression | simple_slice | (assignment_expression | expression !':=') !'=')+ [',' kwargs]"));
        asdl_expr_seq* a;
        void *b;
        if (
            (a = (asdl_expr_seq*)_gather_217_rule(p))  // ','.(starred_expression | simple_slice | (assignment_expression | expression !':=') !'=')+
            &&
            (b = _tmp_219_rule(p), !p->error_indicator)  // [',' kwargs]
        )
        {
            D(fprintf(stderr, "%*c+ args[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.(starred_expression | simple_slice | (assignment_expression | expression !':=') !'=')+ [',' kwargs]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_collect_call_seqs ( p , a , b , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s args[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.(starred_expression | simple_slice | (assignment_expression | expression !':=') !'=')+ [',' kwargs]"));
    }
    { // kwargs
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> args[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwargs"));
        asdl_seq* a;
        if (
            (a = kwargs_rule(p))  // kwargs
        )
        {
            D(fprintf(stderr, "%*c+ args[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwargs"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Call ( _PyPegen_dummy_name ( p ) , CHECK_NULL_ALLOWED ( asdl_expr_seq* , _PyPegen_seq_extract_starred_exprs ( p , a ) ) , CHECK_NULL_ALLOWED ( asdl_keyword_seq* , _PyPegen_seq_delete_starred_exprs ( p , a ) ) , 0 , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s args[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "kwargs"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// kwargs:
//     | ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+
//     | ','.kwarg_or_starred+
//     | ','.kwarg_or_double_starred+
static asdl_seq*
kwargs_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwargs[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+"));
        Token * _literal;
        asdl_seq * a;
        asdl_seq * b;
        if (
            (a = _gather_220_rule(p))  // ','.kwarg_or_starred+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (b = _gather_222_rule(p))  // ','.kwarg_or_double_starred+
        )
        {
            D(fprintf(stderr, "%*c+ kwargs[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+"));
            _res = _PyPegen_join_sequences ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwargs[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.kwarg_or_starred+ ',' ','.kwarg_or_double_starred+"));
    }
    { // ','.kwarg_or_starred+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwargs[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.kwarg_or_starred+"));
        asdl_seq * _gather_224_var;
        if (
            (_gather_224_var = _gather_224_rule(p))  // ','.kwarg_or_starred+
        )
        {
            D(fprintf(stderr, "%*c+ kwargs[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.kwarg_or_starred+"));
            _res = _gather_224_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwargs[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.kwarg_or_starred+"));
    }
    { // ','.kwarg_or_double_starred+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwargs[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.kwarg_or_double_starred+"));
        asdl_seq * _gather_226_var;
        if (
            (_gather_226_var = _gather_226_rule(p))  // ','.kwarg_or_double_starred+
        )
        {
            D(fprintf(stderr, "%*c+ kwargs[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.kwarg_or_double_starred+"));
            _res = _gather_226_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwargs[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.kwarg_or_double_starred+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// starred_expression: invalid_starred_expression | '*' expression
static expr_ty
starred_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_starred_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> starred_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_starred_expression"));
        void *invalid_starred_expression_var;
        if (
            (invalid_starred_expression_var = invalid_starred_expression_rule(p))  // invalid_starred_expression
        )
        {
            D(fprintf(stderr, "%*c+ starred_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_starred_expression"));
            _res = invalid_starred_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s starred_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_starred_expression"));
    }
    { // '*' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> starred_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ starred_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Starred ( a , Load , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s starred_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// kwarg_or_starred:
//     | invalid_kwarg
//     | NAME '=' [(simple_slice | expression)]
//     | starred_expression
static KeywordOrStarred*
kwarg_or_starred_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    KeywordOrStarred* _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_kwarg
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_starred[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_kwarg"));
        void *invalid_kwarg_var;
        if (
            (invalid_kwarg_var = invalid_kwarg_rule(p))  // invalid_kwarg
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_starred[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_kwarg"));
            _res = invalid_kwarg_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_starred[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_kwarg"));
    }
    { // NAME '=' [(simple_slice | expression)]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_starred[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' [(simple_slice | expression)]"));
        Token * _literal;
        expr_ty a;
        void *b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (b = _tmp_228_rule(p), !p->error_indicator)  // [(simple_slice | expression)]
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_starred[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' [(simple_slice | expression)]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_keyword_or_starred ( p , CHECK ( keyword_ty , _PyAST_keyword ( a -> v . Name . id , b , EXTRA ) ) , 1 );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_starred[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME '=' [(simple_slice | expression)]"));
    }
    { // starred_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_starred[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "starred_expression"));
        expr_ty a;
        if (
            (a = starred_expression_rule(p))  // starred_expression
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_starred[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "starred_expression"));
            _res = _PyPegen_keyword_or_starred ( p , a , 0 );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_starred[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "starred_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// kwarg_or_double_starred:
//     | invalid_kwarg
//     | NAME '=' [(simple_slice | expression)]
//     | '**' expression
static KeywordOrStarred*
kwarg_or_double_starred_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    KeywordOrStarred* _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    if (p->call_invalid_rules) { // invalid_kwarg
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_double_starred[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_kwarg"));
        void *invalid_kwarg_var;
        if (
            (invalid_kwarg_var = invalid_kwarg_rule(p))  // invalid_kwarg
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_double_starred[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_kwarg"));
            _res = invalid_kwarg_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_double_starred[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_kwarg"));
    }
    { // NAME '=' [(simple_slice | expression)]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_double_starred[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' [(simple_slice | expression)]"));
        Token * _literal;
        expr_ty a;
        void *b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (b = _tmp_229_rule(p), !p->error_indicator)  // [(simple_slice | expression)]
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_double_starred[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' [(simple_slice | expression)]"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_keyword_or_starred ( p , CHECK ( keyword_ty , _PyAST_keyword ( a -> v . Name . id , b , EXTRA ) ) , 1 );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_double_starred[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME '=' [(simple_slice | expression)]"));
    }
    { // '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> kwarg_or_double_starred[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ kwarg_or_double_starred[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyPegen_keyword_or_starred ( p , CHECK ( keyword_ty , _PyAST_keyword ( NULL , a , EXTRA ) ) , 1 );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s kwarg_or_double_starred[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_targets: !'*' star_target !',' | star_target ((',' star_target))* ','?
static expr_ty
star_targets_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // !'*' star_target !','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_targets[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!'*' star_target !','"));
        expr_ty a;
        if (
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 16)  // token='*'
            &&
            (a = star_target_rule(p))  // star_target
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 12)  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ star_targets[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!'*' star_target !','"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_targets[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "!'*' star_target !','"));
    }
    { // star_target ((',' star_target))* ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_targets[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_target ((',' star_target))* ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        asdl_seq * b;
        if (
            (a = star_target_rule(p))  // star_target
            &&
            (b = _loop0_230_rule(p))  // ((',' star_target))*
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ star_targets[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_target ((',' star_target))* ','?"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Tuple ( CHECK ( asdl_expr_seq* , _PyPegen_seq_insert_in_front ( p , a , b ) ) , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_targets[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_target ((',' star_target))* ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_targets_list_seq: ','.star_target+ ','?
static asdl_expr_seq*
star_targets_list_seq_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_expr_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.star_target+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_targets_list_seq[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.star_target+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_expr_seq* a;
        if (
            (a = (asdl_expr_seq*)_gather_231_rule(p))  // ','.star_target+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ star_targets_list_seq[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.star_target+ ','?"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_targets_list_seq[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.star_target+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_targets_tuple_seq: star_target ((',' star_target))+ ','? | star_target ','
static asdl_expr_seq*
star_targets_tuple_seq_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_expr_seq* _res = NULL;
    int _mark = p->mark;
    { // star_target ((',' star_target))+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_targets_tuple_seq[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_target ((',' star_target))+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        asdl_seq * b;
        if (
            (a = star_target_rule(p))  // star_target
            &&
            (b = _loop1_233_rule(p))  // ((',' star_target))+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ star_targets_tuple_seq[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_target ((',' star_target))+ ','?"));
            _res = ( asdl_expr_seq* ) _PyPegen_seq_insert_in_front ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_targets_tuple_seq[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_target ((',' star_target))+ ','?"));
    }
    { // star_target ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_targets_tuple_seq[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_target ','"));
        Token * _literal;
        expr_ty a;
        if (
            (a = star_target_rule(p))  // star_target
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ star_targets_tuple_seq[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_target ','"));
            _res = ( asdl_expr_seq* ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_targets_tuple_seq[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_target ','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// star_target: '*' (!'*' star_target) | target_with_star_atom
static expr_ty
star_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, star_target_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // '*' (!'*' star_target)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (!'*' star_target)"));
        Token * _literal;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = _tmp_234_rule(p))  // !'*' star_target
        )
        {
            D(fprintf(stderr, "%*c+ star_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (!'*' star_target)"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Starred ( CHECK ( expr_ty , _PyPegen_set_expr_context ( p , a , Store ) ) , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' (!'*' star_target)"));
    }
    { // target_with_star_atom
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "target_with_star_atom"));
        expr_ty target_with_star_atom_var;
        if (
            (target_with_star_atom_var = target_with_star_atom_rule(p))  // target_with_star_atom
        )
        {
            D(fprintf(stderr, "%*c+ star_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "target_with_star_atom"));
            _res = target_with_star_atom_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "target_with_star_atom"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, star_target_type, _res);
    p->level--;
    return _res;
}

// target_with_star_atom:
//     | t_primary '?'? '.' NAME !t_lookahead
//     | t_primary '?'? '[' slices ']' !t_lookahead
//     | star_atom
static expr_ty
target_with_star_atom_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, target_with_star_atom_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // t_primary '?'? '.' NAME !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> target_with_star_atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME !t_lookahead"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        void *n;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ target_with_star_atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Attribute ( a , b -> v . Name . id , Store , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s target_with_star_atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME !t_lookahead"));
    }
    { // t_primary '?'? '[' slices ']' !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> target_with_star_atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' !t_lookahead"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        expr_ty b;
        void *n;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (b = slices_rule(p))  // slices
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ target_with_star_atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Subscript ( a , b , Store , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s target_with_star_atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' !t_lookahead"));
    }
    { // star_atom
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> target_with_star_atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_atom"));
        expr_ty star_atom_var;
        if (
            (star_atom_var = star_atom_rule(p))  // star_atom
        )
        {
            D(fprintf(stderr, "%*c+ target_with_star_atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_atom"));
            _res = star_atom_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s target_with_star_atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_atom"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, target_with_star_atom_type, _res);
    p->level--;
    return _res;
}

// star_atom:
//     | NAME
//     | '(' target_with_star_atom ')'
//     | '(' star_targets_tuple_seq? ')'
//     | '[' star_targets_list_seq? ']'
static expr_ty
star_atom_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ star_atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
            _res = _PyPegen_set_expr_context ( p , a , Store );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME"));
    }
    { // '(' target_with_star_atom ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' target_with_star_atom ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = target_with_star_atom_rule(p))  // target_with_star_atom
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ star_atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' target_with_star_atom ')'"));
            _res = _PyPegen_set_expr_context ( p , a , Store );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' target_with_star_atom ')'"));
    }
    { // '(' star_targets_tuple_seq? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' star_targets_tuple_seq? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = star_targets_tuple_seq_rule(p), !p->error_indicator)  // star_targets_tuple_seq?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ star_atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' star_targets_tuple_seq? ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Tuple ( a , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' star_targets_tuple_seq? ')'"));
    }
    { // '[' star_targets_list_seq? ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> star_atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' star_targets_list_seq? ']'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (a = star_targets_list_seq_rule(p), !p->error_indicator)  // star_targets_list_seq?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ star_atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' star_targets_list_seq? ']'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_List ( a , Store , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s star_atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'[' star_targets_list_seq? ']'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// single_target: single_subscript_attribute_target | NAME | '(' single_target ')'
static expr_ty
single_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // single_subscript_attribute_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> single_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
        expr_ty single_subscript_attribute_target_var;
        if (
            (single_subscript_attribute_target_var = single_subscript_attribute_target_rule(p))  // single_subscript_attribute_target
        )
        {
            D(fprintf(stderr, "%*c+ single_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
            _res = single_subscript_attribute_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s single_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
    }
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> single_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ single_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
            _res = _PyPegen_set_expr_context ( p , a , Store );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s single_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME"));
    }
    { // '(' single_target ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> single_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = single_target_rule(p))  // single_target
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ single_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s single_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// single_subscript_attribute_target:
//     | t_primary '?'? '.' NAME !t_lookahead
//     | t_primary '?'? '[' slices ']' !t_lookahead
static expr_ty
single_subscript_attribute_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // t_primary '?'? '.' NAME !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> single_subscript_attribute_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME !t_lookahead"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        void *n;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ single_subscript_attribute_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Attribute ( a , b -> v . Name . id , Store , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s single_subscript_attribute_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME !t_lookahead"));
    }
    { // t_primary '?'? '[' slices ']' !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> single_subscript_attribute_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' !t_lookahead"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        expr_ty b;
        void *n;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (b = slices_rule(p))  // slices
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ single_subscript_attribute_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Subscript ( a , b , Store , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s single_subscript_attribute_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' !t_lookahead"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// Left-recursive
// t_primary:
//     | t_primary '?'? '.' NAME &t_lookahead
//     | t_primary '?'? '[' slices ']' &t_lookahead
//     | t_primary '?'? (genexp | tuplecomp) &t_lookahead
//     | t_primary '?'? '(' arguments? ')' &t_lookahead
//     | atom &t_lookahead
static expr_ty t_primary_raw(Parser *);
static expr_ty
t_primary_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, t_primary_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    int _resmark = p->mark;
    while (1) {
        int tmpvar_16 = _PyPegen_update_memo(p, _mark, t_primary_type, _res);
        if (tmpvar_16) {
            p->level--;
            return _res;
        }
        p->mark = _mark;
        void *_raw = t_primary_raw(p);
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        if (_raw == NULL || p->mark <= _resmark)
            break;
        _resmark = p->mark;
        _res = _raw;
    }
    p->mark = _resmark;
    p->level--;
    return _res;
}
static expr_ty
t_primary_raw(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // t_primary '?'? '.' NAME &t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME &t_lookahead"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        void *n;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ t_primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME &t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Attribute ( a , b -> v . Name . id , Load , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME &t_lookahead"));
    }
    { // t_primary '?'? '[' slices ']' &t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' &t_lookahead"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        expr_ty b;
        void *n;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (b = slices_rule(p))  // slices
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ t_primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' &t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Subscript ( a , b , Load , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' &t_lookahead"));
    }
    { // t_primary '?'? (genexp | tuplecomp) &t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? (genexp | tuplecomp) &t_lookahead"));
        expr_ty a;
        void *b;
        void *n;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (b = _tmp_235_rule(p))  // genexp | tuplecomp
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ t_primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? (genexp | tuplecomp) &t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Call ( a , CHECK ( asdl_expr_seq* , ( asdl_expr_seq* ) _PyPegen_singleton_seq ( p , b ) ) , NULL , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "t_primary '?'? (genexp | tuplecomp) &t_lookahead"));
    }
    { // t_primary '?'? '(' arguments? ')' &t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '(' arguments? ')' &t_lookahead"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        void *b;
        void *n;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (b = arguments_rule(p), !p->error_indicator)  // arguments?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ t_primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '(' arguments? ')' &t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Call ( a , ( b ) ? ( ( expr_ty ) b ) -> v . Call . args : NULL , ( b ) ? ( ( expr_ty ) b ) -> v . Call . keywords : NULL , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "t_primary '?'? '(' arguments? ')' &t_lookahead"));
    }
    { // atom &t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_primary[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "atom &t_lookahead"));
        expr_ty a;
        if (
            (a = atom_rule(p))  // atom
            &&
            _PyPegen_lookahead(1, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ t_primary[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "atom &t_lookahead"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_primary[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "atom &t_lookahead"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// t_lookahead: '?'? t_lookmain
static void *
t_lookahead_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '?'? t_lookmain
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_lookahead[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'?'? t_lookmain"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *t_lookmain_var;
        if (
            (_opt_var = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (t_lookmain_var = t_lookmain_rule(p))  // t_lookmain
        )
        {
            D(fprintf(stderr, "%*c+ t_lookahead[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'?'? t_lookmain"));
            _res = _PyPegen_dummy_name(p, _opt_var, t_lookmain_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_lookahead[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'?'? t_lookmain"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// t_lookmain: '(' | '[' | '.'
static void *
t_lookmain_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '('
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_lookmain[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'('"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
        )
        {
            D(fprintf(stderr, "%*c+ t_lookmain[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'('"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_lookmain[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'('"));
    }
    { // '['
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_lookmain[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'['"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
        )
        {
            D(fprintf(stderr, "%*c+ t_lookmain[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'['"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_lookmain[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'['"));
    }
    { // '.'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> t_lookmain[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'.'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
        )
        {
            D(fprintf(stderr, "%*c+ t_lookmain[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'.'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s t_lookmain[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'.'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// del_targets: ','.del_target+ ','?
static asdl_expr_seq*
del_targets_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_expr_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.del_target+ ','?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_targets[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.del_target+ ','?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_expr_seq* a;
        if (
            (a = (asdl_expr_seq*)_gather_236_rule(p))  // ','.del_target+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
        )
        {
            D(fprintf(stderr, "%*c+ del_targets[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.del_target+ ','?"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_targets[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.del_target+ ','?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// del_target:
//     | t_primary '?'? '.' NAME !t_lookahead
//     | t_primary '?'? '[' slices ']' !t_lookahead
//     | del_t_atom
static expr_ty
del_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    if (_PyPegen_is_memoized(p, del_target_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // t_primary '?'? '.' NAME !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME !t_lookahead"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        void *n;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
            &&
            (b = _PyPegen_name_token(p))  // NAME
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ del_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Attribute ( a , b -> v . Name . id , Del , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "t_primary '?'? '.' NAME !t_lookahead"));
    }
    { // t_primary '?'? '[' slices ']' !t_lookahead
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' !t_lookahead"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        expr_ty b;
        void *n;
        if (
            (a = t_primary_rule(p))  // t_primary
            &&
            (n = _PyPegen_expect_token(p, 58), !p->error_indicator)  // '?'?
            &&
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (b = slices_rule(p))  // slices
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
            &&
            _PyPegen_lookahead(0, t_lookahead_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ del_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' !t_lookahead"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Subscript ( a , b , Del , n != NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "t_primary '?'? '[' slices ']' !t_lookahead"));
    }
    { // del_t_atom
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "del_t_atom"));
        expr_ty del_t_atom_var;
        if (
            (del_t_atom_var = del_t_atom_rule(p))  // del_t_atom
        )
        {
            D(fprintf(stderr, "%*c+ del_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "del_t_atom"));
            _res = del_t_atom_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "del_t_atom"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, del_target_type, _res);
    p->level--;
    return _res;
}

// del_t_atom: NAME | '(' del_target ')' | '(' del_targets? ')' | '[' del_targets? ']'
static expr_ty
del_t_atom_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_t_atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
        expr_ty a;
        if (
            (a = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ del_t_atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME"));
            _res = _PyPegen_set_expr_context ( p , a , Del );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_t_atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME"));
    }
    { // '(' del_target ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_t_atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' del_target ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = del_target_rule(p))  // del_target
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ del_t_atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' del_target ')'"));
            _res = _PyPegen_set_expr_context ( p , a , Del );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_t_atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' del_target ')'"));
    }
    { // '(' del_targets? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_t_atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' del_targets? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = del_targets_rule(p), !p->error_indicator)  // del_targets?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ del_t_atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' del_targets? ')'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Tuple ( a , Del , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_t_atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' del_targets? ')'"));
    }
    { // '[' del_targets? ']'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> del_t_atom[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' del_targets? ']'"));
        Token * _literal;
        Token * _literal_1;
        void *a;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
            &&
            (a = del_targets_rule(p), !p->error_indicator)  // del_targets?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 10))  // token=']'
        )
        {
            D(fprintf(stderr, "%*c+ del_t_atom[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'[' del_targets? ']'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_List ( a , Del , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s del_t_atom[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'[' del_targets? ']'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// type_expressions:
//     | ','.expression+ ',' '*' expression ',' '**' expression
//     | ','.expression+ ',' '*' expression
//     | ','.expression+ ',' '**' expression
//     | '*' expression ',' '**' expression
//     | '*' expression
//     | '**' expression
//     | ','.expression+
static asdl_expr_seq*
type_expressions_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_expr_seq* _res = NULL;
    int _mark = p->mark;
    { // ','.expression+ ',' '*' expression ',' '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.expression+ ',' '*' expression ',' '**' expression"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        Token * _literal_3;
        asdl_seq * a;
        expr_ty b;
        expr_ty c;
        if (
            (a = _gather_238_rule(p))  // ','.expression+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_1 = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (b = expression_rule(p))  // expression
            &&
            (_literal_2 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_3 = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (c = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.expression+ ',' '*' expression ',' '**' expression"));
            _res = ( asdl_expr_seq* ) _PyPegen_seq_append_to_end ( p , CHECK ( asdl_seq* , _PyPegen_seq_append_to_end ( p , a , b ) ) , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.expression+ ',' '*' expression ',' '**' expression"));
    }
    { // ','.expression+ ',' '*' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.expression+ ',' '*' expression"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        expr_ty b;
        if (
            (a = _gather_240_rule(p))  // ','.expression+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_1 = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.expression+ ',' '*' expression"));
            _res = ( asdl_expr_seq* ) _PyPegen_seq_append_to_end ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.expression+ ',' '*' expression"));
    }
    { // ','.expression+ ',' '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.expression+ ',' '**' expression"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * a;
        expr_ty b;
        if (
            (a = _gather_242_rule(p))  // ','.expression+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_1 = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.expression+ ',' '**' expression"));
            _res = ( asdl_expr_seq* ) _PyPegen_seq_append_to_end ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.expression+ ',' '**' expression"));
    }
    { // '*' expression ',' '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' expression ',' '**' expression"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        expr_ty a;
        expr_ty b;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = expression_rule(p))  // expression
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_2 = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' expression ',' '**' expression"));
            _res = ( asdl_expr_seq* ) _PyPegen_seq_append_to_end ( p , CHECK ( asdl_seq* , _PyPegen_singleton_seq ( p , a ) ) , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' expression ',' '**' expression"));
    }
    { // '*' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' expression"));
            _res = ( asdl_expr_seq* ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' expression"));
    }
    { // '**' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' expression"));
        Token * _literal;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' expression"));
            _res = ( asdl_expr_seq* ) _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' expression"));
    }
    { // ','.expression+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> type_expressions[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.expression+"));
        asdl_expr_seq* a;
        if (
            (a = (asdl_expr_seq*)_gather_244_rule(p))  // ','.expression+
        )
        {
            D(fprintf(stderr, "%*c+ type_expressions[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.expression+"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s type_expressions[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.expression+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// func_type_comment:
//     | NEWLINE TYPE_COMMENT &(NEWLINE INDENT)
//     | invalid_double_type_comments
//     | TYPE_COMMENT
static Token*
func_type_comment_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    Token* _res = NULL;
    int _mark = p->mark;
    { // NEWLINE TYPE_COMMENT &(NEWLINE INDENT)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> func_type_comment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE TYPE_COMMENT &(NEWLINE INDENT)"));
        Token * newline_var;
        Token * t;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (t = _PyPegen_expect_token(p, TYPE_COMMENT))  // token='TYPE_COMMENT'
            &&
            _PyPegen_lookahead(1, _tmp_246_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ func_type_comment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE TYPE_COMMENT &(NEWLINE INDENT)"));
            _res = t;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s func_type_comment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NEWLINE TYPE_COMMENT &(NEWLINE INDENT)"));
    }
    if (p->call_invalid_rules) { // invalid_double_type_comments
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> func_type_comment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_double_type_comments"));
        void *invalid_double_type_comments_var;
        if (
            (invalid_double_type_comments_var = invalid_double_type_comments_rule(p))  // invalid_double_type_comments
        )
        {
            D(fprintf(stderr, "%*c+ func_type_comment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_double_type_comments"));
            _res = invalid_double_type_comments_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s func_type_comment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_double_type_comments"));
    }
    { // TYPE_COMMENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> func_type_comment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "TYPE_COMMENT"));
        Token * type_comment_var;
        if (
            (type_comment_var = _PyPegen_expect_token(p, TYPE_COMMENT))  // token='TYPE_COMMENT'
        )
        {
            D(fprintf(stderr, "%*c+ func_type_comment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "TYPE_COMMENT"));
            _res = type_comment_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s func_type_comment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "TYPE_COMMENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_arguments:
//     | args ',' '*'
//     | expression for_if_clauses ',' [args | expression for_if_clauses]
//     | NAME '=' expression for_if_clauses
//     | [(args ',')] NAME '=' &(',' | ')')
//     | args for_if_clauses
//     | args ',' expression for_if_clauses
//     | args ',' args
static void *
invalid_arguments_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // args ',' '*'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args ',' '*'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        if (
            (a = args_rule(p))  // args
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_literal_1 = _PyPegen_expect_token(p, 16))  // token='*'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args ',' '*'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "iterable argument unpacking follows keyword argument unpacking" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "args ',' '*'"));
    }
    { // expression for_if_clauses ',' [args | expression for_if_clauses]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression for_if_clauses ',' [args | expression for_if_clauses]"));
        Token * _literal;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        asdl_comprehension_seq* b;
        if (
            (a = expression_rule(p))  // expression
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_opt_var = _tmp_247_rule(p), !p->error_indicator)  // [args | expression for_if_clauses]
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression for_if_clauses ',' [args | expression for_if_clauses]"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , _PyPegen_get_last_comprehension_item ( PyPegen_last_item ( b , comprehension_ty ) ) , "Generator expression must be parenthesized" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression for_if_clauses ',' [args | expression for_if_clauses]"));
    }
    { // NAME '=' expression for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' expression for_if_clauses"));
        expr_ty a;
        Token * b;
        expr_ty expression_var;
        asdl_comprehension_seq* for_if_clauses_var;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (expression_var = expression_rule(p))  // expression
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' expression for_if_clauses"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "invalid arg syntax. Maybe you meant '==' or ':=' instead of '='?" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME '=' expression for_if_clauses"));
    }
    { // [(args ',')] NAME '=' &(',' | ')')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "[(args ',')] NAME '=' &(',' | ')')"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        Token * b;
        if (
            (_opt_var = _tmp_248_rule(p), !p->error_indicator)  // [(args ',')]
            &&
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = _PyPegen_expect_token(p, 22))  // token='='
            &&
            _PyPegen_lookahead(1, _tmp_249_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "[(args ',')] NAME '=' &(',' | ')')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "expected argument value expression" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "[(args ',')] NAME '=' &(',' | ')')"));
    }
    { // args for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args for_if_clauses"));
        expr_ty a;
        asdl_comprehension_seq* b;
        if (
            (a = args_rule(p))  // args
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args for_if_clauses"));
            _res = _PyPegen_nonparen_genexp_in_call ( p , a , b );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "args for_if_clauses"));
    }
    { // args ',' expression for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args ',' expression for_if_clauses"));
        Token * _literal;
        expr_ty a;
        expr_ty args_var;
        asdl_comprehension_seq* b;
        if (
            (args_var = args_rule(p))  // args
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (a = expression_rule(p))  // expression
            &&
            (b = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args ',' expression for_if_clauses"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , _PyPegen_get_last_comprehension_item ( PyPegen_last_item ( b , comprehension_ty ) ) , "Generator expression must be parenthesized" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "args ',' expression for_if_clauses"));
    }
    { // args ',' args
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_arguments[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args ',' args"));
        Token * _literal;
        expr_ty a;
        expr_ty args_var;
        if (
            (a = args_rule(p))  // args
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (args_var = args_rule(p))  // args
        )
        {
            D(fprintf(stderr, "%*c+ invalid_arguments[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args ',' args"));
            _res = _PyPegen_arguments_parsing_error ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_arguments[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "args ',' args"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_kwarg:
//     | ('True' | 'False' | 'None') '='
//     | NAME '=' expression for_if_clauses
//     | !(NAME '=') expression '='
//     | '**' expression '=' expression
static void *
invalid_kwarg_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ('True' | 'False' | 'None') '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_kwarg[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('True' | 'False' | 'None') '='"));
        Token* a;
        Token * b;
        if (
            (a = (Token*)_tmp_250_rule(p))  // 'True' | 'False' | 'None'
            &&
            (b = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_kwarg[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('True' | 'False' | 'None') '='"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "cannot assign to %s" , PyBytes_AS_STRING ( a -> bytes ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_kwarg[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('True' | 'False' | 'None') '='"));
    }
    { // NAME '=' expression for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_kwarg[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' expression for_if_clauses"));
        expr_ty a;
        Token * b;
        expr_ty expression_var;
        asdl_comprehension_seq* for_if_clauses_var;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (b = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (expression_var = expression_rule(p))  // expression
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ invalid_kwarg[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' expression for_if_clauses"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "invalid kwarg syntax. Maybe you meant '==' or ':=' instead of '='?" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_kwarg[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME '=' expression for_if_clauses"));
    }
    { // !(NAME '=') expression '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_kwarg[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!(NAME '=') expression '='"));
        expr_ty a;
        Token * b;
        if (
            _PyPegen_lookahead(0, _tmp_251_rule, p)
            &&
            (a = expression_rule(p))  // expression
            &&
            (b = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_kwarg[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!(NAME '=') expression '='"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "expression cannot contain assignment, perhaps you meant \"==\"?" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_kwarg[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "!(NAME '=') expression '='"));
    }
    { // '**' expression '=' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_kwarg[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' expression '=' expression"));
        Token * _literal;
        Token * a;
        expr_ty b;
        expr_ty expression_var;
        if (
            (a = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (expression_var = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_kwarg[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' expression '=' expression"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "cannot assign to keyword argument unpacking" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_kwarg[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' expression '=' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// expression_without_invalid:
//     | lambdef
//     | disjunction 'if' disjunction 'else' expression
//     | disjunction
static expr_ty
expression_without_invalid_rule(Parser *p)
{
    int _prev_call_invalid = p->call_invalid_rules;
    p->call_invalid_rules = 0;
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->call_invalid_rules = _prev_call_invalid;
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->call_invalid_rules = _prev_call_invalid;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // lambdef
        if (p->error_indicator) {
            p->call_invalid_rules = _prev_call_invalid;
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression_without_invalid[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambdef"));
        expr_ty lambdef_var;
        if (
            (lambdef_var = lambdef_rule(p))  // lambdef
        )
        {
            D(fprintf(stderr, "%*c+ expression_without_invalid[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambdef"));
            _res = lambdef_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression_without_invalid[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambdef"));
    }
    { // disjunction 'if' disjunction 'else' expression
        if (p->error_indicator) {
            p->call_invalid_rules = _prev_call_invalid;
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression_without_invalid[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "disjunction 'if' disjunction 'else' expression"));
        Token * _keyword;
        Token * _keyword_1;
        expr_ty a;
        expr_ty b;
        expr_ty c;
        if (
            (a = disjunction_rule(p))  // disjunction
            &&
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (b = disjunction_rule(p))  // disjunction
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 775))  // token='else'
            &&
            (c = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ expression_without_invalid[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "disjunction 'if' disjunction 'else' expression"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->call_invalid_rules = _prev_call_invalid;
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_IfExp ( b , a , c , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->call_invalid_rules = _prev_call_invalid;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression_without_invalid[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "disjunction 'if' disjunction 'else' expression"));
    }
    { // disjunction
        if (p->error_indicator) {
            p->call_invalid_rules = _prev_call_invalid;
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> expression_without_invalid[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "disjunction"));
        expr_ty disjunction_var;
        if (
            (disjunction_var = disjunction_rule(p))  // disjunction
        )
        {
            D(fprintf(stderr, "%*c+ expression_without_invalid[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "disjunction"));
            _res = disjunction_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s expression_without_invalid[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "disjunction"));
    }
    _res = NULL;
  done:
    p->call_invalid_rules = _prev_call_invalid;
    p->level--;
    return _res;
}

// invalid_legacy_expression: NAME !'(' star_expressions
static void *
invalid_legacy_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // NAME !'(' star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_legacy_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME !'(' star_expressions"));
        expr_ty a;
        expr_ty b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 7)  // token='('
            &&
            (b = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ invalid_legacy_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME !'(' star_expressions"));
            _res = _PyPegen_check_legacy_stmt ( p , a ) ? RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "Missing parentheses in call to '%U'. Did you mean %U(...)?" , a -> v . Name . id , a -> v . Name . id ) : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_legacy_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME !'(' star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_expression:
//     | !(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid
//     | disjunction 'if' disjunction !('else' | ':')
//     | 'lambda' lambda_params? ':' &(FSTRING_MIDDLE | fstring_replacement_field)
static void *
invalid_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // !(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid"));
        expr_ty a;
        expr_ty b;
        if (
            _PyPegen_lookahead(0, _tmp_252_rule, p)
            &&
            (a = disjunction_rule(p))  // disjunction
            &&
            (b = expression_without_invalid_rule(p))  // expression_without_invalid
        )
        {
            D(fprintf(stderr, "%*c+ invalid_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid"));
            _res = _PyPegen_check_legacy_stmt ( p , a ) ? NULL : p -> tokens [p -> mark - 1] -> level == 0 ? NULL : RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "invalid syntax. Perhaps you forgot a comma?" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "!(NAME STRING | SOFT_KEYWORD) disjunction expression_without_invalid"));
    }
    { // disjunction 'if' disjunction !('else' | ':')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "disjunction 'if' disjunction !('else' | ':')"));
        Token * _keyword;
        expr_ty a;
        expr_ty b;
        if (
            (a = disjunction_rule(p))  // disjunction
            &&
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (b = disjunction_rule(p))  // disjunction
            &&
            _PyPegen_lookahead(0, _tmp_253_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "disjunction 'if' disjunction !('else' | ':')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "expected 'else' after 'if' expression" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "disjunction 'if' disjunction !('else' | ':')"));
    }
    { // 'lambda' lambda_params? ':' &(FSTRING_MIDDLE | fstring_replacement_field)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'lambda' lambda_params? ':' &(FSTRING_MIDDLE | fstring_replacement_field)"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        Token * b;
        if (
            (a = _PyPegen_expect_token(p, 713))  // token='lambda'
            &&
            (_opt_var = lambda_params_rule(p), !p->error_indicator)  // lambda_params?
            &&
            (b = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            _PyPegen_lookahead(1, _tmp_254_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'lambda' lambda_params? ':' &(FSTRING_MIDDLE | fstring_replacement_field)"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "f-string: lambda expressions are not allowed without parentheses" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'lambda' lambda_params? ':' &(FSTRING_MIDDLE | fstring_replacement_field)"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_named_expression:
//     | expression ':=' expression
//     | NAME '=' bitwise_or !('=' | ':=')
//     | !(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')
static void *
invalid_named_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    if (_PyPegen_is_memoized(p, invalid_named_expression_type, &_res)) {
        p->level--;
        return _res;
    }
    int _mark = p->mark;
    { // expression ':=' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_named_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':=' expression"));
        Token * _literal;
        expr_ty a;
        expr_ty expression_var;
        if (
            (a = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 53))  // token=':='
            &&
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_named_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':=' expression"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "cannot use assignment expressions with %s" , _PyPegen_get_expr_name ( a ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_named_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ':=' expression"));
    }
    { // NAME '=' bitwise_or !('=' | ':=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_named_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' bitwise_or !('=' | ':=')"));
        Token * _literal;
        expr_ty a;
        expr_ty b;
        if (
            (a = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (b = bitwise_or_rule(p))  // bitwise_or
            &&
            _PyPegen_lookahead(0, _tmp_255_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_named_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '=' bitwise_or !('=' | ':=')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "invalid named expression syntax. Maybe you meant '==' or ':=' instead of '='?" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_named_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME '=' bitwise_or !('=' | ':=')"));
    }
    { // !(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_named_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')"));
        expr_ty a;
        Token * b;
        expr_ty bitwise_or_var;
        if (
            _PyPegen_lookahead(0, _tmp_256_rule, p)
            &&
            (a = bitwise_or_rule(p))  // bitwise_or
            &&
            (b = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (bitwise_or_var = bitwise_or_rule(p))  // bitwise_or
            &&
            _PyPegen_lookahead(0, _tmp_257_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_named_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "cannot assign to %s here. Maybe you meant '==' instead of '='?" , _PyPegen_get_expr_name ( a ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_named_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "!(list | tuple | genexp | 'True' | 'None' | 'False') bitwise_or '=' bitwise_or !('=' | ':=')"));
    }
    _res = NULL;
  done:
    _PyPegen_insert_memo(p, _mark, invalid_named_expression_type, _res);
    p->level--;
    return _res;
}

// invalid_assignment:
//     | invalid_ann_assign_target ':' expression
//     | star_named_expression ',' star_named_expressions* ':' expression
//     | expression ':' expression
//     | ((star_targets '='))* star_expressions '='
//     | ((star_targets '='))* yield_expr '='
//     | star_expressions augassign (top_rhs | block_expr_nonewline)
static void *
invalid_assignment_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // invalid_ann_assign_target ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_ann_assign_target ':' expression"));
        Token * _literal;
        expr_ty a;
        expr_ty expression_var;
        if (
            (a = invalid_ann_assign_target_rule(p))  // invalid_ann_assign_target
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_ann_assign_target ':' expression"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "only single target (not %s) can be annotated" , _PyPegen_get_expr_name ( a ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_ann_assign_target ':' expression"));
    }
    { // star_named_expression ',' star_named_expressions* ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_named_expression ',' star_named_expressions* ':' expression"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * _loop0_258_var;
        expr_ty a;
        expr_ty expression_var;
        if (
            (a = star_named_expression_rule(p))  // star_named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_loop0_258_var = _loop0_258_rule(p))  // star_named_expressions*
            &&
            (_literal_1 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_named_expression ',' star_named_expressions* ':' expression"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "only single target (not tuple) can be annotated" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_named_expression ',' star_named_expressions* ':' expression"));
    }
    { // expression ':' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' expression"));
        Token * _literal;
        expr_ty a;
        expr_ty expression_var;
        if (
            (a = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' expression"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "illegal target for annotation" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ':' expression"));
    }
    { // ((star_targets '='))* star_expressions '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((star_targets '='))* star_expressions '='"));
        Token * _literal;
        asdl_seq * _loop0_259_var;
        expr_ty a;
        if (
            (_loop0_259_var = _loop0_259_rule(p))  // ((star_targets '='))*
            &&
            (a = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((star_targets '='))* star_expressions '='"));
            _res = RAISE_SYNTAX_ERROR_INVALID_TARGET ( STAR_TARGETS , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "((star_targets '='))* star_expressions '='"));
    }
    { // ((star_targets '='))* yield_expr '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((star_targets '='))* yield_expr '='"));
        Token * _literal;
        asdl_seq * _loop0_260_var;
        expr_ty a;
        if (
            (_loop0_260_var = _loop0_260_rule(p))  // ((star_targets '='))*
            &&
            (a = yield_expr_rule(p))  // yield_expr
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "((star_targets '='))* yield_expr '='"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "assignment to yield expression not possible" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "((star_targets '='))* yield_expr '='"));
    }
    { // star_expressions augassign (top_rhs | block_expr_nonewline)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_assignment[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expressions augassign (top_rhs | block_expr_nonewline)"));
        void *_tmp_261_var;
        expr_ty a;
        AugOperator* augassign_var;
        if (
            (a = star_expressions_rule(p))  // star_expressions
            &&
            (augassign_var = augassign_rule(p))  // augassign
            &&
            (_tmp_261_var = _tmp_261_rule(p))  // top_rhs | block_expr_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ invalid_assignment[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_expressions augassign (top_rhs | block_expr_nonewline)"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "'%s' is an illegal expression for augmented assignment" , _PyPegen_get_expr_name ( a ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_assignment[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_expressions augassign (top_rhs | block_expr_nonewline)"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_ann_assign_target: list | tuple | '(' invalid_ann_assign_target ')'
static expr_ty
invalid_ann_assign_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    expr_ty _res = NULL;
    int _mark = p->mark;
    { // list
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_ann_assign_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "list"));
        expr_ty list_var;
        if (
            (list_var = list_rule(p))  // list
        )
        {
            D(fprintf(stderr, "%*c+ invalid_ann_assign_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "list"));
            _res = list_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_ann_assign_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "list"));
    }
    { // tuple
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_ann_assign_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuple"));
        expr_ty tuple_var;
        if (
            (tuple_var = tuple_rule(p))  // tuple
        )
        {
            D(fprintf(stderr, "%*c+ invalid_ann_assign_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuple"));
            _res = tuple_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_ann_assign_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "tuple"));
    }
    { // '(' invalid_ann_assign_target ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_ann_assign_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' invalid_ann_assign_target ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = invalid_ann_assign_target_rule(p))  // invalid_ann_assign_target
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_ann_assign_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' invalid_ann_assign_target ')'"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_ann_assign_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' invalid_ann_assign_target ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_del_stmt: 'del' star_expressions
static void *
invalid_del_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'del' star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_del_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'del' star_expressions"));
        Token * _keyword;
        expr_ty a;
        if (
            (_keyword = _PyPegen_expect_token(p, 717))  // token='del'
            &&
            (a = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ invalid_del_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'del' star_expressions"));
            _res = RAISE_SYNTAX_ERROR_INVALID_TARGET ( DEL_TARGETS , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_del_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'del' star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_block: NEWLINE !INDENT
static void *
invalid_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE !INDENT"));
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_comprehension:
//     | ('[' | '(' | '{') starred_expression for_if_clauses
//     | ('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses
//     | ('[' | '{') star_named_expression ',' for_if_clauses
static void *
invalid_comprehension_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ('[' | '(' | '{') starred_expression for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_comprehension[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('[' | '(' | '{') starred_expression for_if_clauses"));
        void *_tmp_262_var;
        expr_ty a;
        asdl_comprehension_seq* for_if_clauses_var;
        if (
            (_tmp_262_var = _tmp_262_rule(p))  // '[' | '(' | '{'
            &&
            (a = starred_expression_rule(p))  // starred_expression
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ invalid_comprehension[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('[' | '(' | '{') starred_expression for_if_clauses"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "iterable unpacking cannot be used in comprehension" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_comprehension[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('[' | '(' | '{') starred_expression for_if_clauses"));
    }
    { // ('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_comprehension[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses"));
        Token * _literal;
        void *_tmp_263_var;
        expr_ty a;
        asdl_expr_seq* b;
        asdl_comprehension_seq* for_if_clauses_var;
        if (
            (_tmp_263_var = _tmp_263_rule(p))  // '[' | '{'
            &&
            (a = star_named_expression_rule(p))  // star_named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (b = star_named_expressions_rule(p))  // star_named_expressions
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ invalid_comprehension[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , PyPegen_last_item ( b , expr_ty ) , "did you forget parentheses around the comprehension target?" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_comprehension[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('[' | '{') star_named_expression ',' star_named_expressions for_if_clauses"));
    }
    { // ('[' | '{') star_named_expression ',' for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_comprehension[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('[' | '{') star_named_expression ',' for_if_clauses"));
        void *_tmp_264_var;
        expr_ty a;
        Token * b;
        asdl_comprehension_seq* for_if_clauses_var;
        if (
            (_tmp_264_var = _tmp_264_rule(p))  // '[' | '{'
            &&
            (a = star_named_expression_rule(p))  // star_named_expression
            &&
            (b = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ invalid_comprehension[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('[' | '{') star_named_expression ',' for_if_clauses"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "did you forget parentheses around the comprehension target?" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_comprehension[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('[' | '{') star_named_expression ',' for_if_clauses"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_dict_comprehension: '{' '**' bitwise_or for_if_clauses '}'
static void *
invalid_dict_comprehension_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '{' '**' bitwise_or for_if_clauses '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_dict_comprehension[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' '**' bitwise_or for_if_clauses '}'"));
        Token * _literal;
        Token * _literal_1;
        Token * a;
        expr_ty bitwise_or_var;
        asdl_comprehension_seq* for_if_clauses_var;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (bitwise_or_var = bitwise_or_rule(p))  // bitwise_or
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
            &&
            (_literal_1 = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_dict_comprehension[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' '**' bitwise_or for_if_clauses '}'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "dict unpacking cannot be used in dict comprehension" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_dict_comprehension[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' '**' bitwise_or for_if_clauses '}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_parameters:
//     | "/" ','
//     | (slash_no_default | slash_with_default) param_maybe_default* '/'
//     | slash_no_default? param_no_default* invalid_parameters_helper param_no_default
//     | param_no_default* '(' param_no_default+ ','? ')'
//     | [(slash_no_default | slash_with_default)] param_maybe_default* '*' (',' | param_no_default) param_maybe_default* '/'
//     | param_maybe_default+ '/' '*'
static void *
invalid_parameters_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // "/" ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"/\" ','"));
        Token * _literal;
        Token * a;
        if (
            (a = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ invalid_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"/\" ','"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "at least one argument must precede /" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"/\" ','"));
    }
    { // (slash_no_default | slash_with_default) param_maybe_default* '/'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(slash_no_default | slash_with_default) param_maybe_default* '/'"));
        asdl_seq * _loop0_266_var;
        void *_tmp_265_var;
        Token * a;
        if (
            (_tmp_265_var = _tmp_265_rule(p))  // slash_no_default | slash_with_default
            &&
            (_loop0_266_var = _loop0_266_rule(p))  // param_maybe_default*
            &&
            (a = _PyPegen_expect_token(p, 17))  // token='/'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(slash_no_default | slash_with_default) param_maybe_default* '/'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "/ may appear only once" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(slash_no_default | slash_with_default) param_maybe_default* '/'"));
    }
    { // slash_no_default? param_no_default* invalid_parameters_helper param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_no_default? param_no_default* invalid_parameters_helper param_no_default"));
        asdl_seq * _loop0_267_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        arg_ty a;
        void *invalid_parameters_helper_var;
        if (
            (_opt_var = slash_no_default_rule(p), !p->error_indicator)  // slash_no_default?
            &&
            (_loop0_267_var = _loop0_267_rule(p))  // param_no_default*
            &&
            (invalid_parameters_helper_var = invalid_parameters_helper_rule(p))  // invalid_parameters_helper
            &&
            (a = param_no_default_rule(p))  // param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ invalid_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_no_default? param_no_default* invalid_parameters_helper param_no_default"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "parameter without a default follows parameter with a default" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "slash_no_default? param_no_default* invalid_parameters_helper param_no_default"));
    }
    { // param_no_default* '(' param_no_default+ ','? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default* '(' param_no_default+ ','? ')'"));
        asdl_seq * _loop0_268_var;
        asdl_seq * _loop1_269_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        Token * b;
        if (
            (_loop0_268_var = _loop0_268_rule(p))  // param_no_default*
            &&
            (a = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (_loop1_269_var = _loop1_269_rule(p))  // param_no_default+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (b = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default* '(' param_no_default+ ','? ')'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "Function parameters cannot be parenthesized" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default* '(' param_no_default+ ','? ')'"));
    }
    { // [(slash_no_default | slash_with_default)] param_maybe_default* '*' (',' | param_no_default) param_maybe_default* '/'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "[(slash_no_default | slash_with_default)] param_maybe_default* '*' (',' | param_no_default) param_maybe_default* '/'"));
        Token * _literal;
        asdl_seq * _loop0_271_var;
        asdl_seq * _loop0_273_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_tmp_272_var;
        Token * a;
        if (
            (_opt_var = _tmp_270_rule(p), !p->error_indicator)  // [(slash_no_default | slash_with_default)]
            &&
            (_loop0_271_var = _loop0_271_rule(p))  // param_maybe_default*
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_272_var = _tmp_272_rule(p))  // ',' | param_no_default
            &&
            (_loop0_273_var = _loop0_273_rule(p))  // param_maybe_default*
            &&
            (a = _PyPegen_expect_token(p, 17))  // token='/'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "[(slash_no_default | slash_with_default)] param_maybe_default* '*' (',' | param_no_default) param_maybe_default* '/'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "/ must be ahead of *" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "[(slash_no_default | slash_with_default)] param_maybe_default* '*' (',' | param_no_default) param_maybe_default* '/'"));
    }
    { // param_maybe_default+ '/' '*'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_maybe_default+ '/' '*'"));
        Token * _literal;
        asdl_seq * _loop1_274_var;
        Token * a;
        if (
            (_loop1_274_var = _loop1_274_rule(p))  // param_maybe_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (a = _PyPegen_expect_token(p, 16))  // token='*'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_maybe_default+ '/' '*'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "expected comma between / and *" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_maybe_default+ '/' '*'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_default: '=' &(')' | ',')
static void *
invalid_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '=' &(')' | ',')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' &(')' | ',')"));
        Token * a;
        if (
            (a = _PyPegen_expect_token(p, 22))  // token='='
            &&
            _PyPegen_lookahead(1, _tmp_275_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' &(')' | ',')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "expected default value expression" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'=' &(')' | ',')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_sum_default: '=' &('|' | ',')
static void *
invalid_sum_default_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '=' &('|' | ',')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_sum_default[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' &('|' | ',')"));
        Token * a;
        if (
            (a = _PyPegen_expect_token(p, 22))  // token='='
            &&
            _PyPegen_lookahead(1, _tmp_276_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_sum_default[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' &('|' | ',')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "expected default value expression" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_sum_default[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'=' &('|' | ',')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_star_etc:
//     | '*' (')' | ',' (')' | '**'))
//     | '*' ',' TYPE_COMMENT
//     | '*' param '='
//     | '*' (param_no_default | ',') param_maybe_default* '*' (param_no_default | ',')
static void *
invalid_star_etc_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '*' (')' | ',' (')' | '**'))
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (')' | ',' (')' | '**'))"));
        void *_tmp_277_var;
        Token * a;
        if (
            (a = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_277_var = _tmp_277_rule(p))  // ')' | ',' (')' | '**')
        )
        {
            D(fprintf(stderr, "%*c+ invalid_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (')' | ',' (')' | '**'))"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "named arguments must follow bare *" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' (')' | ',' (')' | '**'))"));
    }
    { // '*' ',' TYPE_COMMENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' ',' TYPE_COMMENT"));
        Token * _literal;
        Token * _literal_1;
        Token * type_comment_var;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (type_comment_var = _PyPegen_expect_token(p, TYPE_COMMENT))  // token='TYPE_COMMENT'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' ',' TYPE_COMMENT"));
            _res = RAISE_SYNTAX_ERROR ( "bare * has associated type comment" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' ',' TYPE_COMMENT"));
    }
    { // '*' param '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' param '='"));
        Token * _literal;
        Token * a;
        arg_ty param_var;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (param_var = param_rule(p))  // param
            &&
            (a = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' param '='"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "var-positional argument cannot have default value" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' param '='"));
    }
    { // '*' (param_no_default | ',') param_maybe_default* '*' (param_no_default | ',')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (param_no_default | ',') param_maybe_default* '*' (param_no_default | ',')"));
        Token * _literal;
        asdl_seq * _loop0_279_var;
        void *_tmp_278_var;
        void *_tmp_280_var;
        Token * a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_278_var = _tmp_278_rule(p))  // param_no_default | ','
            &&
            (_loop0_279_var = _loop0_279_rule(p))  // param_maybe_default*
            &&
            (a = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_280_var = _tmp_280_rule(p))  // param_no_default | ','
        )
        {
            D(fprintf(stderr, "%*c+ invalid_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (param_no_default | ',') param_maybe_default* '*' (param_no_default | ',')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "* argument may appear only once" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' (param_no_default | ',') param_maybe_default* '*' (param_no_default | ',')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_kwds: '**' param '=' | '**' param ',' param | '**' param ',' ('*' | '**' | '/')
static void *
invalid_kwds_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '**' param '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' param '='"));
        Token * _literal;
        Token * a;
        arg_ty param_var;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (param_var = param_rule(p))  // param
            &&
            (a = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' param '='"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "var-keyword argument cannot have default value" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' param '='"));
    }
    { // '**' param ',' param
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' param ',' param"));
        Token * _literal;
        Token * _literal_1;
        arg_ty a;
        arg_ty param_var;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (param_var = param_rule(p))  // param
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (a = param_rule(p))  // param
        )
        {
            D(fprintf(stderr, "%*c+ invalid_kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' param ',' param"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "arguments cannot follow var-keyword argument" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' param ',' param"));
    }
    { // '**' param ',' ('*' | '**' | '/')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' param ',' ('*' | '**' | '/')"));
        Token * _literal;
        Token * _literal_1;
        Token* a;
        arg_ty param_var;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (param_var = param_rule(p))  // param
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (a = (Token*)_tmp_281_rule(p))  // '*' | '**' | '/'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' param ',' ('*' | '**' | '/')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "arguments cannot follow var-keyword argument" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' param ',' ('*' | '**' | '/')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_parameters_helper: slash_with_default | param_with_default+
static void *
invalid_parameters_helper_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // slash_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_parameters_helper[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_with_default"));
        SlashWithDefault* a;
        if (
            (a = slash_with_default_rule(p))  // slash_with_default
        )
        {
            D(fprintf(stderr, "%*c+ invalid_parameters_helper[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_with_default"));
            _res = _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_parameters_helper[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "slash_with_default"));
    }
    { // param_with_default+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_parameters_helper[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_with_default+"));
        asdl_seq * _loop1_282_var;
        if (
            (_loop1_282_var = _loop1_282_rule(p))  // param_with_default+
        )
        {
            D(fprintf(stderr, "%*c+ invalid_parameters_helper[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_with_default+"));
            _res = _loop1_282_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_parameters_helper[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_with_default+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_lambda_parameters:
//     | "/" ','
//     | (lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'
//     | lambda_slash_no_default? lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default
//     | lambda_param_no_default* '(' ','.lambda_param+ ','? ')'
//     | [(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'
//     | lambda_param_maybe_default+ '/' '*'
static void *
invalid_lambda_parameters_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // "/" ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"/\" ','"));
        Token * _literal;
        Token * a;
        if (
            (a = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"/\" ','"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "at least one argument must precede /" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"/\" ','"));
    }
    { // (lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'"));
        asdl_seq * _loop0_284_var;
        void *_tmp_283_var;
        Token * a;
        if (
            (_tmp_283_var = _tmp_283_rule(p))  // lambda_slash_no_default | lambda_slash_with_default
            &&
            (_loop0_284_var = _loop0_284_rule(p))  // lambda_param_maybe_default*
            &&
            (a = _PyPegen_expect_token(p, 17))  // token='/'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "/ may appear only once" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(lambda_slash_no_default | lambda_slash_with_default) lambda_param_maybe_default* '/'"));
    }
    { // lambda_slash_no_default? lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_no_default? lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default"));
        asdl_seq * _loop0_285_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        arg_ty a;
        void *invalid_lambda_parameters_helper_var;
        if (
            (_opt_var = lambda_slash_no_default_rule(p), !p->error_indicator)  // lambda_slash_no_default?
            &&
            (_loop0_285_var = _loop0_285_rule(p))  // lambda_param_no_default*
            &&
            (invalid_lambda_parameters_helper_var = invalid_lambda_parameters_helper_rule(p))  // invalid_lambda_parameters_helper
            &&
            (a = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_no_default? lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "parameter without a default follows parameter with a default" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_slash_no_default? lambda_param_no_default* invalid_lambda_parameters_helper lambda_param_no_default"));
    }
    { // lambda_param_no_default* '(' ','.lambda_param+ ','? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default* '(' ','.lambda_param+ ','? ')'"));
        asdl_seq * _gather_287_var;
        asdl_seq * _loop0_286_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        Token * b;
        if (
            (_loop0_286_var = _loop0_286_rule(p))  // lambda_param_no_default*
            &&
            (a = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (_gather_287_var = _gather_287_rule(p))  // ','.lambda_param+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (b = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default* '(' ','.lambda_param+ ','? ')'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "Lambda expression parameters cannot be parenthesized" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default* '(' ','.lambda_param+ ','? ')'"));
    }
    { // [(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "[(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'"));
        Token * _literal;
        asdl_seq * _loop0_290_var;
        asdl_seq * _loop0_292_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_tmp_291_var;
        Token * a;
        if (
            (_opt_var = _tmp_289_rule(p), !p->error_indicator)  // [(lambda_slash_no_default | lambda_slash_with_default)]
            &&
            (_loop0_290_var = _loop0_290_rule(p))  // lambda_param_maybe_default*
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_291_var = _tmp_291_rule(p))  // ',' | lambda_param_no_default
            &&
            (_loop0_292_var = _loop0_292_rule(p))  // lambda_param_maybe_default*
            &&
            (a = _PyPegen_expect_token(p, 17))  // token='/'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "[(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "/ must be ahead of *" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "[(lambda_slash_no_default | lambda_slash_with_default)] lambda_param_maybe_default* '*' (',' | lambda_param_no_default) lambda_param_maybe_default* '/'"));
    }
    { // lambda_param_maybe_default+ '/' '*'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default+ '/' '*'"));
        Token * _literal;
        asdl_seq * _loop1_293_var;
        Token * a;
        if (
            (_loop1_293_var = _loop1_293_rule(p))  // lambda_param_maybe_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (a = _PyPegen_expect_token(p, 16))  // token='*'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default+ '/' '*'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "expected comma between / and *" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default+ '/' '*'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_lambda_parameters_helper:
//     | lambda_slash_with_default
//     | lambda_param_with_default+
static void *
invalid_lambda_parameters_helper_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_slash_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_parameters_helper[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_with_default"));
        SlashWithDefault* a;
        if (
            (a = lambda_slash_with_default_rule(p))  // lambda_slash_with_default
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_parameters_helper[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_with_default"));
            _res = _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_parameters_helper[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_slash_with_default"));
    }
    { // lambda_param_with_default+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_parameters_helper[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_with_default+"));
        asdl_seq * _loop1_294_var;
        if (
            (_loop1_294_var = _loop1_294_rule(p))  // lambda_param_with_default+
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_parameters_helper[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_with_default+"));
            _res = _loop1_294_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_parameters_helper[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_with_default+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_lambda_star_etc:
//     | '*' (':' | ',' (':' | '**'))
//     | '*' lambda_param '='
//     | '*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')
static void *
invalid_lambda_star_etc_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '*' (':' | ',' (':' | '**'))
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (':' | ',' (':' | '**'))"));
        Token * _literal;
        void *_tmp_295_var;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_295_var = _tmp_295_rule(p))  // ':' | ',' (':' | '**')
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (':' | ',' (':' | '**'))"));
            _res = RAISE_SYNTAX_ERROR ( "named arguments must follow bare *" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' (':' | ',' (':' | '**'))"));
    }
    { // '*' lambda_param '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' lambda_param '='"));
        Token * _literal;
        Token * a;
        arg_ty lambda_param_var;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (lambda_param_var = lambda_param_rule(p))  // lambda_param
            &&
            (a = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' lambda_param '='"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "var-positional argument cannot have default value" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' lambda_param '='"));
    }
    { // '*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')"));
        Token * _literal;
        asdl_seq * _loop0_297_var;
        void *_tmp_296_var;
        void *_tmp_298_var;
        Token * a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_296_var = _tmp_296_rule(p))  // lambda_param_no_default | ','
            &&
            (_loop0_297_var = _loop0_297_rule(p))  // lambda_param_maybe_default*
            &&
            (a = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_298_var = _tmp_298_rule(p))  // lambda_param_no_default | ','
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "* argument may appear only once" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' (lambda_param_no_default | ',') lambda_param_maybe_default* '*' (lambda_param_no_default | ',')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_lambda_kwds:
//     | '**' lambda_param '='
//     | '**' lambda_param ',' lambda_param
//     | '**' lambda_param ',' ('*' | '**' | '/')
static void *
invalid_lambda_kwds_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '**' lambda_param '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' lambda_param '='"));
        Token * _literal;
        Token * a;
        arg_ty lambda_param_var;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (lambda_param_var = lambda_param_rule(p))  // lambda_param
            &&
            (a = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' lambda_param '='"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "var-keyword argument cannot have default value" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' lambda_param '='"));
    }
    { // '**' lambda_param ',' lambda_param
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' lambda_param ',' lambda_param"));
        Token * _literal;
        Token * _literal_1;
        arg_ty a;
        arg_ty lambda_param_var;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (lambda_param_var = lambda_param_rule(p))  // lambda_param
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (a = lambda_param_rule(p))  // lambda_param
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' lambda_param ',' lambda_param"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "arguments cannot follow var-keyword argument" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' lambda_param ',' lambda_param"));
    }
    { // '**' lambda_param ',' ('*' | '**' | '/')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_kwds[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' lambda_param ',' ('*' | '**' | '/')"));
        Token * _literal;
        Token * _literal_1;
        Token* a;
        arg_ty lambda_param_var;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (lambda_param_var = lambda_param_rule(p))  // lambda_param
            &&
            (_literal_1 = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (a = (Token*)_tmp_299_rule(p))  // '*' | '**' | '/'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_kwds[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**' lambda_param ',' ('*' | '**' | '/')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "arguments cannot follow var-keyword argument" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_kwds[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**' lambda_param ',' ('*' | '**' | '/')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_lambda_sum_parameters:
//     | "/" ','
//     | (lambda_sum_slash_no_default | lambda_sum_slash_with_default) lambda_sum_param_maybe_default* '/'
//     | lambda_sum_slash_no_default? lambda_sum_param_no_default* invalid_lambda_sum_parameters_helper lambda_sum_param_no_default
//     | lambda_sum_param_no_default* '(' ','.lambda_param+ ','? ')'
//     | [(lambda_sum_slash_no_default | lambda_sum_slash_with_default)] lambda_sum_param_maybe_default* '*' (',' | lambda_sum_param_no_default) lambda_sum_param_maybe_default* '/'
//     | lambda_sum_param_maybe_default+ '/' '*'
static void *
invalid_lambda_sum_parameters_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // "/" ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_sum_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"/\" ','"));
        Token * _literal;
        Token * a;
        if (
            (a = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_sum_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"/\" ','"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "at least one argument must precede /" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_sum_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"/\" ','"));
    }
    { // (lambda_sum_slash_no_default | lambda_sum_slash_with_default) lambda_sum_param_maybe_default* '/'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_sum_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(lambda_sum_slash_no_default | lambda_sum_slash_with_default) lambda_sum_param_maybe_default* '/'"));
        asdl_seq * _loop0_301_var;
        void *_tmp_300_var;
        Token * a;
        if (
            (_tmp_300_var = _tmp_300_rule(p))  // lambda_sum_slash_no_default | lambda_sum_slash_with_default
            &&
            (_loop0_301_var = _loop0_301_rule(p))  // lambda_sum_param_maybe_default*
            &&
            (a = _PyPegen_expect_token(p, 17))  // token='/'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_sum_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(lambda_sum_slash_no_default | lambda_sum_slash_with_default) lambda_sum_param_maybe_default* '/'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "/ may appear only once" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_sum_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(lambda_sum_slash_no_default | lambda_sum_slash_with_default) lambda_sum_param_maybe_default* '/'"));
    }
    { // lambda_sum_slash_no_default? lambda_sum_param_no_default* invalid_lambda_sum_parameters_helper lambda_sum_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_sum_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default? lambda_sum_param_no_default* invalid_lambda_sum_parameters_helper lambda_sum_param_no_default"));
        asdl_seq * _loop0_302_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        arg_ty a;
        void *invalid_lambda_sum_parameters_helper_var;
        if (
            (_opt_var = lambda_sum_slash_no_default_rule(p), !p->error_indicator)  // lambda_sum_slash_no_default?
            &&
            (_loop0_302_var = _loop0_302_rule(p))  // lambda_sum_param_no_default*
            &&
            (invalid_lambda_sum_parameters_helper_var = invalid_lambda_sum_parameters_helper_rule(p))  // invalid_lambda_sum_parameters_helper
            &&
            (a = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_sum_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default? lambda_sum_param_no_default* invalid_lambda_sum_parameters_helper lambda_sum_param_no_default"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "parameter without a default follows parameter with a default" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_sum_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default? lambda_sum_param_no_default* invalid_lambda_sum_parameters_helper lambda_sum_param_no_default"));
    }
    { // lambda_sum_param_no_default* '(' ','.lambda_param+ ','? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_sum_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default* '(' ','.lambda_param+ ','? ')'"));
        asdl_seq * _gather_304_var;
        asdl_seq * _loop0_303_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        Token * b;
        if (
            (_loop0_303_var = _loop0_303_rule(p))  // lambda_sum_param_no_default*
            &&
            (a = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (_gather_304_var = _gather_304_rule(p))  // ','.lambda_param+
            &&
            (_opt_var = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (b = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_sum_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default* '(' ','.lambda_param+ ','? ')'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "Lambda expression parameters cannot be parenthesized" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_sum_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default* '(' ','.lambda_param+ ','? ')'"));
    }
    { // [(lambda_sum_slash_no_default | lambda_sum_slash_with_default)] lambda_sum_param_maybe_default* '*' (',' | lambda_sum_param_no_default) lambda_sum_param_maybe_default* '/'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_sum_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "[(lambda_sum_slash_no_default | lambda_sum_slash_with_default)] lambda_sum_param_maybe_default* '*' (',' | lambda_sum_param_no_default) lambda_sum_param_maybe_default* '/'"));
        Token * _literal;
        asdl_seq * _loop0_307_var;
        asdl_seq * _loop0_309_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_tmp_308_var;
        Token * a;
        if (
            (_opt_var = _tmp_306_rule(p), !p->error_indicator)  // [(lambda_sum_slash_no_default | lambda_sum_slash_with_default)]
            &&
            (_loop0_307_var = _loop0_307_rule(p))  // lambda_sum_param_maybe_default*
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_308_var = _tmp_308_rule(p))  // ',' | lambda_sum_param_no_default
            &&
            (_loop0_309_var = _loop0_309_rule(p))  // lambda_sum_param_maybe_default*
            &&
            (a = _PyPegen_expect_token(p, 17))  // token='/'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_sum_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "[(lambda_sum_slash_no_default | lambda_sum_slash_with_default)] lambda_sum_param_maybe_default* '*' (',' | lambda_sum_param_no_default) lambda_sum_param_maybe_default* '/'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "/ must be ahead of *" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_sum_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "[(lambda_sum_slash_no_default | lambda_sum_slash_with_default)] lambda_sum_param_maybe_default* '*' (',' | lambda_sum_param_no_default) lambda_sum_param_maybe_default* '/'"));
    }
    { // lambda_sum_param_maybe_default+ '/' '*'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_sum_parameters[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default+ '/' '*'"));
        Token * _literal;
        asdl_seq * _loop1_310_var;
        Token * a;
        if (
            (_loop1_310_var = _loop1_310_rule(p))  // lambda_sum_param_maybe_default+
            &&
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
            &&
            (a = _PyPegen_expect_token(p, 16))  // token='*'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_sum_parameters[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default+ '/' '*'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "expected comma between / and *" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_sum_parameters[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default+ '/' '*'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_lambda_sum_parameters_helper:
//     | lambda_sum_slash_with_default
//     | lambda_sum_param_with_default+
static void *
invalid_lambda_sum_parameters_helper_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_sum_slash_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_sum_parameters_helper[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default"));
        SlashWithDefault* a;
        if (
            (a = lambda_sum_slash_with_default_rule(p))  // lambda_sum_slash_with_default
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_sum_parameters_helper[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default"));
            _res = _PyPegen_singleton_seq ( p , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_sum_parameters_helper[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default"));
    }
    { // lambda_sum_param_with_default+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_sum_parameters_helper[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default+"));
        asdl_seq * _loop1_311_var;
        if (
            (_loop1_311_var = _loop1_311_rule(p))  // lambda_sum_param_with_default+
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_sum_parameters_helper[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default+"));
            _res = _loop1_311_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_sum_parameters_helper[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default+"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_lambda_sum_star_etc:
//     | '*' ('|' | ',' ('|' | '**'))
//     | '*' lambda_param '='
//     | '*' (lambda_sum_param_no_default | ',') lambda_sum_param_maybe_default* '*' (lambda_sum_param_no_default | ',')
static void *
invalid_lambda_sum_star_etc_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '*' ('|' | ',' ('|' | '**'))
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_sum_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' ('|' | ',' ('|' | '**'))"));
        Token * _literal;
        void *_tmp_312_var;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_312_var = _tmp_312_rule(p))  // '|' | ',' ('|' | '**')
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_sum_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' ('|' | ',' ('|' | '**'))"));
            _res = RAISE_SYNTAX_ERROR ( "named arguments must follow bare *" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_sum_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' ('|' | ',' ('|' | '**'))"));
    }
    { // '*' lambda_param '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_sum_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' lambda_param '='"));
        Token * _literal;
        Token * a;
        arg_ty lambda_param_var;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (lambda_param_var = lambda_param_rule(p))  // lambda_param
            &&
            (a = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_sum_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' lambda_param '='"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "var-positional argument cannot have default value" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_sum_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' lambda_param '='"));
    }
    { // '*' (lambda_sum_param_no_default | ',') lambda_sum_param_maybe_default* '*' (lambda_sum_param_no_default | ',')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_lambda_sum_star_etc[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (lambda_sum_param_no_default | ',') lambda_sum_param_maybe_default* '*' (lambda_sum_param_no_default | ',')"));
        Token * _literal;
        asdl_seq * _loop0_314_var;
        void *_tmp_313_var;
        void *_tmp_315_var;
        Token * a;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_313_var = _tmp_313_rule(p))  // lambda_sum_param_no_default | ','
            &&
            (_loop0_314_var = _loop0_314_rule(p))  // lambda_sum_param_maybe_default*
            &&
            (a = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_315_var = _tmp_315_rule(p))  // lambda_sum_param_no_default | ','
        )
        {
            D(fprintf(stderr, "%*c+ invalid_lambda_sum_star_etc[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' (lambda_sum_param_no_default | ',') lambda_sum_param_maybe_default* '*' (lambda_sum_param_no_default | ',')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "* argument may appear only once" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_lambda_sum_star_etc[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' (lambda_sum_param_no_default | ',') lambda_sum_param_maybe_default* '*' (lambda_sum_param_no_default | ',')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_double_type_comments: TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
static void *
invalid_double_type_comments_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_double_type_comments[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT"));
        Token * indent_var;
        Token * newline_var;
        Token * newline_var_1;
        Token * type_comment_var;
        Token * type_comment_var_1;
        if (
            (type_comment_var = _PyPegen_expect_token(p, TYPE_COMMENT))  // token='TYPE_COMMENT'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (type_comment_var_1 = _PyPegen_expect_token(p, TYPE_COMMENT))  // token='TYPE_COMMENT'
            &&
            (newline_var_1 = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (indent_var = _PyPegen_expect_token(p, INDENT))  // token='INDENT'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_double_type_comments[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT"));
            _res = RAISE_SYNTAX_ERROR ( "Cannot have two type comments on def" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_double_type_comments[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "TYPE_COMMENT NEWLINE TYPE_COMMENT NEWLINE INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_with_item: expression 'as' expression &(',' | ')' | ':')
static void *
invalid_with_item_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // expression 'as' expression &(',' | ')' | ':')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_with_item[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression 'as' expression &(',' | ')' | ':')"));
        Token * _keyword;
        expr_ty a;
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (a = expression_rule(p))  // expression
            &&
            _PyPegen_lookahead(1, _tmp_316_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_with_item[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression 'as' expression &(',' | ')' | ':')"));
            _res = RAISE_SYNTAX_ERROR_INVALID_TARGET ( STAR_TARGETS , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_with_item[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression 'as' expression &(',' | ')' | ':')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_for_target: 'async'? 'for' star_expressions
static void *
invalid_for_target_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'async'? 'for' star_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_for_target[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'for' star_expressions"));
        Token * _keyword;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        if (
            (_opt_var = _PyPegen_expect_token(p, 784), !p->error_indicator)  // 'async'?
            &&
            (_keyword = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (a = star_expressions_rule(p))  // star_expressions
        )
        {
            D(fprintf(stderr, "%*c+ invalid_for_target[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'for' star_expressions"));
            _res = RAISE_SYNTAX_ERROR_INVALID_TARGET ( FOR_TARGETS , a );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_for_target[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'? 'for' star_expressions"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_group: '(' starred_expression ')' | '(' '**' expression ')'
static void *
invalid_group_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '(' starred_expression ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_group[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' starred_expression ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty a;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = starred_expression_rule(p))  // starred_expression
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_group[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' starred_expression ')'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "cannot use starred expression here" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_group[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' starred_expression ')'"));
    }
    { // '(' '**' expression ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_group[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' '**' expression ')'"));
        Token * _literal;
        Token * _literal_1;
        Token * a;
        expr_ty expression_var;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = _PyPegen_expect_token(p, 35))  // token='**'
            &&
            (expression_var = expression_rule(p))  // expression
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_group[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' '**' expression ')'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "cannot use double starred expression here" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_group[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' '**' expression ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_import: 'import' ','.dotted_name+ 'from' dotted_name
static void *
invalid_import_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'import' ','.dotted_name+ 'from' dotted_name
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_import[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'import' ','.dotted_name+ 'from' dotted_name"));
        asdl_seq * _gather_317_var;
        Token * _keyword;
        Token * a;
        expr_ty dotted_name_var;
        if (
            (a = _PyPegen_expect_token(p, 721))  // token='import'
            &&
            (_gather_317_var = _gather_317_rule(p))  // ','.dotted_name+
            &&
            (_keyword = _PyPegen_expect_token(p, 722))  // token='from'
            &&
            (dotted_name_var = dotted_name_rule(p))  // dotted_name
        )
        {
            D(fprintf(stderr, "%*c+ invalid_import[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'import' ','.dotted_name+ 'from' dotted_name"));
            _res = RAISE_SYNTAX_ERROR_STARTING_FROM ( a , "Did you mean to use 'from ... import ...' instead?" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_import[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'import' ','.dotted_name+ 'from' dotted_name"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_import_from_targets: import_from_as_names ',' NEWLINE
static void *
invalid_import_from_targets_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // import_from_as_names ',' NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_import_from_targets[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "import_from_as_names ',' NEWLINE"));
        Token * _literal;
        asdl_alias_seq* import_from_as_names_var;
        Token * newline_var;
        if (
            (import_from_as_names_var = import_from_as_names_rule(p))  // import_from_as_names
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_import_from_targets[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "import_from_as_names ',' NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "trailing comma not allowed without surrounding parentheses" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_import_from_targets[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "import_from_as_names ',' NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_with_stmt:
//     | 'async'? 'with' ','.(expression ['as' star_target])+ NEWLINE
//     | 'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' NEWLINE
static void *
invalid_with_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'async'? 'with' ','.(expression ['as' star_target])+ NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_with_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'with' ','.(expression ['as' star_target])+ NEWLINE"));
        asdl_seq * _gather_319_var;
        Token * _keyword;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * newline_var;
        if (
            (_opt_var = _PyPegen_expect_token(p, 784), !p->error_indicator)  // 'async'?
            &&
            (_keyword = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (_gather_319_var = _gather_319_rule(p))  // ','.(expression ['as' star_target])+
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_with_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'with' ','.(expression ['as' star_target])+ NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "expected ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_with_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'? 'with' ','.(expression ['as' star_target])+ NEWLINE"));
    }
    { // 'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_with_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' NEWLINE"));
        asdl_seq * _gather_321_var;
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_opt_var_1;
        UNUSED(_opt_var_1); // Silence compiler warnings
        Token * newline_var;
        if (
            (_opt_var = _PyPegen_expect_token(p, 784), !p->error_indicator)  // 'async'?
            &&
            (_keyword = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (_gather_321_var = _gather_321_rule(p))  // ','.(expressions ['as' star_target])+
            &&
            (_opt_var_1 = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_with_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "expected ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_with_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_with_stmt_indent:
//     | 'async'? 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT
//     | 'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT
static void *
invalid_with_stmt_indent_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'async'? 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_with_stmt_indent[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT"));
        asdl_seq * _gather_323_var;
        Token * _literal;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        Token * newline_var;
        if (
            (_opt_var = _PyPegen_expect_token(p, 784), !p->error_indicator)  // 'async'?
            &&
            (a = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (_gather_323_var = _gather_323_rule(p))  // ','.(expression ['as' star_target])+
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_with_stmt_indent[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'with' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_with_stmt_indent[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'? 'with' ','.(expression ['as' star_target])+ ':' NEWLINE !INDENT"));
    }
    { // 'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_with_stmt_indent[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT"));
        asdl_seq * _gather_325_var;
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_opt_var_1;
        UNUSED(_opt_var_1); // Silence compiler warnings
        Token * a;
        Token * newline_var;
        if (
            (_opt_var = _PyPegen_expect_token(p, 784), !p->error_indicator)  // 'async'?
            &&
            (a = _PyPegen_expect_token(p, 733))  // token='with'
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (_gather_325_var = _gather_325_rule(p))  // ','.(expressions ['as' star_target])+
            &&
            (_opt_var_1 = _PyPegen_expect_token(p, 12), !p->error_indicator)  // ','?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (_literal_2 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_with_stmt_indent[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'with' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_with_stmt_indent[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'? 'with' '(' ','.(expressions ['as' star_target])+ ','? ')' ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_try_stmt:
//     | 'try' ':' NEWLINE !INDENT
//     | 'try' ':' block !('except' | 'finally')
//     | 'try' ':' block* except_block+ 'except' '*' expression ['as' NAME] ':'
//     | 'try' ':' block* except_star_block+ 'except' [expression ['as' NAME]] ':'
static void *
invalid_try_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'try' ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_try_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' NEWLINE !INDENT"));
        Token * _literal;
        Token * a;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_try_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'try' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_try_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' ':' NEWLINE !INDENT"));
    }
    { // 'try' ':' block !('except' | 'finally')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_try_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block !('except' | 'finally')"));
        Token * _keyword;
        Token * _literal;
        asdl_stmt_seq* block_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (block_var = block_rule(p))  // block
            &&
            _PyPegen_lookahead(0, _tmp_327_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_try_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block !('except' | 'finally')"));
            _res = RAISE_SYNTAX_ERROR ( "expected 'except' or 'finally' block" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_try_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' ':' block !('except' | 'finally')"));
    }
    { // 'try' ':' block* except_block+ 'except' '*' expression ['as' NAME] ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_try_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block* except_block+ 'except' '*' expression ['as' NAME] ':'"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        asdl_seq * _loop0_328_var;
        asdl_seq * _loop1_329_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        Token * b;
        expr_ty expression_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (_loop0_328_var = _loop0_328_rule(p))  // block*
            &&
            (_loop1_329_var = _loop1_329_rule(p))  // except_block+
            &&
            (a = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (b = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (expression_var = expression_rule(p))  // expression
            &&
            (_opt_var = _tmp_330_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (_literal_1 = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_try_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block* except_block+ 'except' '*' expression ['as' NAME] ':'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "cannot have both 'except' and 'except*' on the same 'try'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_try_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' ':' block* except_block+ 'except' '*' expression ['as' NAME] ':'"));
    }
    { // 'try' ':' block* except_star_block+ 'except' [expression ['as' NAME]] ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_try_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block* except_star_block+ 'except' [expression ['as' NAME]] ':'"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        asdl_seq * _loop0_331_var;
        asdl_seq * _loop1_332_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (_loop0_331_var = _loop0_331_rule(p))  // block*
            &&
            (_loop1_332_var = _loop1_332_rule(p))  // except_star_block+
            &&
            (a = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (_opt_var = _tmp_333_rule(p), !p->error_indicator)  // [expression ['as' NAME]]
            &&
            (_literal_1 = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_try_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block* except_star_block+ 'except' [expression ['as' NAME]] ':'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "cannot have both 'except' and 'except*' on the same 'try'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_try_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' ':' block* except_star_block+ 'except' [expression ['as' NAME]] ':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_try_stmt_nonewline:
//     | 'try' ':' block_nonewline !('except' | 'finally')
//     | 'try' ':' block_nonewline* except_block_nonewline+ 'except' '*' expression ['as' NAME] ':'
//     | 'try' ':' block_nonewline* except_star_block_nonewline+ 'except' [expression ['as' NAME]] ':'
static void *
invalid_try_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'try' ':' block_nonewline !('except' | 'finally')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_try_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block_nonewline !('except' | 'finally')"));
        Token * _keyword;
        Token * _literal;
        asdl_stmt_seq* block_nonewline_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (block_nonewline_var = block_nonewline_rule(p))  // block_nonewline
            &&
            _PyPegen_lookahead(0, _tmp_334_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_try_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block_nonewline !('except' | 'finally')"));
            _res = RAISE_SYNTAX_ERROR ( "expected 'except' or 'finally' block" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_try_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' ':' block_nonewline !('except' | 'finally')"));
    }
    { // 'try' ':' block_nonewline* except_block_nonewline+ 'except' '*' expression ['as' NAME] ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_try_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block_nonewline* except_block_nonewline+ 'except' '*' expression ['as' NAME] ':'"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        asdl_seq * _loop0_335_var;
        asdl_seq * _loop1_336_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        Token * b;
        expr_ty expression_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (_loop0_335_var = _loop0_335_rule(p))  // block_nonewline*
            &&
            (_loop1_336_var = _loop1_336_rule(p))  // except_block_nonewline+
            &&
            (a = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (b = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (expression_var = expression_rule(p))  // expression
            &&
            (_opt_var = _tmp_337_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (_literal_1 = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_try_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block_nonewline* except_block_nonewline+ 'except' '*' expression ['as' NAME] ':'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "cannot have both 'except' and 'except*' on the same 'try'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_try_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' ':' block_nonewline* except_block_nonewline+ 'except' '*' expression ['as' NAME] ':'"));
    }
    { // 'try' ':' block_nonewline* except_star_block_nonewline+ 'except' [expression ['as' NAME]] ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_try_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block_nonewline* except_star_block_nonewline+ 'except' [expression ['as' NAME]] ':'"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        asdl_seq * _loop0_338_var;
        asdl_seq * _loop1_339_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (_loop0_338_var = _loop0_338_rule(p))  // block_nonewline*
            &&
            (_loop1_339_var = _loop1_339_rule(p))  // except_star_block_nonewline+
            &&
            (a = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (_opt_var = _tmp_340_rule(p), !p->error_indicator)  // [expression ['as' NAME]]
            &&
            (_literal_1 = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_try_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try' ':' block_nonewline* except_star_block_nonewline+ 'except' [expression ['as' NAME]] ':'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "cannot have both 'except' and 'except*' on the same 'try'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_try_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try' ':' block_nonewline* except_star_block_nonewline+ 'except' [expression ['as' NAME]] ':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_except_stmt:
//     | 'except' '*'? expression ',' expressions ['as' NAME] ':'
//     | 'except' '*'? expression ['as' NAME] NEWLINE
//     | 'except' NEWLINE
//     | 'except' '*' (NEWLINE | ':')
static void *
invalid_except_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'except' '*'? expression ',' expressions ['as' NAME] ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_except_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*'? expression ',' expressions ['as' NAME] ':'"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_opt_var_1;
        UNUSED(_opt_var_1); // Silence compiler warnings
        expr_ty a;
        expr_ty expressions_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (_opt_var = _PyPegen_expect_token(p, 16), !p->error_indicator)  // '*'?
            &&
            (a = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (expressions_var = expressions_rule(p))  // expressions
            &&
            (_opt_var_1 = _tmp_341_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (_literal_1 = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_except_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*'? expression ',' expressions ['as' NAME] ':'"));
            _res = RAISE_SYNTAX_ERROR_STARTING_FROM ( a , "multiple exception types must be parenthesized" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_except_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' '*'? expression ',' expressions ['as' NAME] ':'"));
    }
    { // 'except' '*'? expression ['as' NAME] NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_except_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*'? expression ['as' NAME] NEWLINE"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_opt_var_1;
        UNUSED(_opt_var_1); // Silence compiler warnings
        Token * a;
        expr_ty expression_var;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (_opt_var = _PyPegen_expect_token(p, 16), !p->error_indicator)  // '*'?
            &&
            (expression_var = expression_rule(p))  // expression
            &&
            (_opt_var_1 = _tmp_342_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_except_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*'? expression ['as' NAME] NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "expected ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_except_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' '*'? expression ['as' NAME] NEWLINE"));
    }
    { // 'except' NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_except_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' NEWLINE"));
        Token * a;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_except_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "expected ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_except_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' NEWLINE"));
    }
    { // 'except' '*' (NEWLINE | ':')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_except_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*' (NEWLINE | ':')"));
        Token * _literal;
        void *_tmp_343_var;
        Token * a;
        if (
            (a = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_tmp_343_var = _tmp_343_rule(p))  // NEWLINE | ':'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_except_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*' (NEWLINE | ':')"));
            _res = RAISE_SYNTAX_ERROR ( "expected one or more exception types" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_except_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' '*' (NEWLINE | ':')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_except_stmt_nonewline:
//     | 'except' '*'? expression ',' expressions ['as' NAME] ':'
//     | 'except' '*' ':'
static void *
invalid_except_stmt_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'except' '*'? expression ',' expressions ['as' NAME] ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_except_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*'? expression ',' expressions ['as' NAME] ':'"));
        Token * _keyword;
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_opt_var_1;
        UNUSED(_opt_var_1); // Silence compiler warnings
        expr_ty a;
        expr_ty expressions_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (_opt_var = _PyPegen_expect_token(p, 16), !p->error_indicator)  // '*'?
            &&
            (a = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (expressions_var = expressions_rule(p))  // expressions
            &&
            (_opt_var_1 = _tmp_344_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (_literal_1 = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_except_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*'? expression ',' expressions ['as' NAME] ':'"));
            _res = RAISE_SYNTAX_ERROR_STARTING_FROM ( a , "multiple exception types must be parenthesized" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_except_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' '*'? expression ',' expressions ['as' NAME] ':'"));
    }
    { // 'except' '*' ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_except_stmt_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*' ':'"));
        Token * _literal;
        Token * _literal_1;
        Token * a;
        if (
            (a = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_except_stmt_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*' ':'"));
            _res = RAISE_SYNTAX_ERROR ( "expected one or more exception types" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_except_stmt_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' '*' ':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_finally_stmt: 'finally' ':' NEWLINE !INDENT
static void *
invalid_finally_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'finally' ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_finally_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally' ':' NEWLINE !INDENT"));
        Token * _literal;
        Token * a;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 763))  // token='finally'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_finally_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally' ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'finally' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_finally_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'finally' ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_except_stmt_indent:
//     | 'except' expression ['as' NAME] ':' NEWLINE !INDENT
//     | 'except' ':' NEWLINE !INDENT
static void *
invalid_except_stmt_indent_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'except' expression ['as' NAME] ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_except_stmt_indent[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' expression ['as' NAME] ':' NEWLINE !INDENT"));
        Token * _literal;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        expr_ty expression_var;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (expression_var = expression_rule(p))  // expression
            &&
            (_opt_var = _tmp_345_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_except_stmt_indent[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' expression ['as' NAME] ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'except' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_except_stmt_indent[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' expression ['as' NAME] ':' NEWLINE !INDENT"));
    }
    { // 'except' ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_except_stmt_indent[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' ':' NEWLINE !INDENT"));
        Token * _literal;
        Token * a;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_except_stmt_indent[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'except' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_except_stmt_indent[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_except_star_stmt_indent:
//     | 'except' '*' expression ['as' NAME] ':' NEWLINE !INDENT
static void *
invalid_except_star_stmt_indent_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'except' '*' expression ['as' NAME] ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_except_star_stmt_indent[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*' expression ['as' NAME] ':' NEWLINE !INDENT"));
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        expr_ty expression_var;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 767))  // token='except'
            &&
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (expression_var = expression_rule(p))  // expression
            &&
            (_opt_var = _tmp_346_rule(p), !p->error_indicator)  // ['as' NAME]
            &&
            (_literal_1 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_except_star_stmt_indent[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except' '*' expression ['as' NAME] ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'except*' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_except_star_stmt_indent[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except' '*' expression ['as' NAME] ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_match_stmt:
//     | "match" subject_expr NEWLINE
//     | "match" subject_expr ':' NEWLINE !INDENT
static void *
invalid_match_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // "match" subject_expr NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_match_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr NEWLINE"));
        expr_ty _keyword;
        Token * newline_var;
        expr_ty subject_expr_var;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "match"))  // soft_keyword='"match"'
            &&
            (subject_expr_var = subject_expr_rule(p))  // subject_expr
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_match_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr NEWLINE"));
            _res = CHECK_VERSION ( void* , 10 , "Pattern matching is" , RAISE_SYNTAX_ERROR ( "expected ':'" ) );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_match_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"match\" subject_expr NEWLINE"));
    }
    { // "match" subject_expr ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_match_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE !INDENT"));
        Token * _literal;
        expr_ty a;
        Token * newline_var;
        expr_ty subject;
        if (
            (a = _PyPegen_expect_soft_keyword(p, "match"))  // soft_keyword='"match"'
            &&
            (subject = subject_expr_rule(p))  // subject_expr
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_match_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'match' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_match_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"match\" subject_expr ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_case_block:
//     | "case" patterns guard? NEWLINE
//     | "case" patterns guard? ':' NEWLINE !INDENT
static void *
invalid_case_block_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // "case" patterns guard? NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_case_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? NEWLINE"));
        expr_ty _keyword;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * newline_var;
        pattern_ty patterns_var;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "case"))  // soft_keyword='"case"'
            &&
            (patterns_var = patterns_rule(p))  // patterns
            &&
            (_opt_var = guard_rule(p), !p->error_indicator)  // guard?
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_case_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "expected ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_case_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? NEWLINE"));
    }
    { // "case" patterns guard? ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_case_block[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? ':' NEWLINE !INDENT"));
        Token * _literal;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty a;
        Token * newline_var;
        pattern_ty patterns_var;
        if (
            (a = _PyPegen_expect_soft_keyword(p, "case"))  // soft_keyword='"case"'
            &&
            (patterns_var = patterns_rule(p))  // patterns
            &&
            (_opt_var = guard_rule(p), !p->error_indicator)  // guard?
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_case_block[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'case' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_case_block[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"case\" patterns guard? ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_as_pattern: or_pattern 'as' "_" | or_pattern 'as' !NAME expression
static void *
invalid_as_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // or_pattern 'as' "_"
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_as_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "or_pattern 'as' \"_\""));
        Token * _keyword;
        expr_ty a;
        pattern_ty or_pattern_var;
        if (
            (or_pattern_var = or_pattern_rule(p))  // or_pattern
            &&
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (a = _PyPegen_expect_soft_keyword(p, "_"))  // soft_keyword='"_"'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_as_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "or_pattern 'as' \"_\""));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "cannot use '_' as a target" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_as_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "or_pattern 'as' \"_\""));
    }
    { // or_pattern 'as' !NAME expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_as_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "or_pattern 'as' !NAME expression"));
        Token * _keyword;
        expr_ty a;
        pattern_ty or_pattern_var;
        if (
            (or_pattern_var = or_pattern_rule(p))  // or_pattern
            &&
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            _PyPegen_lookahead_with_name(0, _PyPegen_name_token, p)
            &&
            (a = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_as_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "or_pattern 'as' !NAME expression"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "invalid pattern target" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_as_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "or_pattern 'as' !NAME expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_class_pattern: name_or_attr '(' invalid_class_argument_pattern
static void *
invalid_class_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // name_or_attr '(' invalid_class_argument_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_class_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '(' invalid_class_argument_pattern"));
        Token * _literal;
        asdl_pattern_seq* a;
        expr_ty name_or_attr_var;
        if (
            (name_or_attr_var = name_or_attr_rule(p))  // name_or_attr
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (a = invalid_class_argument_pattern_rule(p))  // invalid_class_argument_pattern
        )
        {
            D(fprintf(stderr, "%*c+ invalid_class_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "name_or_attr '(' invalid_class_argument_pattern"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( PyPegen_first_item ( a , pattern_ty ) , PyPegen_last_item ( a , pattern_ty ) , "positional patterns follow keyword patterns" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_class_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "name_or_attr '(' invalid_class_argument_pattern"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_class_argument_pattern:
//     | [positional_patterns ','] keyword_patterns ',' positional_patterns
static asdl_pattern_seq*
invalid_class_argument_pattern_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_pattern_seq* _res = NULL;
    int _mark = p->mark;
    { // [positional_patterns ','] keyword_patterns ',' positional_patterns
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_class_argument_pattern[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "[positional_patterns ','] keyword_patterns ',' positional_patterns"));
        Token * _literal;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_pattern_seq* a;
        asdl_seq* keyword_patterns_var;
        if (
            (_opt_var = _tmp_347_rule(p), !p->error_indicator)  // [positional_patterns ',']
            &&
            (keyword_patterns_var = keyword_patterns_rule(p))  // keyword_patterns
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (a = positional_patterns_rule(p))  // positional_patterns
        )
        {
            D(fprintf(stderr, "%*c+ invalid_class_argument_pattern[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "[positional_patterns ','] keyword_patterns ',' positional_patterns"));
            _res = a;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_class_argument_pattern[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "[positional_patterns ','] keyword_patterns ',' positional_patterns"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_if_stmt:
//     | 'if' named_expression NEWLINE
//     | 'if' named_expression ':' NEWLINE !INDENT
static void *
invalid_if_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'if' named_expression NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_if_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression NEWLINE"));
        Token * _keyword;
        expr_ty named_expression_var;
        Token * newline_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (named_expression_var = named_expression_rule(p))  // named_expression
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_if_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "expected ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_if_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'if' named_expression NEWLINE"));
    }
    { // 'if' named_expression ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_if_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression ':' NEWLINE !INDENT"));
        Token * _literal;
        Token * a;
        expr_ty a_1;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (a_1 = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_if_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' named_expression ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'if' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_if_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'if' named_expression ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_elif_stmt:
//     | 'elif' named_expression NEWLINE
//     | 'elif' named_expression ':' NEWLINE !INDENT
static void *
invalid_elif_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'elif' named_expression NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_elif_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression NEWLINE"));
        Token * _keyword;
        expr_ty named_expression_var;
        Token * newline_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 774))  // token='elif'
            &&
            (named_expression_var = named_expression_rule(p))  // named_expression
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_elif_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "expected ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_elif_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'elif' named_expression NEWLINE"));
    }
    { // 'elif' named_expression ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_elif_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression ':' NEWLINE !INDENT"));
        Token * _literal;
        Token * a;
        expr_ty named_expression_var;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 774))  // token='elif'
            &&
            (named_expression_var = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_elif_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif' named_expression ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'elif' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_elif_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'elif' named_expression ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_else_stmt: 'else' ':' NEWLINE !INDENT
static void *
invalid_else_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'else' ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_else_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'else' ':' NEWLINE !INDENT"));
        Token * _literal;
        Token * a;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 775))  // token='else'
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_else_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'else' ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'else' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_else_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'else' ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_while_stmt:
//     | 'while' named_expression NEWLINE
//     | 'while' named_expression ':' NEWLINE !INDENT
static void *
invalid_while_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'while' named_expression NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_while_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'while' named_expression NEWLINE"));
        Token * _keyword;
        expr_ty named_expression_var;
        Token * newline_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 777))  // token='while'
            &&
            (named_expression_var = named_expression_rule(p))  // named_expression
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_while_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'while' named_expression NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "expected ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_while_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'while' named_expression NEWLINE"));
    }
    { // 'while' named_expression ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_while_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'while' named_expression ':' NEWLINE !INDENT"));
        Token * _literal;
        Token * a;
        expr_ty named_expression_var;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 777))  // token='while'
            &&
            (named_expression_var = named_expression_rule(p))  // named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_while_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'while' named_expression ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'while' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_while_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'while' named_expression ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_for_stmt:
//     | 'async'? 'for' star_targets 'in' star_expressions NEWLINE
//     | 'async'? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT
static void *
invalid_for_stmt_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'async'? 'for' star_targets 'in' star_expressions NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_for_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'for' star_targets 'in' star_expressions NEWLINE"));
        Token * _keyword;
        Token * _keyword_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * newline_var;
        expr_ty star_expressions_var;
        expr_ty star_targets_var;
        if (
            (_opt_var = _PyPegen_expect_token(p, 784), !p->error_indicator)  // 'async'?
            &&
            (_keyword = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (star_targets_var = star_targets_rule(p))  // star_targets
            &&
            (_keyword_1 = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (star_expressions_var = star_expressions_rule(p))  // star_expressions
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_for_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'for' star_targets 'in' star_expressions NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "expected ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_for_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'? 'for' star_targets 'in' star_expressions NEWLINE"));
    }
    { // 'async'? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_for_stmt[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT"));
        Token * _keyword;
        Token * _literal;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        Token * newline_var;
        expr_ty star_expressions_var;
        expr_ty star_targets_var;
        if (
            (_opt_var = _PyPegen_expect_token(p, 784), !p->error_indicator)  // 'async'?
            &&
            (a = _PyPegen_expect_token(p, 782))  // token='for'
            &&
            (star_targets_var = star_targets_rule(p))  // star_targets
            &&
            (_keyword = _PyPegen_expect_token(p, 783))  // token='in'
            &&
            (star_expressions_var = star_expressions_rule(p))  // star_expressions
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_for_stmt[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after 'for' statement on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_for_stmt[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'? 'for' star_targets 'in' star_expressions ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_def_raw:
//     | 'async'? "def" NAME '(' params? ')' ['->' expression] ':' NEWLINE !INDENT
static void *
invalid_def_raw_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'async'? "def" NAME '(' params? ')' ['->' expression] ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_def_raw[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? \"def\" NAME '(' params? ')' ['->' expression] ':' NEWLINE !INDENT"));
        Token * _literal;
        Token * _literal_1;
        Token * _literal_2;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_opt_var_1;
        UNUSED(_opt_var_1); // Silence compiler warnings
        void *_opt_var_2;
        UNUSED(_opt_var_2); // Silence compiler warnings
        expr_ty a;
        expr_ty name_var;
        Token * newline_var;
        if (
            (_opt_var = _PyPegen_expect_token(p, 784), !p->error_indicator)  // 'async'?
            &&
            (a = _PyPegen_expect_soft_keyword(p, "def"))  // soft_keyword='"def"'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (_opt_var_1 = params_rule(p), !p->error_indicator)  // params?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
            &&
            (_opt_var_2 = _tmp_348_rule(p), !p->error_indicator)  // ['->' expression]
            &&
            (_literal_2 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_def_raw[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'? \"def\" NAME '(' params? ')' ['->' expression] ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after function definition on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_def_raw[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'? \"def\" NAME '(' params? ')' ['->' expression] ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_class_def_raw_nonewline: 'class' NAME ['(' arguments? ')'] NEWLINE
static void *
invalid_class_def_raw_nonewline_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'class' NAME ['(' arguments? ')'] NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_class_def_raw_nonewline[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class' NAME ['(' arguments? ')'] NEWLINE"));
        Token * _keyword;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty name_var;
        Token * newline_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 786))  // token='class'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
            &&
            (_opt_var = _tmp_349_rule(p), !p->error_indicator)  // ['(' arguments? ')']
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_class_def_raw_nonewline[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class' NAME ['(' arguments? ')'] NEWLINE"));
            _res = RAISE_SYNTAX_ERROR ( "expected ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_class_def_raw_nonewline[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'class' NAME ['(' arguments? ')'] NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_class_def_raw:
//     | invalid_class_def_raw_nonewline
//     | 'class' NAME ['(' arguments? ')'] ':' NEWLINE !INDENT
static void *
invalid_class_def_raw_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    if (p->call_invalid_rules) { // invalid_class_def_raw_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_class_def_raw[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_class_def_raw_nonewline"));
        void *invalid_class_def_raw_nonewline_var;
        if (
            (invalid_class_def_raw_nonewline_var = invalid_class_def_raw_nonewline_rule(p))  // invalid_class_def_raw_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ invalid_class_def_raw[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "invalid_class_def_raw_nonewline"));
            _res = invalid_class_def_raw_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_class_def_raw[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "invalid_class_def_raw_nonewline"));
    }
    { // 'class' NAME ['(' arguments? ')'] ':' NEWLINE !INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_class_def_raw[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class' NAME ['(' arguments? ')'] ':' NEWLINE !INDENT"));
        Token * _literal;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        Token * a;
        expr_ty name_var;
        Token * newline_var;
        if (
            (a = _PyPegen_expect_token(p, 786))  // token='class'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
            &&
            (_opt_var = _tmp_350_rule(p), !p->error_indicator)  // ['(' arguments? ')']
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, INDENT)  // token=INDENT
        )
        {
            D(fprintf(stderr, "%*c+ invalid_class_def_raw[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class' NAME ['(' arguments? ')'] ':' NEWLINE !INDENT"));
            _res = RAISE_INDENTATION_ERROR ( "expected an indented block after class definition on line %d" , a -> lineno );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_class_def_raw[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'class' NAME ['(' arguments? ')'] ':' NEWLINE !INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_double_starred_kvpairs:
//     | ','.double_starred_kvpair+ ',' invalid_kvpair
//     | expression ':' '*' bitwise_or
//     | expression ':' &('}' | ',')
static void *
invalid_double_starred_kvpairs_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ','.double_starred_kvpair+ ',' invalid_kvpair
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_double_starred_kvpairs[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.double_starred_kvpair+ ',' invalid_kvpair"));
        asdl_seq * _gather_351_var;
        Token * _literal;
        void *invalid_kvpair_var;
        if (
            (_gather_351_var = _gather_351_rule(p))  // ','.double_starred_kvpair+
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (invalid_kvpair_var = invalid_kvpair_rule(p))  // invalid_kvpair
        )
        {
            D(fprintf(stderr, "%*c+ invalid_double_starred_kvpairs[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','.double_starred_kvpair+ ',' invalid_kvpair"));
            _res = _PyPegen_dummy_name(p, _gather_351_var, _literal, invalid_kvpair_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_double_starred_kvpairs[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','.double_starred_kvpair+ ',' invalid_kvpair"));
    }
    { // expression ':' '*' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_double_starred_kvpairs[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' '*' bitwise_or"));
        Token * _literal;
        Token * a;
        expr_ty bitwise_or_var;
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (a = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (bitwise_or_var = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ invalid_double_starred_kvpairs[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' '*' bitwise_or"));
            _res = RAISE_SYNTAX_ERROR_STARTING_FROM ( a , "cannot use a starred expression in a dictionary value" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_double_starred_kvpairs[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ':' '*' bitwise_or"));
    }
    { // expression ':' &('}' | ',')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_double_starred_kvpairs[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' &('}' | ',')"));
        Token * a;
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (a = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            _PyPegen_lookahead(1, _tmp_353_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_double_starred_kvpairs[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' &('}' | ',')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "expression expected after dictionary key and ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_double_starred_kvpairs[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ':' &('}' | ',')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_kvpair:
//     | expression !(':')
//     | expression ':' '*' bitwise_or
//     | expression ':' &('}' | ',')
static void *
invalid_kvpair_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // expression !(':')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_kvpair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression !(':')"));
        expr_ty a;
        if (
            (a = expression_rule(p))  // expression
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 11)  // token=(':')
        )
        {
            D(fprintf(stderr, "%*c+ invalid_kvpair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression !(':')"));
            _res = RAISE_ERROR_KNOWN_LOCATION ( p , PyExc_SyntaxError , a -> lineno , a -> end_col_offset - 1 , a -> end_lineno , - 1 , "':' expected after dictionary key" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_kvpair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression !(':')"));
    }
    { // expression ':' '*' bitwise_or
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_kvpair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' '*' bitwise_or"));
        Token * _literal;
        Token * a;
        expr_ty bitwise_or_var;
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (a = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (bitwise_or_var = bitwise_or_rule(p))  // bitwise_or
        )
        {
            D(fprintf(stderr, "%*c+ invalid_kvpair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' '*' bitwise_or"));
            _res = RAISE_SYNTAX_ERROR_STARTING_FROM ( a , "cannot use a starred expression in a dictionary value" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_kvpair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ':' '*' bitwise_or"));
    }
    { // expression ':' &('}' | ',')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_kvpair[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' &('}' | ',')"));
        Token * a;
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (a = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            _PyPegen_lookahead(1, _tmp_354_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_kvpair[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ':' &('}' | ',')"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "expression expected after dictionary key and ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_kvpair[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ':' &('}' | ',')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_starred_expression: '*' expression '=' expression
static void *
invalid_starred_expression_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '*' expression '=' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_starred_expression[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' expression '=' expression"));
        Token * _literal;
        Token * a;
        expr_ty b;
        expr_ty expression_var;
        if (
            (a = _PyPegen_expect_token(p, 16))  // token='*'
            &&
            (expression_var = expression_rule(p))  // expression
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (b = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ invalid_starred_expression[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*' expression '=' expression"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_RANGE ( a , b , "cannot assign to iterable argument unpacking" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_starred_expression[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*' expression '=' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_replacement_field:
//     | '{' '='
//     | '{' '!'
//     | '{' ':'
//     | '{' '}'
//     | '{' !top_rhs
//     | '{' top_rhs !('=' | '!' | ':' | '}')
//     | '{' top_rhs '=' !('!' | ':' | '}')
//     | '{' top_rhs '='? invalid_conversion_character
//     | '{' top_rhs '='? ['!' NAME] !(':' | '}')
//     | '{' top_rhs '='? ['!' NAME] ':' fstring_format_spec* !'}'
//     | '{' top_rhs '='? ['!' NAME] !'}'
static void *
invalid_replacement_field_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '{' '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' '='"));
        Token * _literal;
        Token * a;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ invalid_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' '='"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "f-string: valid expression required before '='" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' '='"));
    }
    { // '{' '!'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' '!'"));
        Token * _literal;
        Token * a;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = _PyPegen_expect_token(p, 54))  // token='!'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' '!'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "f-string: valid expression required before '!'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' '!'"));
    }
    { // '{' ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' ':'"));
        Token * _literal;
        Token * a;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' ':'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "f-string: valid expression required before ':'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' ':'"));
    }
    { // '{' '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' '}'"));
        Token * _literal;
        Token * a;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (a = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' '}'"));
            _res = RAISE_SYNTAX_ERROR_KNOWN_LOCATION ( a , "f-string: valid expression required before '}'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' '}'"));
    }
    { // '{' !top_rhs
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' !top_rhs"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            _PyPegen_lookahead(0, top_rhs_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' !top_rhs"));
            _res = RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN ( "f-string: expecting a valid expression after '{'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' !top_rhs"));
    }
    { // '{' top_rhs !('=' | '!' | ':' | '}')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs !('=' | '!' | ':' | '}')"));
        Token * _literal;
        expr_ty top_rhs_var;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (top_rhs_var = top_rhs_rule(p))  // top_rhs
            &&
            _PyPegen_lookahead(0, _tmp_355_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs !('=' | '!' | ':' | '}')"));
            _res = PyErr_Occurred ( ) ? NULL : RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN ( "f-string: expecting '=', or '!', or ':', or '}'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' top_rhs !('=' | '!' | ':' | '}')"));
    }
    { // '{' top_rhs '=' !('!' | ':' | '}')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs '=' !('!' | ':' | '}')"));
        Token * _literal;
        Token * _literal_1;
        expr_ty top_rhs_var;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (top_rhs_var = top_rhs_rule(p))  // top_rhs
            &&
            (_literal_1 = _PyPegen_expect_token(p, 22))  // token='='
            &&
            _PyPegen_lookahead(0, _tmp_356_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs '=' !('!' | ':' | '}')"));
            _res = PyErr_Occurred ( ) ? NULL : RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN ( "f-string: expecting '!', or ':', or '}'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' top_rhs '=' !('!' | ':' | '}')"));
    }
    { // '{' top_rhs '='? invalid_conversion_character
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? invalid_conversion_character"));
        Token * _literal;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *invalid_conversion_character_var;
        expr_ty top_rhs_var;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (top_rhs_var = top_rhs_rule(p))  // top_rhs
            &&
            (_opt_var = _PyPegen_expect_token(p, 22), !p->error_indicator)  // '='?
            &&
            (invalid_conversion_character_var = invalid_conversion_character_rule(p))  // invalid_conversion_character
        )
        {
            D(fprintf(stderr, "%*c+ invalid_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? invalid_conversion_character"));
            _res = _PyPegen_dummy_name(p, _literal, top_rhs_var, _opt_var, invalid_conversion_character_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? invalid_conversion_character"));
    }
    { // '{' top_rhs '='? ['!' NAME] !(':' | '}')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? ['!' NAME] !(':' | '}')"));
        Token * _literal;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_opt_var_1;
        UNUSED(_opt_var_1); // Silence compiler warnings
        expr_ty top_rhs_var;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (top_rhs_var = top_rhs_rule(p))  // top_rhs
            &&
            (_opt_var = _PyPegen_expect_token(p, 22), !p->error_indicator)  // '='?
            &&
            (_opt_var_1 = _tmp_357_rule(p), !p->error_indicator)  // ['!' NAME]
            &&
            _PyPegen_lookahead(0, _tmp_358_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? ['!' NAME] !(':' | '}')"));
            _res = PyErr_Occurred ( ) ? NULL : RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN ( "f-string: expecting ':' or '}'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? ['!' NAME] !(':' | '}')"));
    }
    { // '{' top_rhs '='? ['!' NAME] ':' fstring_format_spec* !'}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? ['!' NAME] ':' fstring_format_spec* !'}'"));
        Token * _literal;
        Token * _literal_1;
        asdl_seq * _loop0_360_var;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_opt_var_1;
        UNUSED(_opt_var_1); // Silence compiler warnings
        expr_ty top_rhs_var;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (top_rhs_var = top_rhs_rule(p))  // top_rhs
            &&
            (_opt_var = _PyPegen_expect_token(p, 22), !p->error_indicator)  // '='?
            &&
            (_opt_var_1 = _tmp_359_rule(p), !p->error_indicator)  // ['!' NAME]
            &&
            (_literal_1 = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (_loop0_360_var = _loop0_360_rule(p))  // fstring_format_spec*
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 26)  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? ['!' NAME] ':' fstring_format_spec* !'}'"));
            _res = PyErr_Occurred ( ) ? NULL : RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN ( "f-string: expecting '}', or format specs" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? ['!' NAME] ':' fstring_format_spec* !'}'"));
    }
    { // '{' top_rhs '='? ['!' NAME] !'}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_replacement_field[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? ['!' NAME] !'}'"));
        Token * _literal;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        void *_opt_var_1;
        UNUSED(_opt_var_1); // Silence compiler warnings
        expr_ty top_rhs_var;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
            &&
            (top_rhs_var = top_rhs_rule(p))  // top_rhs
            &&
            (_opt_var = _PyPegen_expect_token(p, 22), !p->error_indicator)  // '='?
            &&
            (_opt_var_1 = _tmp_361_rule(p), !p->error_indicator)  // ['!' NAME]
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 26)  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ invalid_replacement_field[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? ['!' NAME] !'}'"));
            _res = PyErr_Occurred ( ) ? NULL : RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN ( "f-string: expecting '}'" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_replacement_field[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{' top_rhs '='? ['!' NAME] !'}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// invalid_conversion_character: '!' &(':' | '}') | '!' !NAME
static void *
invalid_conversion_character_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '!' &(':' | '}')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_conversion_character[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' &(':' | '}')"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 54))  // token='!'
            &&
            _PyPegen_lookahead(1, _tmp_362_rule, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_conversion_character[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' &(':' | '}')"));
            _res = RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN ( "f-string: missing conversion character" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_conversion_character[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!' &(':' | '}')"));
    }
    { // '!' !NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> invalid_conversion_character[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' !NAME"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 54))  // token='!'
            &&
            _PyPegen_lookahead_with_name(0, _PyPegen_name_token, p)
        )
        {
            D(fprintf(stderr, "%*c+ invalid_conversion_character[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' !NAME"));
            _res = RAISE_SYNTAX_ERROR_ON_NEXT_TOKEN ( "f-string: invalid conversion character" );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s invalid_conversion_character[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!' !NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_1: NEWLINE
static asdl_seq *
_loop0_1_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_1[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE"));
        Token * newline_var;
        while (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            _res = newline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_1[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NEWLINE"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_2: NEWLINE
static asdl_seq *
_loop0_2_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_2[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE"));
        Token * newline_var;
        while (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            _res = newline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_2[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NEWLINE"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_3: fstring_middle
static asdl_seq *
_loop0_3_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // fstring_middle
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_3[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "fstring_middle"));
        expr_ty fstring_middle_var;
        while (
            (fstring_middle_var = fstring_middle_rule(p))  // fstring_middle
        )
        {
            _res = fstring_middle_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_3[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "fstring_middle"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_4: statement
static asdl_seq *
_loop1_4_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // statement
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_4[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statement"));
        asdl_stmt_seq* statement_var;
        while (
            (statement_var = statement_rule(p))  // statement
        )
        {
            _res = statement_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_4[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "statement"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_5: 'return' del_kw_stmt | return_stmt
static void *
_tmp_5_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // 'return' del_kw_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_5[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'return' del_kw_stmt"));
        Token * _keyword;
        stmt_ty del_kw_stmt_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 567))  // token='return'
            &&
            (del_kw_stmt_var = del_kw_stmt_rule(p))  // del_kw_stmt
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_5[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'return' del_kw_stmt"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Return ( NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_5[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'return' del_kw_stmt"));
    }
    { // return_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_5[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "return_stmt"));
        stmt_ty return_stmt_var;
        if (
            (return_stmt_var = return_stmt_rule(p))  // return_stmt
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_5[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "return_stmt"));
            _res = return_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_5[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "return_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_6: 'import' | 'from'
static void *
_tmp_6_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'import'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_6[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'import'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 721))  // token='import'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_6[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'import'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_6[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'import'"));
    }
    { // 'from'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_6[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'from'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 722))  // token='from'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_6[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'from'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_6[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'from'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_7: del_kw_stmt | del_stmt
static void *
_tmp_7_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // del_kw_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_7[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "del_kw_stmt"));
        stmt_ty del_kw_stmt_var;
        if (
            (del_kw_stmt_var = del_kw_stmt_rule(p))  // del_kw_stmt
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_7[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "del_kw_stmt"));
            _res = del_kw_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_7[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "del_kw_stmt"));
    }
    { // del_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_7[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "del_stmt"));
        stmt_ty del_stmt_var;
        if (
            (del_stmt_var = del_stmt_rule(p))  // del_stmt
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_7[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "del_stmt"));
            _res = del_stmt_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_7[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "del_stmt"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_8: "def" | '@' | 'async'
static void *
_tmp_8_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // "def"
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_8[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\""));
        expr_ty _keyword;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "def"))  // soft_keyword='"def"'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_8[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\""));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_8[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"def\""));
    }
    { // '@'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_8[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 49))  // token='@'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_8[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_8[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'@'"));
    }
    { // 'async'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_8[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_8[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_8[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_9: 'class' | '@'
static void *
_tmp_9_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'class'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_9[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 786))  // token='class'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_9[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_9[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'class'"));
    }
    { // '@'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_9[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 49))  // token='@'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_9[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_9[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'@'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_10: 'with' | 'async'
static void *
_tmp_10_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'with'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_10[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 733))  // token='with'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_10[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_10[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'with'"));
    }
    { // 'async'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_10[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_10[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_10[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_11: 'for' | 'async'
static void *
_tmp_11_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'for'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_11[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 782))  // token='for'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_11[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_11[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'for'"));
    }
    { // 'async'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_11[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_11[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_11[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_12: statement_nonewline
static asdl_seq *
_loop1_12_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // statement_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_12[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "statement_nonewline"));
        asdl_stmt_seq* statement_nonewline_var;
        while (
            (statement_nonewline_var = statement_nonewline_rule(p))  // statement_nonewline
        )
        {
            _res = statement_nonewline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_12[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "statement_nonewline"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_14: ';' (';'.simple_stmt+ | parenthesized_stmt_nonewline)
static asdl_seq *
_loop0_14_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ';' (';'.simple_stmt+ | parenthesized_stmt_nonewline)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_14[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';' (';'.simple_stmt+ | parenthesized_stmt_nonewline)"));
        Token * _literal;
        void *elem;
        while (
            (_literal = _PyPegen_expect_token(p, 13))  // token=';'
            &&
            (elem = _tmp_363_rule(p))  // ';'.simple_stmt+ | parenthesized_stmt_nonewline
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_14[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "';' (';'.simple_stmt+ | parenthesized_stmt_nonewline)"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_13: (';'.simple_stmt+ | parenthesized_stmt_nonewline) _loop0_14
static asdl_seq *
_gather_13_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // (';'.simple_stmt+ | parenthesized_stmt_nonewline) _loop0_14
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_13[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(';'.simple_stmt+ | parenthesized_stmt_nonewline) _loop0_14"));
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_363_rule(p))  // ';'.simple_stmt+ | parenthesized_stmt_nonewline
            &&
            (seq = _loop0_14_rule(p))  // _loop0_14
        )
        {
            D(fprintf(stderr, "%*c+ _gather_13[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(';'.simple_stmt+ | parenthesized_stmt_nonewline) _loop0_14"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_13[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(';'.simple_stmt+ | parenthesized_stmt_nonewline) _loop0_14"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_15: 'with' | 'async'
static void *
_tmp_15_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'with'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_15[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 733))  // token='with'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_15[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_15[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'with'"));
    }
    { // 'async'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_15[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_15[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_15[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_16: 'for' | 'async'
static void *
_tmp_16_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'for'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_16[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 782))  // token='for'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_16[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_16[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'for'"));
    }
    { // 'async'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_16[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_16[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_16[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_17: '=' top_rhs
static void *
_tmp_17_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '=' top_rhs
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_17[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' top_rhs"));
        Token * _literal;
        expr_ty d;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (d = top_rhs_rule(p))  // top_rhs
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_17[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' top_rhs"));
            _res = d;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_17[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'=' top_rhs"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_18: '(' single_target ')' | single_subscript_attribute_target
static void *
_tmp_18_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '(' single_target ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_18[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty b;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (b = single_target_rule(p))  // single_target
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_18[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
            _res = b;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_18[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
    }
    { // single_subscript_attribute_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_18[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
        expr_ty single_subscript_attribute_target_var;
        if (
            (single_subscript_attribute_target_var = single_subscript_attribute_target_rule(p))  // single_subscript_attribute_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_18[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
            _res = single_subscript_attribute_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_18[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_19: '=' top_rhs
static void *
_tmp_19_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '=' top_rhs
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_19[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' top_rhs"));
        Token * _literal;
        expr_ty d;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (d = top_rhs_rule(p))  // top_rhs
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_19[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' top_rhs"));
            _res = d;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_19[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'=' top_rhs"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_20: (star_targets '=')
static asdl_seq *
_loop1_20_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // (star_targets '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_20[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(star_targets '=')"));
        void *_tmp_364_var;
        while (
            (_tmp_364_var = _tmp_364_rule(p))  // star_targets '='
        )
        {
            _res = _tmp_364_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_20[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(star_targets '=')"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_21: '|>='
static void *
_tmp_21_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '|>='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_21[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|>='"));
        Token * t;
        if (
            (t = _PyPegen_expect_token(p, 57))  // token='|>='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_21[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|>='"));
            _res = ( ++ p -> subn , t );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_21[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|>='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_22: top_rhs?
static void *
_tmp_22_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // top_rhs?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_22[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "top_rhs?"));
        void *d;
        if (
            (d = top_rhs_rule(p), !p->error_indicator)  // top_rhs?
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_22[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "top_rhs?"));
            _res = ( - - p -> subn , d );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_22[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "top_rhs?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_23: ';' | NEWLINE
static void *
_tmp_23_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ';'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_23[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 13))  // token=';'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_23[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_23[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "';'"));
    }
    { // NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_23[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE"));
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_23[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE"));
            _res = newline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_23[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_24: '+=' | '+' '='
static void *
_tmp_24_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '+='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_24[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 36))  // token='+='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_24[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+='"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_24[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'+='"));
    }
    { // '+' '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_24[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+' '='"));
        Token * _literal;
        Token * _literal_1;
        if (
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_24[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+' '='"));
            _res = _PyPegen_dummy_name(p, _literal, _literal_1);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_24[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'+' '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_25: '-=' | '-' '='
static void *
_tmp_25_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '-='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_25[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 37))  // token='-='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_25[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-='"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_25[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'-='"));
    }
    { // '-' '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_25[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-' '='"));
        Token * _literal;
        Token * _literal_1;
        if (
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_25[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-' '='"));
            _res = _PyPegen_dummy_name(p, _literal, _literal_1);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_25[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'-' '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_26: '!=' | '!' '='
static void *
_tmp_26_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '!='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_26[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 28))  // token='!='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_26[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!='"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_26[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!='"));
    }
    { // '!' '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_26[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' '='"));
        Token * _literal;
        Token * _literal_1;
        if (
            (_literal = _PyPegen_expect_token(p, 54))  // token='!'
            &&
            (_literal_1 = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_26[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' '='"));
            _res = _PyPegen_dummy_name(p, _literal, _literal_1);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_26[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!' '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_27: 'from' expression
static void *
_tmp_27_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'from' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_27[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'from' expression"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 722))  // token='from'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_27[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'from' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_27[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'from' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_29: ',' NAME
static asdl_seq *
_loop0_29_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_29[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' NAME"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _PyPegen_name_token(p))  // NAME
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_29[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' NAME"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_28: NAME _loop0_29
static asdl_seq *
_gather_28_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // NAME _loop0_29
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_28[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME _loop0_29"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = _PyPegen_name_token(p))  // NAME
            &&
            (seq = _loop0_29_rule(p))  // _loop0_29
        )
        {
            D(fprintf(stderr, "%*c+ _gather_28[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME _loop0_29"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_28[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME _loop0_29"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_31: ',' NAME
static asdl_seq *
_loop0_31_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_31[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' NAME"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _PyPegen_name_token(p))  // NAME
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_31[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' NAME"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_30: NAME _loop0_31
static asdl_seq *
_gather_30_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // NAME _loop0_31
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_30[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME _loop0_31"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = _PyPegen_name_token(p))  // NAME
            &&
            (seq = _loop0_31_rule(p))  // _loop0_31
        )
        {
            D(fprintf(stderr, "%*c+ _gather_30[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME _loop0_31"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_30[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME _loop0_31"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_32:
//     | 'False'
//     | 'None'
//     | 'True'
//     | 'and'
//     | 'as'
//     | 'assert'
//     | 'async'
//     | 'await'
//     | 'break'
//     | 'class'
//     | 'continue'
//     | 'del'
//     | 'elif'
//     | 'else'
//     | 'except'
//     | 'finally'
//     | 'for'
//     | 'from'
//     | 'global'
//     | 'goto'
//     | 'if'
//     | 'import'
//     | 'in'
//     | 'is'
//     | 'lambda'
//     | 'nonlocal'
//     | 'not'
//     | 'or'
//     | 'pass'
//     | 'raise'
//     | 'return'
//     | 'try'
//     | 'while'
//     | 'with'
//     | 'yield'
static void *
_tmp_32_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'False'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 716))  // token='False'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'False'"));
    }
    { // 'None'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 715))  // token='None'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'None'"));
    }
    { // 'True'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 714))  // token='True'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'True'"));
    }
    { // 'and'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'and'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 678))  // token='and'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'and'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'and'"));
    }
    { // 'as'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as'"));
    }
    { // 'assert'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'assert'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 573))  // token='assert'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'assert'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'assert'"));
    }
    { // 'async'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'"));
    }
    { // 'await'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'await'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 691))  // token='await'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'await'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'await'"));
    }
    { // 'break'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'break'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 545))  // token='break'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'break'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'break'"));
    }
    { // 'class'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 786))  // token='class'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'class'"));
    }
    { // 'continue'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'continue'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 547))  // token='continue'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'continue'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'continue'"));
    }
    { // 'del'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'del'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 717))  // token='del'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'del'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'del'"));
    }
    { // 'elif'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 774))  // token='elif'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'elif'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'elif'"));
    }
    { // 'else'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'else'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 775))  // token='else'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'else'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'else'"));
    }
    { // 'except'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 767))  // token='except'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except'"));
    }
    { // 'finally'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 763))  // token='finally'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'finally'"));
    }
    { // 'for'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 782))  // token='for'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'for'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'for'"));
    }
    { // 'from'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'from'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 722))  // token='from'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'from'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'from'"));
    }
    { // 'global'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'global'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 555))  // token='global'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'global'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'global'"));
    }
    { // 'goto'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'goto'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 574))  // token='goto'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'goto'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'goto'"));
    }
    { // 'if'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'if'"));
    }
    { // 'import'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'import'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 721))  // token='import'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'import'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'import'"));
    }
    { // 'in'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'in'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 783))  // token='in'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'in'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'in'"));
    }
    { // 'is'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'is'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 690))  // token='is'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'is'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'is'"));
    }
    { // 'lambda'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'lambda'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 713))  // token='lambda'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'lambda'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'lambda'"));
    }
    { // 'nonlocal'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'nonlocal'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 562))  // token='nonlocal'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'nonlocal'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'nonlocal'"));
    }
    { // 'not'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'not'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 689))  // token='not'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'not'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'not'"));
    }
    { // 'or'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'or'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 677))  // token='or'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'or'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'or'"));
    }
    { // 'pass'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'pass'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 565))  // token='pass'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'pass'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'pass'"));
    }
    { // 'raise'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'raise'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 566))  // token='raise'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'raise'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'raise'"));
    }
    { // 'return'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'return'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 567))  // token='return'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'return'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'return'"));
    }
    { // 'try'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 751))  // token='try'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'try'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'try'"));
    }
    { // 'while'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'while'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 777))  // token='while'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'while'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'while'"));
    }
    { // 'with'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 733))  // token='with'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'with'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'with'"));
    }
    { // 'yield'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_32[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'yield'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 676))  // token='yield'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_32[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'yield'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_32[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'yield'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_33: ';' | NEWLINE
static void *
_tmp_33_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ';'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_33[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 13))  // token=';'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_33[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_33[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "';'"));
    }
    { // NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_33[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE"));
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_33[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE"));
            _res = newline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_33[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_34: ',' expression
static void *
_tmp_34_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_34[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_34[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_34[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_36: ',' NAME
static asdl_seq *
_loop0_36_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_36[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' NAME"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _PyPegen_name_token(p))  // NAME
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_36[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' NAME"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_35: NAME _loop0_36
static asdl_seq *
_gather_35_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // NAME _loop0_36
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_35[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME _loop0_36"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = _PyPegen_name_token(p))  // NAME
            &&
            (seq = _loop0_36_rule(p))  // _loop0_36
        )
        {
            D(fprintf(stderr, "%*c+ _gather_35[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME _loop0_36"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_35[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME _loop0_36"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_37: ('.' | '...')
static asdl_seq *
_loop0_37_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ('.' | '...')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_37[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('.' | '...')"));
        void *_tmp_365_var;
        while (
            (_tmp_365_var = _tmp_365_rule(p))  // '.' | '...'
        )
        {
            _res = _tmp_365_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_37[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('.' | '...')"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_38: ('.' | '...')
static asdl_seq *
_loop1_38_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ('.' | '...')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_38[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('.' | '...')"));
        void *_tmp_366_var;
        while (
            (_tmp_366_var = _tmp_366_rule(p))  // '.' | '...'
        )
        {
            _res = _tmp_366_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_38[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('.' | '...')"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_40: ',' import_from_as_name
static asdl_seq *
_loop0_40_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' import_from_as_name
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_40[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' import_from_as_name"));
        Token * _literal;
        alias_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = import_from_as_name_rule(p))  // import_from_as_name
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_40[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' import_from_as_name"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_39: import_from_as_name _loop0_40
static asdl_seq *
_gather_39_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // import_from_as_name _loop0_40
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_39[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "import_from_as_name _loop0_40"));
        alias_ty elem;
        asdl_seq * seq;
        if (
            (elem = import_from_as_name_rule(p))  // import_from_as_name
            &&
            (seq = _loop0_40_rule(p))  // _loop0_40
        )
        {
            D(fprintf(stderr, "%*c+ _gather_39[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "import_from_as_name _loop0_40"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_39[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "import_from_as_name _loop0_40"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_41: 'as' NAME
static void *
_tmp_41_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_41[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (z = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_41[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_41[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_43: ',' dotted_as_name
static asdl_seq *
_loop0_43_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' dotted_as_name
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_43[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' dotted_as_name"));
        Token * _literal;
        alias_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = dotted_as_name_rule(p))  // dotted_as_name
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_43[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' dotted_as_name"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_42: dotted_as_name _loop0_43
static asdl_seq *
_gather_42_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // dotted_as_name _loop0_43
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_42[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dotted_as_name _loop0_43"));
        alias_ty elem;
        asdl_seq * seq;
        if (
            (elem = dotted_as_name_rule(p))  // dotted_as_name
            &&
            (seq = _loop0_43_rule(p))  // _loop0_43
        )
        {
            D(fprintf(stderr, "%*c+ _gather_42[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dotted_as_name _loop0_43"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_42[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "dotted_as_name _loop0_43"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_44: 'as' NAME
static void *
_tmp_44_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_44[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (z = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_44[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_44[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_45: '=' block_expr
static void *
_tmp_45_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '=' block_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_45[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' block_expr"));
        Token * _literal;
        expr_ty d;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (d = block_expr_rule(p))  // block_expr
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_45[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' block_expr"));
            _res = d;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_45[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'=' block_expr"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_46: '(' single_target ')' | single_subscript_attribute_target
static void *
_tmp_46_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '(' single_target ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_46[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty b;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (b = single_target_rule(p))  // single_target
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_46[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
            _res = b;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_46[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
    }
    { // single_subscript_attribute_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_46[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
        expr_ty single_subscript_attribute_target_var;
        if (
            (single_subscript_attribute_target_var = single_subscript_attribute_target_rule(p))  // single_subscript_attribute_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_46[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
            _res = single_subscript_attribute_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_46[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_47: '=' block_expr
static void *
_tmp_47_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '=' block_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_47[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' block_expr"));
        Token * _literal;
        expr_ty d;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (d = block_expr_rule(p))  // block_expr
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_47[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' block_expr"));
            _res = d;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_47[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'=' block_expr"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_48: (star_targets '=')
static asdl_seq *
_loop1_48_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // (star_targets '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_48[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(star_targets '=')"));
        void *_tmp_367_var;
        while (
            (_tmp_367_var = _tmp_367_rule(p))  // star_targets '='
        )
        {
            _res = _tmp_367_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_48[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(star_targets '=')"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_49: '|>='
static void *
_tmp_49_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '|>='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_49[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|>='"));
        Token * t;
        if (
            (t = _PyPegen_expect_token(p, 57))  // token='|>='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_49[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|>='"));
            _res = ( ++ p -> subn , t );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_49[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|>='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_50: block_expr?
static void *
_tmp_50_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // block_expr?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_50[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block_expr?"));
        void *d;
        if (
            (d = block_expr_rule(p), !p->error_indicator)  // block_expr?
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_50[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block_expr?"));
            _res = ( - - p -> subn , d );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_50[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "block_expr?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_51: '=' block_expr_nonewline
static void *
_tmp_51_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '=' block_expr_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_51[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' block_expr_nonewline"));
        Token * _literal;
        expr_ty d;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (d = block_expr_nonewline_rule(p))  // block_expr_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_51[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' block_expr_nonewline"));
            _res = d;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_51[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'=' block_expr_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_52: '(' single_target ')' | single_subscript_attribute_target
static void *
_tmp_52_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '(' single_target ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_52[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
        Token * _literal;
        Token * _literal_1;
        expr_ty b;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (b = single_target_rule(p))  // single_target
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_52[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
            _res = b;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_52[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' single_target ')'"));
    }
    { // single_subscript_attribute_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_52[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
        expr_ty single_subscript_attribute_target_var;
        if (
            (single_subscript_attribute_target_var = single_subscript_attribute_target_rule(p))  // single_subscript_attribute_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_52[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
            _res = single_subscript_attribute_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_52[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "single_subscript_attribute_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_53: '=' block_expr_nonewline
static void *
_tmp_53_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '=' block_expr_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_53[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' block_expr_nonewline"));
        Token * _literal;
        expr_ty d;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
            &&
            (d = block_expr_nonewline_rule(p))  // block_expr_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_53[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'=' block_expr_nonewline"));
            _res = d;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_53[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'=' block_expr_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_54: (star_targets '=')
static asdl_seq *
_loop1_54_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // (star_targets '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_54[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(star_targets '=')"));
        void *_tmp_368_var;
        while (
            (_tmp_368_var = _tmp_368_rule(p))  // star_targets '='
        )
        {
            _res = _tmp_368_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_54[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(star_targets '=')"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_55: '|>='
static void *
_tmp_55_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '|>='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_55[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|>='"));
        Token * t;
        if (
            (t = _PyPegen_expect_token(p, 57))  // token='|>='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_55[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|>='"));
            _res = ( ++ p -> subn , t );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_55[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|>='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_56: block_expr_nonewline?
static void *
_tmp_56_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // block_expr_nonewline?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_56[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block_expr_nonewline?"));
        void *d;
        if (
            (d = block_expr_nonewline_rule(p), !p->error_indicator)  // block_expr_nonewline?
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_56[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block_expr_nonewline?"));
            _res = ( - - p -> subn , d );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_56[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "block_expr_nonewline?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_57: '{'
static void *
_tmp_57_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '{'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_57[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{'"));
        Token * start;
        if (
            (start = _PyPegen_expect_token(p, 25))  // token='{'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_57[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{'"));
            _res = _PyPegen_check_braces ( p ) ? start : NULL;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_57[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_58: ('@' named_expression NEWLINE)
static asdl_seq *
_loop1_58_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ('@' named_expression NEWLINE)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_58[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('@' named_expression NEWLINE)"));
        void *_tmp_369_var;
        while (
            (_tmp_369_var = _tmp_369_rule(p))  // '@' named_expression NEWLINE
        )
        {
            _res = _tmp_369_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_58[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('@' named_expression NEWLINE)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_59: '(' arguments? ')'
static void *
_tmp_59_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '(' arguments? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_59[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *z;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (z = arguments_rule(p), !p->error_indicator)  // arguments?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_59[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_59[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_60: '(' arguments? ')'
static void *
_tmp_60_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '(' arguments? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_60[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *z;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (z = arguments_rule(p), !p->error_indicator)  // arguments?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_60[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_60[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_61: '->' expression
static void *
_tmp_61_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '->' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_61[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_61[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_61[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'->' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_62: '->' expression
static void *
_tmp_62_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '->' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_62[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_62[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_62[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'->' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_63: '->' expression
static void *
_tmp_63_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '->' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_63[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_63[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_63[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'->' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_64: '->' expression
static void *
_tmp_64_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '->' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_64[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_64[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_64[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'->' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_65: '->' expression
static void *
_tmp_65_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '->' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_65[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_65[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_65[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'->' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_66: '->' expression
static void *
_tmp_66_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '->' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_66[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_66[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_66[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'->' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_67: '->' expression
static void *
_tmp_67_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '->' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_67[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_67[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_67[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'->' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_68: '->' expression
static void *
_tmp_68_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '->' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_68[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
        Token * _literal;
        expr_ty z;
        if (
            (_literal = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (z = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_68[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_68[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'->' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_69: param_no_default
static asdl_seq *
_loop0_69_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_69[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_69[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_70: param_with_default
static asdl_seq *
_loop0_70_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_70[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_70[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_with_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_71: param_with_default
static asdl_seq *
_loop0_71_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_71[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_71[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_with_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_72: param_no_default
static asdl_seq *
_loop1_72_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_72[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_72[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_73: param_with_default
static asdl_seq *
_loop0_73_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_73[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_73[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_with_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_74: param_with_default
static asdl_seq *
_loop1_74_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_74[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_74[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_75: param_no_default
static asdl_seq *
_loop1_75_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_75[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_75[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_76: param_no_default
static asdl_seq *
_loop1_76_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_76[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_76[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_77: param_no_default
static asdl_seq *
_loop0_77_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_77[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_77[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_78: param_with_default
static asdl_seq *
_loop1_78_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_78[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_78[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_79: param_no_default
static asdl_seq *
_loop0_79_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_79[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_79[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_80: param_with_default
static asdl_seq *
_loop1_80_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_80[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_80[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_81: param_maybe_default
static asdl_seq *
_loop0_81_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_81[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_maybe_default"));
        NameDefaultPair* param_maybe_default_var;
        while (
            (param_maybe_default_var = param_maybe_default_rule(p))  // param_maybe_default
        )
        {
            _res = param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_81[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_82: param_maybe_default
static asdl_seq *
_loop0_82_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_82[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_maybe_default"));
        NameDefaultPair* param_maybe_default_var;
        while (
            (param_maybe_default_var = param_maybe_default_rule(p))  // param_maybe_default
        )
        {
            _res = param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_82[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_83: param_maybe_default
static asdl_seq *
_loop1_83_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_83[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_maybe_default"));
        NameDefaultPair* param_maybe_default_var;
        while (
            (param_maybe_default_var = param_maybe_default_rule(p))  // param_maybe_default
        )
        {
            _res = param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_83[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_maybe_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_84: braced_block | &&':' block
static void *
_tmp_84_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_84[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_84[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_84[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    { // &&':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_84[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block"));
        Token * _literal;
        asdl_stmt_seq* c;
        if (
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (c = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_84[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_84[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&&':' block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_85: braced_block | &&':' block_nonewline
static void *
_tmp_85_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_85[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_85[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_85[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    { // &&':' block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_85[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
        Token * _literal;
        asdl_stmt_seq* c;
        if (
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (c = block_nonewline_rule(p))  // block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_85[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_85[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_87: ',' with_item
static asdl_seq *
_loop0_87_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_87[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_87[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_86: with_item _loop0_87
static asdl_seq *
_gather_86_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_87
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_86[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_87"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_87_rule(p))  // _loop0_87
        )
        {
            D(fprintf(stderr, "%*c+ _gather_86[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_87"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_86[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_87"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_89: ',' with_item
static asdl_seq *
_loop0_89_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_89[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_89[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_88: with_item _loop0_89
static asdl_seq *
_gather_88_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_89
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_88[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_89"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_89_rule(p))  // _loop0_89
        )
        {
            D(fprintf(stderr, "%*c+ _gather_88[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_89"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_88[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_89"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_91: ',' with_item
static asdl_seq *
_loop0_91_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_91[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_91[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_90: with_item _loop0_91
static asdl_seq *
_gather_90_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_91
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_90[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_91"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_91_rule(p))  // _loop0_91
        )
        {
            D(fprintf(stderr, "%*c+ _gather_90[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_91"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_90[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_91"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_93: ',' with_item
static asdl_seq *
_loop0_93_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_93[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_93[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_92: with_item _loop0_93
static asdl_seq *
_gather_92_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_93
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_92[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_93"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_93_rule(p))  // _loop0_93
        )
        {
            D(fprintf(stderr, "%*c+ _gather_92[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_93"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_92[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_93"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_95: ',' with_item
static asdl_seq *
_loop0_95_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_95[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_95[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_94: with_item _loop0_95
static asdl_seq *
_gather_94_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_95
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_94[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_95"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_95_rule(p))  // _loop0_95
        )
        {
            D(fprintf(stderr, "%*c+ _gather_94[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_95"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_94[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_95"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_97: ',' with_item
static asdl_seq *
_loop0_97_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_97[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_97[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_96: with_item _loop0_97
static asdl_seq *
_gather_96_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_97
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_96[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_97"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_97_rule(p))  // _loop0_97
        )
        {
            D(fprintf(stderr, "%*c+ _gather_96[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_97"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_96[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_97"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_99: ',' with_item
static asdl_seq *
_loop0_99_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_99[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_99[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_98: with_item _loop0_99
static asdl_seq *
_gather_98_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_99
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_98[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_99"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_99_rule(p))  // _loop0_99
        )
        {
            D(fprintf(stderr, "%*c+ _gather_98[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_99"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_98[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_99"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_101: ',' with_item
static asdl_seq *
_loop0_101_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_101[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_101[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_100: with_item _loop0_101
static asdl_seq *
_gather_100_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_101
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_100[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_101"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_101_rule(p))  // _loop0_101
        )
        {
            D(fprintf(stderr, "%*c+ _gather_100[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_101"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_100[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_101"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_103: ',' with_item
static asdl_seq *
_loop0_103_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_103[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_103[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_102: with_item _loop0_103
static asdl_seq *
_gather_102_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_103
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_102[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_103"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_103_rule(p))  // _loop0_103
        )
        {
            D(fprintf(stderr, "%*c+ _gather_102[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_103"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_102[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_103"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_105: ',' with_item
static asdl_seq *
_loop0_105_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_105[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_105[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_104: with_item _loop0_105
static asdl_seq *
_gather_104_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_105
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_104[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_105"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_105_rule(p))  // _loop0_105
        )
        {
            D(fprintf(stderr, "%*c+ _gather_104[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_105"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_104[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_105"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_107: ',' with_item
static asdl_seq *
_loop0_107_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_107[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_107[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_106: with_item _loop0_107
static asdl_seq *
_gather_106_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_107
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_106[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_107"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_107_rule(p))  // _loop0_107
        )
        {
            D(fprintf(stderr, "%*c+ _gather_106[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_107"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_106[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_107"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_109: ',' with_item
static asdl_seq *
_loop0_109_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' with_item
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_109[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' with_item"));
        Token * _literal;
        withitem_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = with_item_rule(p))  // with_item
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_109[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' with_item"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_108: with_item _loop0_109
static asdl_seq *
_gather_108_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // with_item _loop0_109
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_108[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_109"));
        withitem_ty elem;
        asdl_seq * seq;
        if (
            (elem = with_item_rule(p))  // with_item
            &&
            (seq = _loop0_109_rule(p))  // _loop0_109
        )
        {
            D(fprintf(stderr, "%*c+ _gather_108[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "with_item _loop0_109"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_108[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "with_item _loop0_109"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_110: ',' | ')' | ':'
static void *
_tmp_110_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_110[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_110[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_110[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    { // ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_110[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_110[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_110[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "')'"));
    }
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_110[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_110[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_110[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_111: &&':' block | braced_block
static void *
_tmp_111_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // &&':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_111[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block"));
        Token * _literal;
        asdl_stmt_seq* c;
        if (
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (c = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_111[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_111[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&&':' block"));
    }
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_111[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_111[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_111[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_112: &&':' block | braced_block
static void *
_tmp_112_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // &&':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_112[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block"));
        Token * _literal;
        asdl_stmt_seq* c;
        if (
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (c = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_112[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_112[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&&':' block"));
    }
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_112[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_112[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_112[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_113: except_block
static asdl_seq *
_loop1_113_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // except_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_113[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "except_block"));
        excepthandler_ty except_block_var;
        while (
            (except_block_var = except_block_rule(p))  // except_block
        )
        {
            _res = except_block_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_113[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "except_block"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_114: &&':' block | braced_block
static void *
_tmp_114_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // &&':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_114[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block"));
        Token * _literal;
        asdl_stmt_seq* c;
        if (
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (c = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_114[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_114[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&&':' block"));
    }
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_114[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_114[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_114[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_115: except_star_block
static asdl_seq *
_loop1_115_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // except_star_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_115[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "except_star_block"));
        excepthandler_ty except_star_block_var;
        while (
            (except_star_block_var = except_star_block_rule(p))  // except_star_block
        )
        {
            _res = except_star_block_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_115[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "except_star_block"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_116: &&':' block_nonewline | braced_block
static void *
_tmp_116_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // &&':' block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_116[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
        Token * _literal;
        asdl_stmt_seq* c;
        if (
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (c = block_nonewline_rule(p))  // block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_116[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_116[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
    }
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_116[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_116[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_116[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_117: &&':' block_nonewline | braced_block
static void *
_tmp_117_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // &&':' block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_117[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
        Token * _literal;
        asdl_stmt_seq* c;
        if (
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (c = block_nonewline_rule(p))  // block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_117[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_117[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
    }
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_117[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_117[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_117[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_118: except_block_nonewline
static asdl_seq *
_loop1_118_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // except_block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_118[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "except_block_nonewline"));
        excepthandler_ty except_block_nonewline_var;
        while (
            (except_block_nonewline_var = except_block_nonewline_rule(p))  // except_block_nonewline
        )
        {
            _res = except_block_nonewline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_118[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "except_block_nonewline"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_119: &&':' block_nonewline | braced_block
static void *
_tmp_119_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // &&':' block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_119[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
        Token * _literal;
        asdl_stmt_seq* c;
        if (
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (c = block_nonewline_rule(p))  // block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_119[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_119[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
    }
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_119[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_119[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_119[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_120: except_star_block_nonewline
static asdl_seq *
_loop1_120_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // except_star_block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_120[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "except_star_block_nonewline"));
        excepthandler_ty except_star_block_nonewline_var;
        while (
            (except_star_block_nonewline_var = except_star_block_nonewline_rule(p))  // except_star_block_nonewline
        )
        {
            _res = except_star_block_nonewline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_120[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "except_star_block_nonewline"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_121: 'as' NAME
static void *
_tmp_121_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_121[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (z = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_121[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_121[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_122: 'as' NAME
static void *
_tmp_122_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_122[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (z = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_122[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_122[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_123: &&':' block | braced_block
static void *
_tmp_123_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // &&':' block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_123[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block"));
        Token * _literal;
        asdl_stmt_seq* b;
        if (
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (b = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_123[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block"));
            _res = b;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_123[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&&':' block"));
    }
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_123[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_123[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_123[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_124: 'as' NAME
static void *
_tmp_124_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_124[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (z = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_124[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_124[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_125: 'as' NAME
static void *
_tmp_125_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_125[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (z = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_125[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_125[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_126: &&':' block_nonewline | braced_block
static void *
_tmp_126_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // &&':' block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_126[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
        Token * _literal;
        asdl_stmt_seq* b;
        if (
            (_literal = _PyPegen_expect_forced_token(p, 11, ":"))  // forced_token=':'
            &&
            (b = block_nonewline_rule(p))  // block_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_126[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
            _res = b;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_126[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&&':' block_nonewline"));
    }
    { // braced_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_126[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
        asdl_stmt_seq* braced_block_var;
        if (
            (braced_block_var = braced_block_rule(p))  // braced_block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_126[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "braced_block"));
            _res = braced_block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_126[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "braced_block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_127: switchcase_block
static asdl_seq *
_loop1_127_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // switchcase_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_127[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "switchcase_block"));
        switch_case_ty switchcase_block_var;
        while (
            (switchcase_block_var = switchcase_block_rule(p))  // switchcase_block
        )
        {
            _res = switchcase_block_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_127[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "switchcase_block"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_128: switchcase_block
static asdl_seq *
_loop1_128_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // switchcase_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_128[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "switchcase_block"));
        switch_case_ty switchcase_block_var;
        while (
            (switchcase_block_var = switchcase_block_rule(p))  // switchcase_block
        )
        {
            _res = switchcase_block_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_128[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "switchcase_block"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_130: ',' (bitwiseor_pattern | 'None')
static asdl_seq *
_loop0_130_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' (bitwiseor_pattern | 'None')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_130[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (bitwiseor_pattern | 'None')"));
        Token * _literal;
        void *elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _tmp_370_rule(p))  // bitwiseor_pattern | 'None'
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_130[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' (bitwiseor_pattern | 'None')"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_129: (bitwiseor_pattern | 'None') _loop0_130
static asdl_seq *
_gather_129_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // (bitwiseor_pattern | 'None') _loop0_130
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_129[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(bitwiseor_pattern | 'None') _loop0_130"));
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_370_rule(p))  // bitwiseor_pattern | 'None'
            &&
            (seq = _loop0_130_rule(p))  // _loop0_130
        )
        {
            D(fprintf(stderr, "%*c+ _gather_129[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(bitwiseor_pattern | 'None') _loop0_130"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_129[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(bitwiseor_pattern | 'None') _loop0_130"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_131: switchcase_block_nonewline
static asdl_seq *
_loop1_131_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // switchcase_block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_131[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "switchcase_block_nonewline"));
        switch_case_ty switchcase_block_nonewline_var;
        while (
            (switchcase_block_nonewline_var = switchcase_block_nonewline_rule(p))  // switchcase_block_nonewline
        )
        {
            _res = switchcase_block_nonewline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_131[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "switchcase_block_nonewline"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_132: switchcase_block_nonewline
static asdl_seq *
_loop1_132_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // switchcase_block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_132[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "switchcase_block_nonewline"));
        switch_case_ty switchcase_block_nonewline_var;
        while (
            (switchcase_block_nonewline_var = switchcase_block_nonewline_rule(p))  // switchcase_block_nonewline
        )
        {
            _res = switchcase_block_nonewline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_132[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "switchcase_block_nonewline"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_134: ',' (bitwiseor_pattern | 'None')
static asdl_seq *
_loop0_134_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' (bitwiseor_pattern | 'None')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_134[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (bitwiseor_pattern | 'None')"));
        Token * _literal;
        void *elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _tmp_371_rule(p))  // bitwiseor_pattern | 'None'
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_134[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' (bitwiseor_pattern | 'None')"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_133: (bitwiseor_pattern | 'None') _loop0_134
static asdl_seq *
_gather_133_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // (bitwiseor_pattern | 'None') _loop0_134
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_133[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(bitwiseor_pattern | 'None') _loop0_134"));
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_371_rule(p))  // bitwiseor_pattern | 'None'
            &&
            (seq = _loop0_134_rule(p))  // _loop0_134
        )
        {
            D(fprintf(stderr, "%*c+ _gather_133[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(bitwiseor_pattern | 'None') _loop0_134"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_133[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(bitwiseor_pattern | 'None') _loop0_134"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_135: case_block
static asdl_seq *
_loop1_135_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // case_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_135[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "case_block"));
        match_case_ty case_block_var;
        while (
            (case_block_var = case_block_rule(p))  // case_block
        )
        {
            _res = case_block_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_135[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "case_block"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_136: case_block
static asdl_seq *
_loop1_136_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // case_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_136[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "case_block"));
        match_case_ty case_block_var;
        while (
            (case_block_var = case_block_rule(p))  // case_block
        )
        {
            _res = case_block_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_136[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "case_block"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_137: case_block_nonewline
static asdl_seq *
_loop1_137_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // case_block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_137[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "case_block_nonewline"));
        match_case_ty case_block_nonewline_var;
        while (
            (case_block_nonewline_var = case_block_nonewline_rule(p))  // case_block_nonewline
        )
        {
            _res = case_block_nonewline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_137[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "case_block_nonewline"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_138: case_block_nonewline
static asdl_seq *
_loop1_138_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // case_block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_138[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "case_block_nonewline"));
        match_case_ty case_block_nonewline_var;
        while (
            (case_block_nonewline_var = case_block_nonewline_rule(p))  // case_block_nonewline
        )
        {
            _res = case_block_nonewline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_138[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "case_block_nonewline"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_140: '|' closed_pattern
static asdl_seq *
_loop0_140_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // '|' closed_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_140[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|' closed_pattern"));
        Token * _literal;
        pattern_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 18))  // token='|'
            &&
            (elem = closed_pattern_rule(p))  // closed_pattern
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_140[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|' closed_pattern"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_139: closed_pattern _loop0_140
static asdl_seq *
_gather_139_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // closed_pattern _loop0_140
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_139[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "closed_pattern _loop0_140"));
        pattern_ty elem;
        asdl_seq * seq;
        if (
            (elem = closed_pattern_rule(p))  // closed_pattern
            &&
            (seq = _loop0_140_rule(p))  // _loop0_140
        )
        {
            D(fprintf(stderr, "%*c+ _gather_139[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "closed_pattern _loop0_140"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_139[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "closed_pattern _loop0_140"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_141: '+' | '-'
static void *
_tmp_141_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '+'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_141[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_141[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_141[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'+'"));
    }
    { // '-'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_141[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_141[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_141[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'-'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_142: '+' | '-'
static void *
_tmp_142_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '+'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_142[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 14))  // token='+'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_142[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'+'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_142[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'+'"));
    }
    { // '-'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_142[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 15))  // token='-'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_142[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'-'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_142[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'-'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_143: '.' | '(' | '='
static void *
_tmp_143_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '.'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_143[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'.'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_143[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'.'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_143[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'.'"));
    }
    { // '('
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_143[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'('"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_143[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'('"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_143[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'('"));
    }
    { // '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_143[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_143[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'='"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_143[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_144: '.' | '(' | '='
static void *
_tmp_144_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '.'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_144[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'.'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_144[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'.'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_144[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'.'"));
    }
    { // '('
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_144[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'('"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_144[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'('"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_144[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'('"));
    }
    { // '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_144[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_144[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'='"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_144[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_146: ',' maybe_star_pattern
static asdl_seq *
_loop0_146_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' maybe_star_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_146[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' maybe_star_pattern"));
        Token * _literal;
        pattern_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = maybe_star_pattern_rule(p))  // maybe_star_pattern
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_146[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' maybe_star_pattern"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_145: maybe_star_pattern _loop0_146
static asdl_seq *
_gather_145_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // maybe_star_pattern _loop0_146
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_145[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "maybe_star_pattern _loop0_146"));
        pattern_ty elem;
        asdl_seq * seq;
        if (
            (elem = maybe_star_pattern_rule(p))  // maybe_star_pattern
            &&
            (seq = _loop0_146_rule(p))  // _loop0_146
        )
        {
            D(fprintf(stderr, "%*c+ _gather_145[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "maybe_star_pattern _loop0_146"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_145[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "maybe_star_pattern _loop0_146"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_148: ',' key_value_pattern
static asdl_seq *
_loop0_148_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' key_value_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_148[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' key_value_pattern"));
        Token * _literal;
        KeyPatternPair* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = key_value_pattern_rule(p))  // key_value_pattern
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_148[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' key_value_pattern"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_147: key_value_pattern _loop0_148
static asdl_seq *
_gather_147_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // key_value_pattern _loop0_148
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_147[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "key_value_pattern _loop0_148"));
        KeyPatternPair* elem;
        asdl_seq * seq;
        if (
            (elem = key_value_pattern_rule(p))  // key_value_pattern
            &&
            (seq = _loop0_148_rule(p))  // _loop0_148
        )
        {
            D(fprintf(stderr, "%*c+ _gather_147[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "key_value_pattern _loop0_148"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_147[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "key_value_pattern _loop0_148"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_149: literal_expr | attr
static void *
_tmp_149_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // literal_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_149[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "literal_expr"));
        expr_ty literal_expr_var;
        if (
            (literal_expr_var = literal_expr_rule(p))  // literal_expr
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_149[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "literal_expr"));
            _res = literal_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_149[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "literal_expr"));
    }
    { // attr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_149[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "attr"));
        expr_ty attr_var;
        if (
            (attr_var = attr_rule(p))  // attr
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_149[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "attr"));
            _res = attr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_149[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "attr"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_151: ',' pattern
static asdl_seq *
_loop0_151_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_151[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' pattern"));
        Token * _literal;
        pattern_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = pattern_rule(p))  // pattern
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_151[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' pattern"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_150: pattern _loop0_151
static asdl_seq *
_gather_150_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // pattern _loop0_151
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_150[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "pattern _loop0_151"));
        pattern_ty elem;
        asdl_seq * seq;
        if (
            (elem = pattern_rule(p))  // pattern
            &&
            (seq = _loop0_151_rule(p))  // _loop0_151
        )
        {
            D(fprintf(stderr, "%*c+ _gather_150[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "pattern _loop0_151"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_150[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "pattern _loop0_151"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_153: ',' keyword_pattern
static asdl_seq *
_loop0_153_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' keyword_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_153[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' keyword_pattern"));
        Token * _literal;
        KeyPatternPair* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = keyword_pattern_rule(p))  // keyword_pattern
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_153[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' keyword_pattern"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_152: keyword_pattern _loop0_153
static asdl_seq *
_gather_152_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // keyword_pattern _loop0_153
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_152[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "keyword_pattern _loop0_153"));
        KeyPatternPair* elem;
        asdl_seq * seq;
        if (
            (elem = keyword_pattern_rule(p))  // keyword_pattern
            &&
            (seq = _loop0_153_rule(p))  // _loop0_153
        )
        {
            D(fprintf(stderr, "%*c+ _gather_152[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "keyword_pattern _loop0_153"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_152[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "keyword_pattern _loop0_153"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_154: ';'.simple_stmt+ ';'? | block
static void *
_tmp_154_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ';'.simple_stmt+ ';'?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_154[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';'.simple_stmt+ ';'?"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        asdl_stmt_seq* s;
        if (
            (s = (asdl_stmt_seq*)_gather_372_rule(p))  // ';'.simple_stmt+
            &&
            (_opt_var = _PyPegen_expect_token(p, 13), !p->error_indicator)  // ';'?
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_154[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';'.simple_stmt+ ';'?"));
            _res = s;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_154[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "';'.simple_stmt+ ';'?"));
    }
    { // block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_154[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block"));
        asdl_stmt_seq* block_var;
        if (
            (block_var = block_rule(p))  // block
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_154[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block"));
            _res = block_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_154[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "block"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_156: ',' type_param
static asdl_seq *
_loop0_156_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' type_param
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_156[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' type_param"));
        Token * _literal;
        type_param_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = type_param_rule(p))  // type_param
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_156[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' type_param"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_155: type_param _loop0_156
static asdl_seq *
_gather_155_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // type_param _loop0_156
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_155[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "type_param _loop0_156"));
        type_param_ty elem;
        asdl_seq * seq;
        if (
            (elem = type_param_rule(p))  // type_param
            &&
            (seq = _loop0_156_rule(p))  // _loop0_156
        )
        {
            D(fprintf(stderr, "%*c+ _gather_155[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "type_param _loop0_156"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_155[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "type_param _loop0_156"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_157: (',' expression)
static asdl_seq *
_loop1_157_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // (',' expression)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_157[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(',' expression)"));
        void *_tmp_374_var;
        while (
            (_tmp_374_var = _tmp_374_rule(p))  // ',' expression
        )
        {
            _res = _tmp_374_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_157[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(',' expression)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_158: (',' star_expression)
static asdl_seq *
_loop1_158_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // (',' star_expression)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_158[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(',' star_expression)"));
        void *_tmp_375_var;
        while (
            (_tmp_375_var = _tmp_375_rule(p))  // ',' star_expression
        )
        {
            _res = _tmp_375_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_158[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(',' star_expression)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_160: ',' star_named_expression
static asdl_seq *
_loop0_160_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' star_named_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_160[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' star_named_expression"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = star_named_expression_rule(p))  // star_named_expression
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_160[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' star_named_expression"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_159: star_named_expression _loop0_160
static asdl_seq *
_gather_159_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // star_named_expression _loop0_160
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_159[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_named_expression _loop0_160"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = star_named_expression_rule(p))  // star_named_expression
            &&
            (seq = _loop0_160_rule(p))  // _loop0_160
        )
        {
            D(fprintf(stderr, "%*c+ _gather_159[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_named_expression _loop0_160"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_159[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_named_expression _loop0_160"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_161: ('or' conjunction)
static asdl_seq *
_loop1_161_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ('or' conjunction)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_161[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('or' conjunction)"));
        void *_tmp_376_var;
        while (
            (_tmp_376_var = _tmp_376_rule(p))  // 'or' conjunction
        )
        {
            _res = _tmp_376_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_161[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('or' conjunction)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_162: ('and' inversion)
static asdl_seq *
_loop1_162_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ('and' inversion)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_162[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('and' inversion)"));
        void *_tmp_377_var;
        while (
            (_tmp_377_var = _tmp_377_rule(p))  // 'and' inversion
        )
        {
            _res = _tmp_377_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_162[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('and' inversion)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_163: compare_op_composition_pair
static asdl_seq *
_loop1_163_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // compare_op_composition_pair
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_163[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "compare_op_composition_pair"));
        CmpopExprPair* compare_op_composition_pair_var;
        while (
            (compare_op_composition_pair_var = compare_op_composition_pair_rule(p))  // compare_op_composition_pair
        )
        {
            _res = compare_op_composition_pair_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_163[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "compare_op_composition_pair"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_164: '!='
static void *
_tmp_164_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '!='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_164[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!='"));
        Token * tok;
        if (
            (tok = _PyPegen_expect_token(p, 28))  // token='!='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_164[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!='"));
            _res = _PyPegen_check_barry_as_flufl ( p , tok ) ? NULL : tok;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_164[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_165: '|>'
static void *
_tmp_165_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '|>'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_165[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|>'"));
        Token * t;
        if (
            (t = _PyPegen_expect_token(p, 55))  // token='|>'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_165[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|>'"));
            _res = ( ++ p -> subn , t );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_165[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|>'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_166: bitwise_or?
static void *
_tmp_166_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // bitwise_or?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_166[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_or?"));
        void *c;
        if (
            (c = bitwise_or_rule(p), !p->error_indicator)  // bitwise_or?
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_166[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwise_or?"));
            _res = ( - - p -> subn , c );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_166[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwise_or?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_167: compound_expr | tuplecomp | genexp
static void *
_tmp_167_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // compound_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_167[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "compound_expr"));
        expr_ty compound_expr_var;
        if (
            (compound_expr_var = compound_expr_rule(p))  // compound_expr
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_167[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "compound_expr"));
            _res = compound_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_167[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "compound_expr"));
    }
    { // tuplecomp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_167[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuplecomp"));
        expr_ty tuplecomp_var;
        if (
            (tuplecomp_var = tuplecomp_rule(p))  // tuplecomp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_167[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuplecomp"));
            _res = tuplecomp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_167[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "tuplecomp"));
    }
    { // genexp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_167[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "genexp"));
        expr_ty genexp_var;
        if (
            (genexp_var = genexp_rule(p))  // genexp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_167[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "genexp"));
            _res = genexp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_167[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "genexp"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_169: ',' (slice | starred_expression)
static asdl_seq *
_loop0_169_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' (slice | starred_expression)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_169[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (slice | starred_expression)"));
        Token * _literal;
        void *elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _tmp_378_rule(p))  // slice | starred_expression
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_169[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' (slice | starred_expression)"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_168: (slice | starred_expression) _loop0_169
static asdl_seq *
_gather_168_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // (slice | starred_expression) _loop0_169
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_168[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(slice | starred_expression) _loop0_169"));
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_378_rule(p))  // slice | starred_expression
            &&
            (seq = _loop0_169_rule(p))  // _loop0_169
        )
        {
            D(fprintf(stderr, "%*c+ _gather_168[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(slice | starred_expression) _loop0_169"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_168[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(slice | starred_expression) _loop0_169"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_170: ':' expression?
static void *
_tmp_170_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ':' expression?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_170[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' expression?"));
        Token * _literal;
        void *d;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
            &&
            (d = expression_rule(p), !p->error_indicator)  // expression?
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_170[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':' expression?"));
            _res = d;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_170[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':' expression?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_171: STRING | FSTRING_START
static void *
_tmp_171_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // STRING
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_171[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "STRING"));
        expr_ty string_var;
        if (
            (string_var = _PyPegen_string_token(p))  // STRING
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_171[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "STRING"));
            _res = string_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_171[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "STRING"));
    }
    { // FSTRING_START
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_171[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "FSTRING_START"));
        Token * fstring_start_var;
        if (
            (fstring_start_var = _PyPegen_expect_token(p, FSTRING_START))  // token='FSTRING_START'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_171[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "FSTRING_START"));
            _res = fstring_start_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_171[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "FSTRING_START"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_172: compound_expr | tuple | group | tuplecomp | genexp
static void *
_tmp_172_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // compound_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_172[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "compound_expr"));
        expr_ty compound_expr_var;
        if (
            (compound_expr_var = compound_expr_rule(p))  // compound_expr
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_172[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "compound_expr"));
            _res = compound_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_172[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "compound_expr"));
    }
    { // tuple
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_172[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuple"));
        expr_ty tuple_var;
        if (
            (tuple_var = tuple_rule(p))  // tuple
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_172[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuple"));
            _res = tuple_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_172[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "tuple"));
    }
    { // group
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_172[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "group"));
        expr_ty group_var;
        if (
            (group_var = group_rule(p))  // group
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_172[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "group"));
            _res = group_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_172[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "group"));
    }
    { // tuplecomp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_172[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuplecomp"));
        expr_ty tuplecomp_var;
        if (
            (tuplecomp_var = tuplecomp_rule(p))  // tuplecomp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_172[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuplecomp"));
            _res = tuplecomp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_172[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "tuplecomp"));
    }
    { // genexp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_172[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "genexp"));
        expr_ty genexp_var;
        if (
            (genexp_var = genexp_rule(p))  // genexp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_172[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "genexp"));
            _res = genexp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_172[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "genexp"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_173: list | listcomp
static void *
_tmp_173_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // list
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_173[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "list"));
        expr_ty list_var;
        if (
            (list_var = list_rule(p))  // list
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_173[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "list"));
            _res = list_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_173[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "list"));
    }
    { // listcomp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_173[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "listcomp"));
        expr_ty listcomp_var;
        if (
            (listcomp_var = listcomp_rule(p))  // listcomp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_173[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "listcomp"));
            _res = listcomp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_173[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "listcomp"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_174: dict | set | dictcomp | setcomp
static void *
_tmp_174_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // dict
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_174[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dict"));
        expr_ty dict_var;
        if (
            (dict_var = dict_rule(p))  // dict
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_174[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dict"));
            _res = dict_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_174[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "dict"));
    }
    { // set
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_174[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "set"));
        expr_ty set_var;
        if (
            (set_var = set_rule(p))  // set
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_174[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "set"));
            _res = set_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_174[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "set"));
    }
    { // dictcomp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_174[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dictcomp"));
        expr_ty dictcomp_var;
        if (
            (dictcomp_var = dictcomp_rule(p))  // dictcomp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_174[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dictcomp"));
            _res = dictcomp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_174[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "dictcomp"));
    }
    { // setcomp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_174[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "setcomp"));
        expr_ty setcomp_var;
        if (
            (setcomp_var = setcomp_rule(p))  // setcomp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_174[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "setcomp"));
            _res = setcomp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_174[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "setcomp"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_175: yield_expr | slice
static void *
_tmp_175_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // yield_expr
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_175[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "yield_expr"));
        expr_ty yield_expr_var;
        if (
            (yield_expr_var = yield_expr_rule(p))  // yield_expr
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_175[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "yield_expr"));
            _res = yield_expr_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_175[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "yield_expr"));
    }
    { // slice
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_175[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slice"));
        expr_ty slice_var;
        if (
            (slice_var = slice_rule(p))  // slice
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_175[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slice"));
            _res = slice_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_175[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "slice"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_176:
//     | &("def" | '@' | 'async') function_def_nonewline
//     | &('class' | '@') class_def_nonewline
//     | &"block" block_expr_nonewline
static void *
_tmp_176_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // &("def" | '@' | 'async') function_def_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_176[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&(\"def\" | '@' | 'async') function_def_nonewline"));
        stmt_ty function_def_nonewline_var;
        if (
            _PyPegen_lookahead(1, _tmp_379_rule, p)
            &&
            (function_def_nonewline_var = function_def_nonewline_rule(p))  // function_def_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_176[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&(\"def\" | '@' | 'async') function_def_nonewline"));
            _res = function_def_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_176[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&(\"def\" | '@' | 'async') function_def_nonewline"));
    }
    { // &('class' | '@') class_def_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_176[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('class' | '@') class_def_nonewline"));
        stmt_ty class_def_nonewline_var;
        if (
            _PyPegen_lookahead(1, _tmp_380_rule, p)
            &&
            (class_def_nonewline_var = class_def_nonewline_rule(p))  // class_def_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_176[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&('class' | '@') class_def_nonewline"));
            _res = class_def_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_176[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&('class' | '@') class_def_nonewline"));
    }
    { // &"block" block_expr_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_176[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"block\" block_expr_nonewline"));
        expr_ty block_expr_nonewline_var;
        if (
            _PyPegen_lookahead_with_string(1, _PyPegen_expect_soft_keyword, p, "block")
            &&
            (block_expr_nonewline_var = block_expr_nonewline_rule(p))  // block_expr_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_176[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "&\"block\" block_expr_nonewline"));
            _res = block_expr_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_176[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "&\"block\" block_expr_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_177: lambda_param_no_default
static asdl_seq *
_loop0_177_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_177[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_177[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_178: lambda_param_with_default
static asdl_seq *
_loop0_178_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_178[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_178[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_179: lambda_param_with_default
static asdl_seq *
_loop0_179_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_179[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_179[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_180: lambda_param_no_default
static asdl_seq *
_loop1_180_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_180[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_180[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_181: lambda_param_with_default
static asdl_seq *
_loop0_181_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_181[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_181[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_182: lambda_param_with_default
static asdl_seq *
_loop1_182_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_182[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_182[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_183: lambda_param_no_default
static asdl_seq *
_loop1_183_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_183[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_183[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_184: lambda_param_no_default
static asdl_seq *
_loop1_184_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_184[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_184[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_185: lambda_param_no_default
static asdl_seq *
_loop0_185_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_185[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_185[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_186: lambda_param_with_default
static asdl_seq *
_loop1_186_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_186[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_186[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_187: lambda_param_no_default
static asdl_seq *
_loop0_187_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_187[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_187[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_188: lambda_param_with_default
static asdl_seq *
_loop1_188_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_188[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_188[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_189: lambda_param_maybe_default
static asdl_seq *
_loop0_189_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_189[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
        NameDefaultPair* lambda_param_maybe_default_var;
        while (
            (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p))  // lambda_param_maybe_default
        )
        {
            _res = lambda_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_189[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_190: lambda_param_maybe_default
static asdl_seq *
_loop1_190_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_190[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
        NameDefaultPair* lambda_param_maybe_default_var;
        while (
            (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p))  // lambda_param_maybe_default
        )
        {
            _res = lambda_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_190[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_191: lambda_sum_param_no_default
static asdl_seq *
_loop0_191_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_191[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
        arg_ty lambda_sum_param_no_default_var;
        while (
            (lambda_sum_param_no_default_var = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
        )
        {
            _res = lambda_sum_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_191[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_192: lambda_sum_param_with_default
static asdl_seq *
_loop0_192_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_192[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
        NameDefaultPair* lambda_sum_param_with_default_var;
        while (
            (lambda_sum_param_with_default_var = lambda_sum_param_with_default_rule(p))  // lambda_sum_param_with_default
        )
        {
            _res = lambda_sum_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_192[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_193: lambda_sum_param_with_default
static asdl_seq *
_loop0_193_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_193[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
        NameDefaultPair* lambda_sum_param_with_default_var;
        while (
            (lambda_sum_param_with_default_var = lambda_sum_param_with_default_rule(p))  // lambda_sum_param_with_default
        )
        {
            _res = lambda_sum_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_193[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_194: lambda_sum_param_no_default
static asdl_seq *
_loop1_194_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_194[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
        arg_ty lambda_sum_param_no_default_var;
        while (
            (lambda_sum_param_no_default_var = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
        )
        {
            _res = lambda_sum_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_194[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_195: lambda_sum_param_with_default
static asdl_seq *
_loop0_195_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_195[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
        NameDefaultPair* lambda_sum_param_with_default_var;
        while (
            (lambda_sum_param_with_default_var = lambda_sum_param_with_default_rule(p))  // lambda_sum_param_with_default
        )
        {
            _res = lambda_sum_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_195[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_196: lambda_sum_param_with_default
static asdl_seq *
_loop1_196_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_196[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
        NameDefaultPair* lambda_sum_param_with_default_var;
        while (
            (lambda_sum_param_with_default_var = lambda_sum_param_with_default_rule(p))  // lambda_sum_param_with_default
        )
        {
            _res = lambda_sum_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_196[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_197: param_no_default
static asdl_seq *
_loop1_197_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_197[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_197[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_198: param_no_default
static asdl_seq *
_loop1_198_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_198[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_198[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_199: lambda_sum_param_no_default
static asdl_seq *
_loop0_199_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_199[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
        arg_ty lambda_sum_param_no_default_var;
        while (
            (lambda_sum_param_no_default_var = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
        )
        {
            _res = lambda_sum_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_199[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_200: lambda_sum_param_with_default
static asdl_seq *
_loop1_200_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_200[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
        NameDefaultPair* lambda_sum_param_with_default_var;
        while (
            (lambda_sum_param_with_default_var = lambda_sum_param_with_default_rule(p))  // lambda_sum_param_with_default
        )
        {
            _res = lambda_sum_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_200[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_201: lambda_sum_param_no_default
static asdl_seq *
_loop0_201_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_201[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
        arg_ty lambda_sum_param_no_default_var;
        while (
            (lambda_sum_param_no_default_var = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
        )
        {
            _res = lambda_sum_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_201[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_202: lambda_sum_param_with_default
static asdl_seq *
_loop1_202_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_202[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
        NameDefaultPair* lambda_sum_param_with_default_var;
        while (
            (lambda_sum_param_with_default_var = lambda_sum_param_with_default_rule(p))  // lambda_sum_param_with_default
        )
        {
            _res = lambda_sum_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_202[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_203: lambda_sum_param_maybe_default
static asdl_seq *
_loop0_203_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_203[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
        NameDefaultPair* lambda_sum_param_maybe_default_var;
        while (
            (lambda_sum_param_maybe_default_var = lambda_sum_param_maybe_default_rule(p))  // lambda_sum_param_maybe_default
        )
        {
            _res = lambda_sum_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_203[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_204: lambda_sum_param_maybe_default
static asdl_seq *
_loop0_204_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_204[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
        NameDefaultPair* lambda_sum_param_maybe_default_var;
        while (
            (lambda_sum_param_maybe_default_var = lambda_sum_param_maybe_default_rule(p))  // lambda_sum_param_maybe_default
        )
        {
            _res = lambda_sum_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_204[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_205: lambda_sum_param_maybe_default
static asdl_seq *
_loop1_205_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_205[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
        NameDefaultPair* lambda_sum_param_maybe_default_var;
        while (
            (lambda_sum_param_maybe_default_var = lambda_sum_param_maybe_default_rule(p))  // lambda_sum_param_maybe_default
        )
        {
            _res = lambda_sum_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_205[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_206: fstring_format_spec
static asdl_seq *
_loop0_206_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // fstring_format_spec
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_206[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "fstring_format_spec"));
        expr_ty fstring_format_spec_var;
        while (
            (fstring_format_spec_var = fstring_format_spec_rule(p))  // fstring_format_spec
        )
        {
            _res = fstring_format_spec_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_206[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "fstring_format_spec"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_207: (fstring | string)
static asdl_seq *
_loop1_207_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // (fstring | string)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_207[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(fstring | string)"));
        void *_tmp_381_var;
        while (
            (_tmp_381_var = _tmp_381_rule(p))  // fstring | string
        )
        {
            _res = _tmp_381_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_207[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(fstring | string)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_208: star_named_expression ',' star_named_expressions?
static void *
_tmp_208_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // star_named_expression ',' star_named_expressions?
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_208[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_named_expression ',' star_named_expressions?"));
        Token * _literal;
        expr_ty y;
        void *z;
        if (
            (y = star_named_expression_rule(p))  // star_named_expression
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (z = star_named_expressions_rule(p), !p->error_indicator)  // star_named_expressions?
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_208[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_named_expression ',' star_named_expressions?"));
            _res = _PyPegen_seq_insert_in_front ( p , y , z );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_208[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_named_expression ',' star_named_expressions?"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_210: ',' double_starred_kvpair
static asdl_seq *
_loop0_210_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' double_starred_kvpair
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_210[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' double_starred_kvpair"));
        Token * _literal;
        KeyValuePair* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = double_starred_kvpair_rule(p))  // double_starred_kvpair
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_210[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' double_starred_kvpair"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_209: double_starred_kvpair _loop0_210
static asdl_seq *
_gather_209_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // double_starred_kvpair _loop0_210
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_209[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "double_starred_kvpair _loop0_210"));
        KeyValuePair* elem;
        asdl_seq * seq;
        if (
            (elem = double_starred_kvpair_rule(p))  // double_starred_kvpair
            &&
            (seq = _loop0_210_rule(p))  // _loop0_210
        )
        {
            D(fprintf(stderr, "%*c+ _gather_209[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "double_starred_kvpair _loop0_210"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_209[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "double_starred_kvpair _loop0_210"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_211: for_if_clause
static asdl_seq *
_loop1_211_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // for_if_clause
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_211[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "for_if_clause"));
        comprehension_ty for_if_clause_var;
        while (
            (for_if_clause_var = for_if_clause_rule(p))  // for_if_clause
        )
        {
            _res = for_if_clause_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_211[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "for_if_clause"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_212: ('if' disjunction)
static asdl_seq *
_loop0_212_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ('if' disjunction)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_212[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('if' disjunction)"));
        void *_tmp_382_var;
        while (
            (_tmp_382_var = _tmp_382_rule(p))  // 'if' disjunction
        )
        {
            _res = _tmp_382_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_212[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('if' disjunction)"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_213: ('if' disjunction)
static asdl_seq *
_loop0_213_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ('if' disjunction)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_213[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('if' disjunction)"));
        void *_tmp_383_var;
        while (
            (_tmp_383_var = _tmp_383_rule(p))  // 'if' disjunction
        )
        {
            _res = _tmp_383_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_213[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('if' disjunction)"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_214: ('if' disjunction)
static asdl_seq *
_loop0_214_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ('if' disjunction)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_214[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "('if' disjunction)"));
        void *_tmp_384_var;
        while (
            (_tmp_384_var = _tmp_384_rule(p))  // 'if' disjunction
        )
        {
            _res = _tmp_384_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_214[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "('if' disjunction)"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_215: assignment_expression | expression !':='
static void *
_tmp_215_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // assignment_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_215[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_expression"));
        expr_ty assignment_expression_var;
        if (
            (assignment_expression_var = assignment_expression_rule(p))  // assignment_expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_215[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_expression"));
            _res = assignment_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_215[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "assignment_expression"));
    }
    { // expression !':='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_215[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression !':='"));
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 53)  // token=':='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_215[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression !':='"));
            _res = expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_215[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression !':='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_216: assignment_expression | expression !':='
static void *
_tmp_216_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // assignment_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_216[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_expression"));
        expr_ty assignment_expression_var;
        if (
            (assignment_expression_var = assignment_expression_rule(p))  // assignment_expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_216[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_expression"));
            _res = assignment_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_216[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "assignment_expression"));
    }
    { // expression !':='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_216[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression !':='"));
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 53)  // token=':='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_216[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression !':='"));
            _res = expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_216[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression !':='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_218:
//     | ',' (starred_expression | simple_slice | (assignment_expression | expression !':=') !'=')
static asdl_seq *
_loop0_218_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' (starred_expression | simple_slice | (assignment_expression | expression !':=') !'=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_218[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (starred_expression | simple_slice | (assignment_expression | expression !':=') !'=')"));
        Token * _literal;
        void *elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _tmp_385_rule(p))  // starred_expression | simple_slice | (assignment_expression | expression !':=') !'='
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_218[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' (starred_expression | simple_slice | (assignment_expression | expression !':=') !'=')"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_217:
//     | (starred_expression | simple_slice | (assignment_expression | expression !':=') !'=') _loop0_218
static asdl_seq *
_gather_217_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // (starred_expression | simple_slice | (assignment_expression | expression !':=') !'=') _loop0_218
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_217[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(starred_expression | simple_slice | (assignment_expression | expression !':=') !'=') _loop0_218"));
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_385_rule(p))  // starred_expression | simple_slice | (assignment_expression | expression !':=') !'='
            &&
            (seq = _loop0_218_rule(p))  // _loop0_218
        )
        {
            D(fprintf(stderr, "%*c+ _gather_217[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(starred_expression | simple_slice | (assignment_expression | expression !':=') !'=') _loop0_218"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_217[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(starred_expression | simple_slice | (assignment_expression | expression !':=') !'=') _loop0_218"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_219: ',' kwargs
static void *
_tmp_219_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' kwargs
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_219[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' kwargs"));
        Token * _literal;
        asdl_seq* k;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (k = kwargs_rule(p))  // kwargs
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_219[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' kwargs"));
            _res = k;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_219[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' kwargs"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_221: ',' kwarg_or_starred
static asdl_seq *
_loop0_221_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' kwarg_or_starred
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_221[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' kwarg_or_starred"));
        Token * _literal;
        KeywordOrStarred* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = kwarg_or_starred_rule(p))  // kwarg_or_starred
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_221[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' kwarg_or_starred"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_220: kwarg_or_starred _loop0_221
static asdl_seq *
_gather_220_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // kwarg_or_starred _loop0_221
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_220[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwarg_or_starred _loop0_221"));
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_starred_rule(p))  // kwarg_or_starred
            &&
            (seq = _loop0_221_rule(p))  // _loop0_221
        )
        {
            D(fprintf(stderr, "%*c+ _gather_220[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwarg_or_starred _loop0_221"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_220[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "kwarg_or_starred _loop0_221"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_223: ',' kwarg_or_double_starred
static asdl_seq *
_loop0_223_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' kwarg_or_double_starred
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_223[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' kwarg_or_double_starred"));
        Token * _literal;
        KeywordOrStarred* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = kwarg_or_double_starred_rule(p))  // kwarg_or_double_starred
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_223[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' kwarg_or_double_starred"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_222: kwarg_or_double_starred _loop0_223
static asdl_seq *
_gather_222_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // kwarg_or_double_starred _loop0_223
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_222[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwarg_or_double_starred _loop0_223"));
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_double_starred_rule(p))  // kwarg_or_double_starred
            &&
            (seq = _loop0_223_rule(p))  // _loop0_223
        )
        {
            D(fprintf(stderr, "%*c+ _gather_222[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwarg_or_double_starred _loop0_223"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_222[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "kwarg_or_double_starred _loop0_223"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_225: ',' kwarg_or_starred
static asdl_seq *
_loop0_225_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' kwarg_or_starred
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_225[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' kwarg_or_starred"));
        Token * _literal;
        KeywordOrStarred* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = kwarg_or_starred_rule(p))  // kwarg_or_starred
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_225[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' kwarg_or_starred"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_224: kwarg_or_starred _loop0_225
static asdl_seq *
_gather_224_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // kwarg_or_starred _loop0_225
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_224[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwarg_or_starred _loop0_225"));
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_starred_rule(p))  // kwarg_or_starred
            &&
            (seq = _loop0_225_rule(p))  // _loop0_225
        )
        {
            D(fprintf(stderr, "%*c+ _gather_224[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwarg_or_starred _loop0_225"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_224[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "kwarg_or_starred _loop0_225"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_227: ',' kwarg_or_double_starred
static asdl_seq *
_loop0_227_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' kwarg_or_double_starred
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_227[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' kwarg_or_double_starred"));
        Token * _literal;
        KeywordOrStarred* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = kwarg_or_double_starred_rule(p))  // kwarg_or_double_starred
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_227[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' kwarg_or_double_starred"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_226: kwarg_or_double_starred _loop0_227
static asdl_seq *
_gather_226_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // kwarg_or_double_starred _loop0_227
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_226[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwarg_or_double_starred _loop0_227"));
        KeywordOrStarred* elem;
        asdl_seq * seq;
        if (
            (elem = kwarg_or_double_starred_rule(p))  // kwarg_or_double_starred
            &&
            (seq = _loop0_227_rule(p))  // _loop0_227
        )
        {
            D(fprintf(stderr, "%*c+ _gather_226[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "kwarg_or_double_starred _loop0_227"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_226[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "kwarg_or_double_starred _loop0_227"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_228: simple_slice | expression
static void *
_tmp_228_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // simple_slice
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_228[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
        expr_ty simple_slice_var;
        if (
            (simple_slice_var = simple_slice_rule(p))  // simple_slice
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_228[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
            _res = simple_slice_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_228[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_slice"));
    }
    { // expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_228[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression"));
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_228[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression"));
            _res = expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_228[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_229: simple_slice | expression
static void *
_tmp_229_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // simple_slice
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_229[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
        expr_ty simple_slice_var;
        if (
            (simple_slice_var = simple_slice_rule(p))  // simple_slice
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_229[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
            _res = simple_slice_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_229[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_slice"));
    }
    { // expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_229[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression"));
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_229[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression"));
            _res = expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_229[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_230: (',' star_target)
static asdl_seq *
_loop0_230_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // (',' star_target)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_230[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(',' star_target)"));
        void *_tmp_386_var;
        while (
            (_tmp_386_var = _tmp_386_rule(p))  // ',' star_target
        )
        {
            _res = _tmp_386_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_230[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(',' star_target)"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_232: ',' star_target
static asdl_seq *
_loop0_232_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_232[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' star_target"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = star_target_rule(p))  // star_target
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_232[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' star_target"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_231: star_target _loop0_232
static asdl_seq *
_gather_231_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // star_target _loop0_232
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_231[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_target _loop0_232"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = star_target_rule(p))  // star_target
            &&
            (seq = _loop0_232_rule(p))  // _loop0_232
        )
        {
            D(fprintf(stderr, "%*c+ _gather_231[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_target _loop0_232"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_231[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_target _loop0_232"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_233: (',' star_target)
static asdl_seq *
_loop1_233_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // (',' star_target)
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_233[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(',' star_target)"));
        void *_tmp_387_var;
        while (
            (_tmp_387_var = _tmp_387_rule(p))  // ',' star_target
        )
        {
            _res = _tmp_387_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_233[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(',' star_target)"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_234: !'*' star_target
static void *
_tmp_234_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // !'*' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_234[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!'*' star_target"));
        expr_ty star_target_var;
        if (
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 16)  // token='*'
            &&
            (star_target_var = star_target_rule(p))  // star_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_234[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "!'*' star_target"));
            _res = star_target_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_234[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "!'*' star_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_235: genexp | tuplecomp
static void *
_tmp_235_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // genexp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_235[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "genexp"));
        expr_ty genexp_var;
        if (
            (genexp_var = genexp_rule(p))  // genexp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_235[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "genexp"));
            _res = genexp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_235[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "genexp"));
    }
    { // tuplecomp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_235[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuplecomp"));
        expr_ty tuplecomp_var;
        if (
            (tuplecomp_var = tuplecomp_rule(p))  // tuplecomp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_235[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuplecomp"));
            _res = tuplecomp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_235[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "tuplecomp"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_237: ',' del_target
static asdl_seq *
_loop0_237_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' del_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_237[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' del_target"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = del_target_rule(p))  // del_target
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_237[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' del_target"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_236: del_target _loop0_237
static asdl_seq *
_gather_236_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // del_target _loop0_237
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_236[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "del_target _loop0_237"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = del_target_rule(p))  // del_target
            &&
            (seq = _loop0_237_rule(p))  // _loop0_237
        )
        {
            D(fprintf(stderr, "%*c+ _gather_236[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "del_target _loop0_237"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_236[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "del_target _loop0_237"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_239: ',' expression
static asdl_seq *
_loop0_239_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_239[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' expression"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = expression_rule(p))  // expression
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_239[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' expression"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_238: expression _loop0_239
static asdl_seq *
_gather_238_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // expression _loop0_239
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_238[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression _loop0_239"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = expression_rule(p))  // expression
            &&
            (seq = _loop0_239_rule(p))  // _loop0_239
        )
        {
            D(fprintf(stderr, "%*c+ _gather_238[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression _loop0_239"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_238[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression _loop0_239"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_241: ',' expression
static asdl_seq *
_loop0_241_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_241[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' expression"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = expression_rule(p))  // expression
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_241[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' expression"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_240: expression _loop0_241
static asdl_seq *
_gather_240_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // expression _loop0_241
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_240[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression _loop0_241"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = expression_rule(p))  // expression
            &&
            (seq = _loop0_241_rule(p))  // _loop0_241
        )
        {
            D(fprintf(stderr, "%*c+ _gather_240[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression _loop0_241"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_240[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression _loop0_241"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_243: ',' expression
static asdl_seq *
_loop0_243_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_243[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' expression"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = expression_rule(p))  // expression
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_243[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' expression"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_242: expression _loop0_243
static asdl_seq *
_gather_242_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // expression _loop0_243
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_242[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression _loop0_243"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = expression_rule(p))  // expression
            &&
            (seq = _loop0_243_rule(p))  // _loop0_243
        )
        {
            D(fprintf(stderr, "%*c+ _gather_242[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression _loop0_243"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_242[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression _loop0_243"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_245: ',' expression
static asdl_seq *
_loop0_245_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_245[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' expression"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = expression_rule(p))  // expression
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_245[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' expression"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_244: expression _loop0_245
static asdl_seq *
_gather_244_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // expression _loop0_245
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_244[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression _loop0_245"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = expression_rule(p))  // expression
            &&
            (seq = _loop0_245_rule(p))  // _loop0_245
        )
        {
            D(fprintf(stderr, "%*c+ _gather_244[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression _loop0_245"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_244[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression _loop0_245"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_246: NEWLINE INDENT
static void *
_tmp_246_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // NEWLINE INDENT
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_246[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE INDENT"));
        Token * indent_var;
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
            &&
            (indent_var = _PyPegen_expect_token(p, INDENT))  // token='INDENT'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_246[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE INDENT"));
            _res = _PyPegen_dummy_name(p, newline_var, indent_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_246[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NEWLINE INDENT"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_247: args | expression for_if_clauses
static void *
_tmp_247_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // args
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_247[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args"));
        expr_ty args_var;
        if (
            (args_var = args_rule(p))  // args
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_247[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args"));
            _res = args_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_247[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "args"));
    }
    { // expression for_if_clauses
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_247[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression for_if_clauses"));
        expr_ty expression_var;
        asdl_comprehension_seq* for_if_clauses_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (for_if_clauses_var = for_if_clauses_rule(p))  // for_if_clauses
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_247[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression for_if_clauses"));
            _res = _PyPegen_dummy_name(p, expression_var, for_if_clauses_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_247[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression for_if_clauses"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_248: args ','
static void *
_tmp_248_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // args ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_248[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args ','"));
        Token * _literal;
        expr_ty args_var;
        if (
            (args_var = args_rule(p))  // args
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_248[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "args ','"));
            _res = _PyPegen_dummy_name(p, args_var, _literal);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_248[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "args ','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_249: ',' | ')'
static void *
_tmp_249_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_249[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_249[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_249[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    { // ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_249[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_249[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_249[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_250: 'True' | 'False' | 'None'
static void *
_tmp_250_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'True'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_250[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 714))  // token='True'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_250[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_250[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'True'"));
    }
    { // 'False'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_250[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 716))  // token='False'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_250[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_250[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'False'"));
    }
    { // 'None'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_250[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 715))  // token='None'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_250[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_250[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'None'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_251: NAME '='
static void *
_tmp_251_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // NAME '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_251[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '='"));
        Token * _literal;
        expr_ty name_var;
        if (
            (name_var = _PyPegen_name_token(p))  // NAME
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_251[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME '='"));
            _res = _PyPegen_dummy_name(p, name_var, _literal);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_251[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_252: NAME STRING | SOFT_KEYWORD
static void *
_tmp_252_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // NAME STRING
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_252[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME STRING"));
        expr_ty name_var;
        expr_ty string_var;
        if (
            (name_var = _PyPegen_name_token(p))  // NAME
            &&
            (string_var = _PyPegen_string_token(p))  // STRING
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_252[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NAME STRING"));
            _res = _PyPegen_dummy_name(p, name_var, string_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_252[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NAME STRING"));
    }
    { // SOFT_KEYWORD
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_252[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "SOFT_KEYWORD"));
        expr_ty soft_keyword_var;
        if (
            (soft_keyword_var = _PyPegen_soft_keyword_token(p))  // SOFT_KEYWORD
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_252[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "SOFT_KEYWORD"));
            _res = soft_keyword_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_252[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "SOFT_KEYWORD"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_253: 'else' | ':'
static void *
_tmp_253_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'else'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_253[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'else'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 775))  // token='else'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_253[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'else'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_253[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'else'"));
    }
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_253[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_253[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_253[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_254: FSTRING_MIDDLE | fstring_replacement_field
static void *
_tmp_254_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // FSTRING_MIDDLE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_254[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "FSTRING_MIDDLE"));
        Token * fstring_middle_var;
        if (
            (fstring_middle_var = _PyPegen_expect_token(p, FSTRING_MIDDLE))  // token='FSTRING_MIDDLE'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_254[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "FSTRING_MIDDLE"));
            _res = fstring_middle_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_254[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "FSTRING_MIDDLE"));
    }
    { // fstring_replacement_field
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_254[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "fstring_replacement_field"));
        expr_ty fstring_replacement_field_var;
        if (
            (fstring_replacement_field_var = fstring_replacement_field_rule(p))  // fstring_replacement_field
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_254[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "fstring_replacement_field"));
            _res = fstring_replacement_field_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_254[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "fstring_replacement_field"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_255: '=' | ':='
static void *
_tmp_255_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_255[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_255[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'='"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_255[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'='"));
    }
    { // ':='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_255[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 53))  // token=':='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_255[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':='"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_255[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_256: list | tuple | genexp | 'True' | 'None' | 'False'
static void *
_tmp_256_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // list
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_256[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "list"));
        expr_ty list_var;
        if (
            (list_var = list_rule(p))  // list
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_256[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "list"));
            _res = list_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_256[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "list"));
    }
    { // tuple
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_256[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuple"));
        expr_ty tuple_var;
        if (
            (tuple_var = tuple_rule(p))  // tuple
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_256[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "tuple"));
            _res = tuple_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_256[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "tuple"));
    }
    { // genexp
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_256[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "genexp"));
        expr_ty genexp_var;
        if (
            (genexp_var = genexp_rule(p))  // genexp
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_256[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "genexp"));
            _res = genexp_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_256[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "genexp"));
    }
    { // 'True'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_256[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 714))  // token='True'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_256[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'True'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_256[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'True'"));
    }
    { // 'None'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_256[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 715))  // token='None'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_256[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_256[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'None'"));
    }
    { // 'False'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_256[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 716))  // token='False'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_256[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'False'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_256[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'False'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_257: '=' | ':='
static void *
_tmp_257_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_257[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_257[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'='"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_257[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'='"));
    }
    { // ':='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_257[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 53))  // token=':='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_257[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':='"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_257[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_258: star_named_expressions
static asdl_seq *
_loop0_258_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // star_named_expressions
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_258[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_named_expressions"));
        asdl_expr_seq* star_named_expressions_var;
        while (
            (star_named_expressions_var = star_named_expressions_rule(p))  // star_named_expressions
        )
        {
            _res = star_named_expressions_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_258[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_named_expressions"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_259: (star_targets '=')
static asdl_seq *
_loop0_259_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // (star_targets '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_259[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(star_targets '=')"));
        void *_tmp_388_var;
        while (
            (_tmp_388_var = _tmp_388_rule(p))  // star_targets '='
        )
        {
            _res = _tmp_388_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_259[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(star_targets '=')"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_260: (star_targets '=')
static asdl_seq *
_loop0_260_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // (star_targets '=')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_260[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(star_targets '=')"));
        void *_tmp_389_var;
        while (
            (_tmp_389_var = _tmp_389_rule(p))  // star_targets '='
        )
        {
            _res = _tmp_389_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_260[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(star_targets '=')"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_261: top_rhs | block_expr_nonewline
static void *
_tmp_261_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // top_rhs
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_261[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "top_rhs"));
        expr_ty top_rhs_var;
        if (
            (top_rhs_var = top_rhs_rule(p))  // top_rhs
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_261[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "top_rhs"));
            _res = top_rhs_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_261[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "top_rhs"));
    }
    { // block_expr_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_261[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block_expr_nonewline"));
        expr_ty block_expr_nonewline_var;
        if (
            (block_expr_nonewline_var = block_expr_nonewline_rule(p))  // block_expr_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_261[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block_expr_nonewline"));
            _res = block_expr_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_261[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "block_expr_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_262: '[' | '(' | '{'
static void *
_tmp_262_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '['
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_262[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'['"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_262[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'['"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_262[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'['"));
    }
    { // '('
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_262[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'('"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_262[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'('"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_262[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'('"));
    }
    { // '{'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_262[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_262[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_262[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_263: '[' | '{'
static void *
_tmp_263_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '['
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_263[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'['"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_263[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'['"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_263[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'['"));
    }
    { // '{'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_263[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_263[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_263[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_264: '[' | '{'
static void *
_tmp_264_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '['
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_264[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'['"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 9))  // token='['
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_264[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'['"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_264[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'['"));
    }
    { // '{'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_264[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 25))  // token='{'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_264[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'{'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_264[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'{'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_265: slash_no_default | slash_with_default
static void *
_tmp_265_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // slash_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_265[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_no_default"));
        asdl_arg_seq* slash_no_default_var;
        if (
            (slash_no_default_var = slash_no_default_rule(p))  // slash_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_265[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_no_default"));
            _res = slash_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_265[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "slash_no_default"));
    }
    { // slash_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_265[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_with_default"));
        SlashWithDefault* slash_with_default_var;
        if (
            (slash_with_default_var = slash_with_default_rule(p))  // slash_with_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_265[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_with_default"));
            _res = slash_with_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_265[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "slash_with_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_266: param_maybe_default
static asdl_seq *
_loop0_266_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_266[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_maybe_default"));
        NameDefaultPair* param_maybe_default_var;
        while (
            (param_maybe_default_var = param_maybe_default_rule(p))  // param_maybe_default
        )
        {
            _res = param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_266[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_267: param_no_default
static asdl_seq *
_loop0_267_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_267[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_267[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_268: param_no_default
static asdl_seq *
_loop0_268_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_268[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_268[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_269: param_no_default
static asdl_seq *
_loop1_269_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_269[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        while (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            _res = param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_269[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_270: slash_no_default | slash_with_default
static void *
_tmp_270_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // slash_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_270[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_no_default"));
        asdl_arg_seq* slash_no_default_var;
        if (
            (slash_no_default_var = slash_no_default_rule(p))  // slash_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_270[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_no_default"));
            _res = slash_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_270[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "slash_no_default"));
    }
    { // slash_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_270[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_with_default"));
        SlashWithDefault* slash_with_default_var;
        if (
            (slash_with_default_var = slash_with_default_rule(p))  // slash_with_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_270[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slash_with_default"));
            _res = slash_with_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_270[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "slash_with_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_271: param_maybe_default
static asdl_seq *
_loop0_271_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_271[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_maybe_default"));
        NameDefaultPair* param_maybe_default_var;
        while (
            (param_maybe_default_var = param_maybe_default_rule(p))  // param_maybe_default
        )
        {
            _res = param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_271[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_272: ',' | param_no_default
static void *
_tmp_272_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_272[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_272[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_272[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_272[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        if (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_272[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
            _res = param_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_272[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_273: param_maybe_default
static asdl_seq *
_loop0_273_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_273[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_maybe_default"));
        NameDefaultPair* param_maybe_default_var;
        while (
            (param_maybe_default_var = param_maybe_default_rule(p))  // param_maybe_default
        )
        {
            _res = param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_273[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_274: param_maybe_default
static asdl_seq *
_loop1_274_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_274[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_maybe_default"));
        NameDefaultPair* param_maybe_default_var;
        while (
            (param_maybe_default_var = param_maybe_default_rule(p))  // param_maybe_default
        )
        {
            _res = param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_274[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_maybe_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_275: ')' | ','
static void *
_tmp_275_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_275[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_275[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_275[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "')'"));
    }
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_275[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_275[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_275[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_276: '|' | ','
static void *
_tmp_276_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '|'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_276[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 18))  // token='|'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_276[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_276[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|'"));
    }
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_276[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_276[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_276[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_277: ')' | ',' (')' | '**')
static void *
_tmp_277_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_277[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_277[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_277[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "')'"));
    }
    { // ',' (')' | '**')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_277[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (')' | '**')"));
        Token * _literal;
        void *_tmp_390_var;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_tmp_390_var = _tmp_390_rule(p))  // ')' | '**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_277[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (')' | '**')"));
            _res = _PyPegen_dummy_name(p, _literal, _tmp_390_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_277[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' (')' | '**')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_278: param_no_default | ','
static void *
_tmp_278_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_278[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        if (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_278[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
            _res = param_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_278[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_278[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_278[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_278[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_279: param_maybe_default
static asdl_seq *
_loop0_279_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_279[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_maybe_default"));
        NameDefaultPair* param_maybe_default_var;
        while (
            (param_maybe_default_var = param_maybe_default_rule(p))  // param_maybe_default
        )
        {
            _res = param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_279[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_280: param_no_default | ','
static void *
_tmp_280_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_280[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
        arg_ty param_no_default_var;
        if (
            (param_no_default_var = param_no_default_rule(p))  // param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_280[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_no_default"));
            _res = param_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_280[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_no_default"));
    }
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_280[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_280[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_280[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_281: '*' | '**' | '/'
static void *
_tmp_281_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '*'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_281[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_281[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_281[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*'"));
    }
    { // '**'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_281[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_281[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_281[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**'"));
    }
    { // '/'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_281[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'/'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_281[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'/'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_281[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'/'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop1_282: param_with_default
static asdl_seq *
_loop1_282_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_282[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "param_with_default"));
        NameDefaultPair* param_with_default_var;
        while (
            (param_with_default_var = param_with_default_rule(p))  // param_with_default
        )
        {
            _res = param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_282[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_283: lambda_slash_no_default | lambda_slash_with_default
static void *
_tmp_283_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_slash_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_283[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_no_default"));
        asdl_arg_seq* lambda_slash_no_default_var;
        if (
            (lambda_slash_no_default_var = lambda_slash_no_default_rule(p))  // lambda_slash_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_283[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_no_default"));
            _res = lambda_slash_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_283[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_slash_no_default"));
    }
    { // lambda_slash_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_283[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_with_default"));
        SlashWithDefault* lambda_slash_with_default_var;
        if (
            (lambda_slash_with_default_var = lambda_slash_with_default_rule(p))  // lambda_slash_with_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_283[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_with_default"));
            _res = lambda_slash_with_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_283[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_slash_with_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_284: lambda_param_maybe_default
static asdl_seq *
_loop0_284_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_284[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
        NameDefaultPair* lambda_param_maybe_default_var;
        while (
            (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p))  // lambda_param_maybe_default
        )
        {
            _res = lambda_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_284[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_285: lambda_param_no_default
static asdl_seq *
_loop0_285_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_285[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_285[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_286: lambda_param_no_default
static asdl_seq *
_loop0_286_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_286[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        while (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            _res = lambda_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_286[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_288: ',' lambda_param
static asdl_seq *
_loop0_288_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' lambda_param
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_288[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' lambda_param"));
        Token * _literal;
        arg_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = lambda_param_rule(p))  // lambda_param
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_288[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' lambda_param"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_287: lambda_param _loop0_288
static asdl_seq *
_gather_287_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // lambda_param _loop0_288
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_287[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param _loop0_288"));
        arg_ty elem;
        asdl_seq * seq;
        if (
            (elem = lambda_param_rule(p))  // lambda_param
            &&
            (seq = _loop0_288_rule(p))  // _loop0_288
        )
        {
            D(fprintf(stderr, "%*c+ _gather_287[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param _loop0_288"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_287[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param _loop0_288"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_289: lambda_slash_no_default | lambda_slash_with_default
static void *
_tmp_289_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_slash_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_289[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_no_default"));
        asdl_arg_seq* lambda_slash_no_default_var;
        if (
            (lambda_slash_no_default_var = lambda_slash_no_default_rule(p))  // lambda_slash_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_289[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_no_default"));
            _res = lambda_slash_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_289[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_slash_no_default"));
    }
    { // lambda_slash_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_289[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_with_default"));
        SlashWithDefault* lambda_slash_with_default_var;
        if (
            (lambda_slash_with_default_var = lambda_slash_with_default_rule(p))  // lambda_slash_with_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_289[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_slash_with_default"));
            _res = lambda_slash_with_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_289[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_slash_with_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_290: lambda_param_maybe_default
static asdl_seq *
_loop0_290_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_290[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
        NameDefaultPair* lambda_param_maybe_default_var;
        while (
            (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p))  // lambda_param_maybe_default
        )
        {
            _res = lambda_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_290[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_291: ',' | lambda_param_no_default
static void *
_tmp_291_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_291[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_291[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_291[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_291[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        if (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_291[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
            _res = lambda_param_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_291[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_292: lambda_param_maybe_default
static asdl_seq *
_loop0_292_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_292[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
        NameDefaultPair* lambda_param_maybe_default_var;
        while (
            (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p))  // lambda_param_maybe_default
        )
        {
            _res = lambda_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_292[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_293: lambda_param_maybe_default
static asdl_seq *
_loop1_293_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_293[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
        NameDefaultPair* lambda_param_maybe_default_var;
        while (
            (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p))  // lambda_param_maybe_default
        )
        {
            _res = lambda_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_293[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_294: lambda_param_with_default
static asdl_seq *
_loop1_294_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_294[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
        NameDefaultPair* lambda_param_with_default_var;
        while (
            (lambda_param_with_default_var = lambda_param_with_default_rule(p))  // lambda_param_with_default
        )
        {
            _res = lambda_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_294[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_295: ':' | ',' (':' | '**')
static void *
_tmp_295_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_295[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_295[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_295[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':'"));
    }
    { // ',' (':' | '**')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_295[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (':' | '**')"));
        Token * _literal;
        void *_tmp_391_var;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_tmp_391_var = _tmp_391_rule(p))  // ':' | '**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_295[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (':' | '**')"));
            _res = _PyPegen_dummy_name(p, _literal, _tmp_391_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_295[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' (':' | '**')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_296: lambda_param_no_default | ','
static void *
_tmp_296_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_296[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        if (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_296[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
            _res = lambda_param_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_296[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
    }
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_296[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_296[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_296[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_297: lambda_param_maybe_default
static asdl_seq *
_loop0_297_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_297[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
        NameDefaultPair* lambda_param_maybe_default_var;
        while (
            (lambda_param_maybe_default_var = lambda_param_maybe_default_rule(p))  // lambda_param_maybe_default
        )
        {
            _res = lambda_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_297[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_298: lambda_param_no_default | ','
static void *
_tmp_298_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_298[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
        arg_ty lambda_param_no_default_var;
        if (
            (lambda_param_no_default_var = lambda_param_no_default_rule(p))  // lambda_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_298[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
            _res = lambda_param_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_298[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param_no_default"));
    }
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_298[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_298[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_298[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_299: '*' | '**' | '/'
static void *
_tmp_299_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '*'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_299[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 16))  // token='*'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_299[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'*'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_299[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'*'"));
    }
    { // '**'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_299[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_299[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_299[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**'"));
    }
    { // '/'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_299[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'/'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 17))  // token='/'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_299[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'/'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_299[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'/'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_300: lambda_sum_slash_no_default | lambda_sum_slash_with_default
static void *
_tmp_300_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_sum_slash_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_300[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default"));
        asdl_arg_seq* lambda_sum_slash_no_default_var;
        if (
            (lambda_sum_slash_no_default_var = lambda_sum_slash_no_default_rule(p))  // lambda_sum_slash_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_300[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default"));
            _res = lambda_sum_slash_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_300[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default"));
    }
    { // lambda_sum_slash_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_300[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default"));
        SlashWithDefault* lambda_sum_slash_with_default_var;
        if (
            (lambda_sum_slash_with_default_var = lambda_sum_slash_with_default_rule(p))  // lambda_sum_slash_with_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_300[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default"));
            _res = lambda_sum_slash_with_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_300[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_301: lambda_sum_param_maybe_default
static asdl_seq *
_loop0_301_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_301[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
        NameDefaultPair* lambda_sum_param_maybe_default_var;
        while (
            (lambda_sum_param_maybe_default_var = lambda_sum_param_maybe_default_rule(p))  // lambda_sum_param_maybe_default
        )
        {
            _res = lambda_sum_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_301[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_302: lambda_sum_param_no_default
static asdl_seq *
_loop0_302_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_302[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
        arg_ty lambda_sum_param_no_default_var;
        while (
            (lambda_sum_param_no_default_var = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
        )
        {
            _res = lambda_sum_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_302[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_303: lambda_sum_param_no_default
static asdl_seq *
_loop0_303_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_303[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
        arg_ty lambda_sum_param_no_default_var;
        while (
            (lambda_sum_param_no_default_var = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
        )
        {
            _res = lambda_sum_param_no_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_303[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop0_305: ',' lambda_param
static asdl_seq *
_loop0_305_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' lambda_param
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_305[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' lambda_param"));
        Token * _literal;
        arg_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = lambda_param_rule(p))  // lambda_param
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_305[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' lambda_param"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_304: lambda_param _loop0_305
static asdl_seq *
_gather_304_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // lambda_param _loop0_305
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_304[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param _loop0_305"));
        arg_ty elem;
        asdl_seq * seq;
        if (
            (elem = lambda_param_rule(p))  // lambda_param
            &&
            (seq = _loop0_305_rule(p))  // _loop0_305
        )
        {
            D(fprintf(stderr, "%*c+ _gather_304[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_param _loop0_305"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_304[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_param _loop0_305"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_306: lambda_sum_slash_no_default | lambda_sum_slash_with_default
static void *
_tmp_306_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_sum_slash_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_306[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default"));
        asdl_arg_seq* lambda_sum_slash_no_default_var;
        if (
            (lambda_sum_slash_no_default_var = lambda_sum_slash_no_default_rule(p))  // lambda_sum_slash_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_306[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default"));
            _res = lambda_sum_slash_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_306[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_slash_no_default"));
    }
    { // lambda_sum_slash_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_306[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default"));
        SlashWithDefault* lambda_sum_slash_with_default_var;
        if (
            (lambda_sum_slash_with_default_var = lambda_sum_slash_with_default_rule(p))  // lambda_sum_slash_with_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_306[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default"));
            _res = lambda_sum_slash_with_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_306[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_slash_with_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_307: lambda_sum_param_maybe_default
static asdl_seq *
_loop0_307_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_307[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
        NameDefaultPair* lambda_sum_param_maybe_default_var;
        while (
            (lambda_sum_param_maybe_default_var = lambda_sum_param_maybe_default_rule(p))  // lambda_sum_param_maybe_default
        )
        {
            _res = lambda_sum_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_307[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_308: ',' | lambda_sum_param_no_default
static void *
_tmp_308_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_308[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_308[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_308[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    { // lambda_sum_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_308[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
        arg_ty lambda_sum_param_no_default_var;
        if (
            (lambda_sum_param_no_default_var = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_308[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
            _res = lambda_sum_param_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_308[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_309: lambda_sum_param_maybe_default
static asdl_seq *
_loop0_309_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_309[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
        NameDefaultPair* lambda_sum_param_maybe_default_var;
        while (
            (lambda_sum_param_maybe_default_var = lambda_sum_param_maybe_default_rule(p))  // lambda_sum_param_maybe_default
        )
        {
            _res = lambda_sum_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_309[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_310: lambda_sum_param_maybe_default
static asdl_seq *
_loop1_310_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_310[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
        NameDefaultPair* lambda_sum_param_maybe_default_var;
        while (
            (lambda_sum_param_maybe_default_var = lambda_sum_param_maybe_default_rule(p))  // lambda_sum_param_maybe_default
        )
        {
            _res = lambda_sum_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_310[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_311: lambda_sum_param_with_default
static asdl_seq *
_loop1_311_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_with_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_311[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
        NameDefaultPair* lambda_sum_param_with_default_var;
        while (
            (lambda_sum_param_with_default_var = lambda_sum_param_with_default_rule(p))  // lambda_sum_param_with_default
        )
        {
            _res = lambda_sum_param_with_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_311[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_with_default"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_312: '|' | ',' ('|' | '**')
static void *
_tmp_312_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '|'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_312[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 18))  // token='|'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_312[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_312[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|'"));
    }
    { // ',' ('|' | '**')
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_312[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' ('|' | '**')"));
        Token * _literal;
        void *_tmp_392_var;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (_tmp_392_var = _tmp_392_rule(p))  // '|' | '**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_312[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' ('|' | '**')"));
            _res = _PyPegen_dummy_name(p, _literal, _tmp_392_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_312[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' ('|' | '**')"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_313: lambda_sum_param_no_default | ','
static void *
_tmp_313_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_sum_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_313[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
        arg_ty lambda_sum_param_no_default_var;
        if (
            (lambda_sum_param_no_default_var = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_313[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
            _res = lambda_sum_param_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_313[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
    }
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_313[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_313[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_313[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_314: lambda_sum_param_maybe_default
static asdl_seq *
_loop0_314_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // lambda_sum_param_maybe_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_314[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
        NameDefaultPair* lambda_sum_param_maybe_default_var;
        while (
            (lambda_sum_param_maybe_default_var = lambda_sum_param_maybe_default_rule(p))  // lambda_sum_param_maybe_default
        )
        {
            _res = lambda_sum_param_maybe_default_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_314[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_maybe_default"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_315: lambda_sum_param_no_default | ','
static void *
_tmp_315_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // lambda_sum_param_no_default
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_315[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
        arg_ty lambda_sum_param_no_default_var;
        if (
            (lambda_sum_param_no_default_var = lambda_sum_param_no_default_rule(p))  // lambda_sum_param_no_default
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_315[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
            _res = lambda_sum_param_no_default_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_315[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "lambda_sum_param_no_default"));
    }
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_315[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_315[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_315[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_316: ',' | ')' | ':'
static void *
_tmp_316_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_316[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_316[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_316[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    { // ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_316[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_316[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_316[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "')'"));
    }
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_316[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_316[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_316[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_318: ',' dotted_name
static asdl_seq *
_loop0_318_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' dotted_name
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_318[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' dotted_name"));
        Token * _literal;
        expr_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = dotted_name_rule(p))  // dotted_name
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_318[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' dotted_name"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_317: dotted_name _loop0_318
static asdl_seq *
_gather_317_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // dotted_name _loop0_318
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_317[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dotted_name _loop0_318"));
        expr_ty elem;
        asdl_seq * seq;
        if (
            (elem = dotted_name_rule(p))  // dotted_name
            &&
            (seq = _loop0_318_rule(p))  // _loop0_318
        )
        {
            D(fprintf(stderr, "%*c+ _gather_317[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "dotted_name _loop0_318"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_317[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "dotted_name _loop0_318"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_320: ',' (expression ['as' star_target])
static asdl_seq *
_loop0_320_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' (expression ['as' star_target])
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_320[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (expression ['as' star_target])"));
        Token * _literal;
        void *elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _tmp_393_rule(p))  // expression ['as' star_target]
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_320[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' (expression ['as' star_target])"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_319: (expression ['as' star_target]) _loop0_320
static asdl_seq *
_gather_319_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // (expression ['as' star_target]) _loop0_320
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_319[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(expression ['as' star_target]) _loop0_320"));
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_393_rule(p))  // expression ['as' star_target]
            &&
            (seq = _loop0_320_rule(p))  // _loop0_320
        )
        {
            D(fprintf(stderr, "%*c+ _gather_319[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(expression ['as' star_target]) _loop0_320"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_319[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(expression ['as' star_target]) _loop0_320"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_322: ',' (expressions ['as' star_target])
static asdl_seq *
_loop0_322_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' (expressions ['as' star_target])
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_322[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (expressions ['as' star_target])"));
        Token * _literal;
        void *elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _tmp_394_rule(p))  // expressions ['as' star_target]
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_322[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' (expressions ['as' star_target])"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_321: (expressions ['as' star_target]) _loop0_322
static asdl_seq *
_gather_321_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // (expressions ['as' star_target]) _loop0_322
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_321[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(expressions ['as' star_target]) _loop0_322"));
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_394_rule(p))  // expressions ['as' star_target]
            &&
            (seq = _loop0_322_rule(p))  // _loop0_322
        )
        {
            D(fprintf(stderr, "%*c+ _gather_321[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(expressions ['as' star_target]) _loop0_322"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_321[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(expressions ['as' star_target]) _loop0_322"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_324: ',' (expression ['as' star_target])
static asdl_seq *
_loop0_324_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' (expression ['as' star_target])
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_324[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (expression ['as' star_target])"));
        Token * _literal;
        void *elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _tmp_395_rule(p))  // expression ['as' star_target]
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_324[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' (expression ['as' star_target])"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_323: (expression ['as' star_target]) _loop0_324
static asdl_seq *
_gather_323_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // (expression ['as' star_target]) _loop0_324
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_323[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(expression ['as' star_target]) _loop0_324"));
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_395_rule(p))  // expression ['as' star_target]
            &&
            (seq = _loop0_324_rule(p))  // _loop0_324
        )
        {
            D(fprintf(stderr, "%*c+ _gather_323[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(expression ['as' star_target]) _loop0_324"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_323[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(expression ['as' star_target]) _loop0_324"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_326: ',' (expressions ['as' star_target])
static asdl_seq *
_loop0_326_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' (expressions ['as' star_target])
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_326[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' (expressions ['as' star_target])"));
        Token * _literal;
        void *elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = _tmp_396_rule(p))  // expressions ['as' star_target]
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_326[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' (expressions ['as' star_target])"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_325: (expressions ['as' star_target]) _loop0_326
static asdl_seq *
_gather_325_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // (expressions ['as' star_target]) _loop0_326
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_325[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(expressions ['as' star_target]) _loop0_326"));
        void *elem;
        asdl_seq * seq;
        if (
            (elem = _tmp_396_rule(p))  // expressions ['as' star_target]
            &&
            (seq = _loop0_326_rule(p))  // _loop0_326
        )
        {
            D(fprintf(stderr, "%*c+ _gather_325[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(expressions ['as' star_target]) _loop0_326"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_325[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(expressions ['as' star_target]) _loop0_326"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_327: 'except' | 'finally'
static void *
_tmp_327_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'except'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_327[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 767))  // token='except'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_327[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_327[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except'"));
    }
    { // 'finally'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_327[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 763))  // token='finally'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_327[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_327[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'finally'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_328: block
static asdl_seq *
_loop0_328_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_328[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block"));
        asdl_stmt_seq* block_var;
        while (
            (block_var = block_rule(p))  // block
        )
        {
            _res = block_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_328[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "block"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_329: except_block
static asdl_seq *
_loop1_329_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // except_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_329[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "except_block"));
        excepthandler_ty except_block_var;
        while (
            (except_block_var = except_block_rule(p))  // except_block
        )
        {
            _res = except_block_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_329[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "except_block"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_330: 'as' NAME
static void *
_tmp_330_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_330[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty name_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_330[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = _PyPegen_dummy_name(p, _keyword, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_330[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_331: block
static asdl_seq *
_loop0_331_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_331[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block"));
        asdl_stmt_seq* block_var;
        while (
            (block_var = block_rule(p))  // block
        )
        {
            _res = block_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_331[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "block"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_332: except_star_block
static asdl_seq *
_loop1_332_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // except_star_block
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_332[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "except_star_block"));
        excepthandler_ty except_star_block_var;
        while (
            (except_star_block_var = except_star_block_rule(p))  // except_star_block
        )
        {
            _res = except_star_block_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_332[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "except_star_block"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_333: expression ['as' NAME]
static void *
_tmp_333_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // expression ['as' NAME]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_333[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ['as' NAME]"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (_opt_var = _tmp_397_rule(p), !p->error_indicator)  // ['as' NAME]
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_333[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ['as' NAME]"));
            _res = _PyPegen_dummy_name(p, expression_var, _opt_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_333[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ['as' NAME]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_334: 'except' | 'finally'
static void *
_tmp_334_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'except'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_334[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 767))  // token='except'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_334[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'except'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_334[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'except'"));
    }
    { // 'finally'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_334[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 763))  // token='finally'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_334[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'finally'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_334[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'finally'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_335: block_nonewline
static asdl_seq *
_loop0_335_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_335[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block_nonewline"));
        asdl_stmt_seq* block_nonewline_var;
        while (
            (block_nonewline_var = block_nonewline_rule(p))  // block_nonewline
        )
        {
            _res = block_nonewline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_335[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "block_nonewline"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_336: except_block_nonewline
static asdl_seq *
_loop1_336_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // except_block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_336[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "except_block_nonewline"));
        excepthandler_ty except_block_nonewline_var;
        while (
            (except_block_nonewline_var = except_block_nonewline_rule(p))  // except_block_nonewline
        )
        {
            _res = except_block_nonewline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_336[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "except_block_nonewline"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_337: 'as' NAME
static void *
_tmp_337_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_337[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty name_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_337[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = _PyPegen_dummy_name(p, _keyword, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_337[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_338: block_nonewline
static asdl_seq *
_loop0_338_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_338[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "block_nonewline"));
        asdl_stmt_seq* block_nonewline_var;
        while (
            (block_nonewline_var = block_nonewline_rule(p))  // block_nonewline
        )
        {
            _res = block_nonewline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_338[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "block_nonewline"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _loop1_339: except_star_block_nonewline
static asdl_seq *
_loop1_339_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // except_star_block_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop1_339[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "except_star_block_nonewline"));
        excepthandler_ty except_star_block_nonewline_var;
        while (
            (except_star_block_nonewline_var = except_star_block_nonewline_rule(p))  // except_star_block_nonewline
        )
        {
            _res = except_star_block_nonewline_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop1_339[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "except_star_block_nonewline"));
    }
    if (_n == 0 || p->error_indicator) {
        PyMem_Free(_children);
        p->level--;
        return NULL;
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_340: expression ['as' NAME]
static void *
_tmp_340_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // expression ['as' NAME]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_340[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ['as' NAME]"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (_opt_var = _tmp_398_rule(p), !p->error_indicator)  // ['as' NAME]
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_340[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ['as' NAME]"));
            _res = _PyPegen_dummy_name(p, expression_var, _opt_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_340[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ['as' NAME]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_341: 'as' NAME
static void *
_tmp_341_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_341[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty name_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_341[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = _PyPegen_dummy_name(p, _keyword, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_341[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_342: 'as' NAME
static void *
_tmp_342_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_342[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty name_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_342[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = _PyPegen_dummy_name(p, _keyword, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_342[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_343: NEWLINE | ':'
static void *
_tmp_343_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_343[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE"));
        Token * newline_var;
        if (
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_343[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "NEWLINE"));
            _res = newline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_343[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "NEWLINE"));
    }
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_343[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_343[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_343[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_344: 'as' NAME
static void *
_tmp_344_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_344[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty name_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_344[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = _PyPegen_dummy_name(p, _keyword, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_344[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_345: 'as' NAME
static void *
_tmp_345_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_345[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty name_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_345[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = _PyPegen_dummy_name(p, _keyword, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_345[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_346: 'as' NAME
static void *
_tmp_346_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_346[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty name_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_346[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = _PyPegen_dummy_name(p, _keyword, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_346[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_347: positional_patterns ','
static void *
_tmp_347_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // positional_patterns ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_347[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "positional_patterns ','"));
        Token * _literal;
        asdl_pattern_seq* positional_patterns_var;
        if (
            (positional_patterns_var = positional_patterns_rule(p))  // positional_patterns
            &&
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_347[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "positional_patterns ','"));
            _res = _PyPegen_dummy_name(p, positional_patterns_var, _literal);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_347[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "positional_patterns ','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_348: '->' expression
static void *
_tmp_348_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '->' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_348[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
        Token * _literal;
        expr_ty expression_var;
        if (
            (_literal = _PyPegen_expect_token(p, 51))  // token='->'
            &&
            (expression_var = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_348[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'->' expression"));
            _res = _PyPegen_dummy_name(p, _literal, expression_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_348[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'->' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_349: '(' arguments? ')'
static void *
_tmp_349_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '(' arguments? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_349[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (_opt_var = arguments_rule(p), !p->error_indicator)  // arguments?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_349[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
            _res = _PyPegen_dummy_name(p, _literal, _opt_var, _literal_1);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_349[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_350: '(' arguments? ')'
static void *
_tmp_350_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '(' arguments? ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_350[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
        Token * _literal;
        Token * _literal_1;
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        if (
            (_literal = _PyPegen_expect_token(p, 7))  // token='('
            &&
            (_opt_var = arguments_rule(p), !p->error_indicator)  // arguments?
            &&
            (_literal_1 = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_350[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
            _res = _PyPegen_dummy_name(p, _literal, _opt_var, _literal_1);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_350[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'(' arguments? ')'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_352: ',' double_starred_kvpair
static asdl_seq *
_loop0_352_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ',' double_starred_kvpair
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_352[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' double_starred_kvpair"));
        Token * _literal;
        KeyValuePair* elem;
        while (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (elem = double_starred_kvpair_rule(p))  // double_starred_kvpair
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_352[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' double_starred_kvpair"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_351: double_starred_kvpair _loop0_352
static asdl_seq *
_gather_351_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // double_starred_kvpair _loop0_352
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_351[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "double_starred_kvpair _loop0_352"));
        KeyValuePair* elem;
        asdl_seq * seq;
        if (
            (elem = double_starred_kvpair_rule(p))  // double_starred_kvpair
            &&
            (seq = _loop0_352_rule(p))  // _loop0_352
        )
        {
            D(fprintf(stderr, "%*c+ _gather_351[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "double_starred_kvpair _loop0_352"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_351[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "double_starred_kvpair _loop0_352"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_353: '}' | ','
static void *
_tmp_353_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_353[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_353[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_353[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'}'"));
    }
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_353[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_353[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_353[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_354: '}' | ','
static void *
_tmp_354_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_354[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_354[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_354[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'}'"));
    }
    { // ','
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_354[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_354[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "','"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_354[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "','"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_355: '=' | '!' | ':' | '}'
static void *
_tmp_355_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_355[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'='"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_355[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'='"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_355[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'='"));
    }
    { // '!'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_355[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 54))  // token='!'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_355[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_355[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!'"));
    }
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_355[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_355[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_355[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':'"));
    }
    { // '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_355[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_355[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_355[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_356: '!' | ':' | '}'
static void *
_tmp_356_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '!'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_356[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 54))  // token='!'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_356[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_356[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!'"));
    }
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_356[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_356[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_356[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':'"));
    }
    { // '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_356[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_356[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_356[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_357: '!' NAME
static void *
_tmp_357_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '!' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_357[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' NAME"));
        Token * _literal;
        expr_ty name_var;
        if (
            (_literal = _PyPegen_expect_token(p, 54))  // token='!'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_357[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' NAME"));
            _res = _PyPegen_dummy_name(p, _literal, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_357[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_358: ':' | '}'
static void *
_tmp_358_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_358[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_358[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_358[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':'"));
    }
    { // '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_358[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_358[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_358[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_359: '!' NAME
static void *
_tmp_359_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '!' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_359[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' NAME"));
        Token * _literal;
        expr_ty name_var;
        if (
            (_literal = _PyPegen_expect_token(p, 54))  // token='!'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_359[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' NAME"));
            _res = _PyPegen_dummy_name(p, _literal, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_359[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_360: fstring_format_spec
static asdl_seq *
_loop0_360_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // fstring_format_spec
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_360[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "fstring_format_spec"));
        expr_ty fstring_format_spec_var;
        while (
            (fstring_format_spec_var = fstring_format_spec_rule(p))  // fstring_format_spec
        )
        {
            _res = fstring_format_spec_var;
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_360[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "fstring_format_spec"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _tmp_361: '!' NAME
static void *
_tmp_361_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '!' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_361[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' NAME"));
        Token * _literal;
        expr_ty name_var;
        if (
            (_literal = _PyPegen_expect_token(p, 54))  // token='!'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_361[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'!' NAME"));
            _res = _PyPegen_dummy_name(p, _literal, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_361[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'!' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_362: ':' | '}'
static void *
_tmp_362_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_362[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_362[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_362[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':'"));
    }
    { // '}'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_362[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 26))  // token='}'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_362[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'}'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_362[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'}'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_363: ';'.simple_stmt+ | parenthesized_stmt_nonewline
static void *
_tmp_363_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ';'.simple_stmt+
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_363[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';'.simple_stmt+"));
        asdl_stmt_seq* b;
        if (
            (b = (asdl_stmt_seq*)_gather_399_rule(p))  // ';'.simple_stmt+
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_363[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';'.simple_stmt+"));
            _res = b;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_363[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "';'.simple_stmt+"));
    }
    { // parenthesized_stmt_nonewline
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_363[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "parenthesized_stmt_nonewline"));
        asdl_stmt_seq* parenthesized_stmt_nonewline_var;
        if (
            (parenthesized_stmt_nonewline_var = parenthesized_stmt_nonewline_rule(p))  // parenthesized_stmt_nonewline
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_363[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "parenthesized_stmt_nonewline"));
            _res = parenthesized_stmt_nonewline_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_363[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "parenthesized_stmt_nonewline"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_364: star_targets '='
static void *
_tmp_364_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // star_targets '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_364[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_targets '='"));
        Token * _literal;
        expr_ty z;
        if (
            (z = star_targets_rule(p))  // star_targets
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_364[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_targets '='"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_364[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_targets '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_365: '.' | '...'
static void *
_tmp_365_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '.'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_365[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'.'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_365[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'.'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_365[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'.'"));
    }
    { // '...'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_365[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'...'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 52))  // token='...'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_365[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'...'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_365[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'...'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_366: '.' | '...'
static void *
_tmp_366_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '.'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_366[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'.'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 23))  // token='.'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_366[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'.'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_366[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'.'"));
    }
    { // '...'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_366[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'...'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 52))  // token='...'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_366[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'...'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_366[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'...'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_367: star_targets '='
static void *
_tmp_367_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // star_targets '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_367[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_targets '='"));
        Token * _literal;
        expr_ty z;
        if (
            (z = star_targets_rule(p))  // star_targets
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_367[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_targets '='"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_367[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_targets '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_368: star_targets '='
static void *
_tmp_368_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // star_targets '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_368[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_targets '='"));
        Token * _literal;
        expr_ty z;
        if (
            (z = star_targets_rule(p))  // star_targets
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_368[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_targets '='"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_368[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_targets '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_369: '@' named_expression NEWLINE
static void *
_tmp_369_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '@' named_expression NEWLINE
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_369[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@' named_expression NEWLINE"));
        Token * _literal;
        expr_ty f;
        Token * newline_var;
        if (
            (_literal = _PyPegen_expect_token(p, 49))  // token='@'
            &&
            (f = named_expression_rule(p))  // named_expression
            &&
            (newline_var = _PyPegen_expect_token(p, NEWLINE))  // token='NEWLINE'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_369[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@' named_expression NEWLINE"));
            _res = f;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_369[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'@' named_expression NEWLINE"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_370: bitwiseor_pattern | 'None'
static void *
_tmp_370_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwiseor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_370[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwiseor_pattern"));
        expr_ty bitwiseor_pattern_var;
        if (
            (bitwiseor_pattern_var = bitwiseor_pattern_rule(p))  // bitwiseor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_370[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwiseor_pattern"));
            _res = bitwiseor_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_370[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwiseor_pattern"));
    }
    { // 'None'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_370[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 715))  // token='None'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_370[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_None , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_370[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'None'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_371: bitwiseor_pattern | 'None'
static void *
_tmp_371_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    if (p->mark == p->fill && _PyPegen_fill_token(p) < 0) {
        p->error_indicator = 1;
        p->level--;
        return NULL;
    }
    int _start_lineno = p->tokens[_mark]->lineno;
    UNUSED(_start_lineno); // Only used by EXTRA macro
    int _start_col_offset = p->tokens[_mark]->col_offset;
    UNUSED(_start_col_offset); // Only used by EXTRA macro
    { // bitwiseor_pattern
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_371[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwiseor_pattern"));
        expr_ty bitwiseor_pattern_var;
        if (
            (bitwiseor_pattern_var = bitwiseor_pattern_rule(p))  // bitwiseor_pattern
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_371[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "bitwiseor_pattern"));
            _res = bitwiseor_pattern_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_371[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "bitwiseor_pattern"));
    }
    { // 'None'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_371[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 715))  // token='None'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_371[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'None'"));
            Token *_token = _PyPegen_get_last_nonnwhitespace_token(p);
            if (_token == NULL) {
                p->level--;
                return NULL;
            }
            int _end_lineno = _token->end_lineno;
            UNUSED(_end_lineno); // Only used by EXTRA macro
            int _end_col_offset = _token->end_col_offset;
            UNUSED(_end_col_offset); // Only used by EXTRA macro
            _res = _PyAST_Constant ( Py_None , NULL , EXTRA );
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_371[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'None'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_373: ';' simple_stmt
static asdl_seq *
_loop0_373_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ';' simple_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_373[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';' simple_stmt"));
        Token * _literal;
        stmt_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 13))  // token=';'
            &&
            (elem = simple_stmt_rule(p))  // simple_stmt
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_373[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "';' simple_stmt"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_372: simple_stmt _loop0_373
static asdl_seq *
_gather_372_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // simple_stmt _loop0_373
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_372[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmt _loop0_373"));
        stmt_ty elem;
        asdl_seq * seq;
        if (
            (elem = simple_stmt_rule(p))  // simple_stmt
            &&
            (seq = _loop0_373_rule(p))  // _loop0_373
        )
        {
            D(fprintf(stderr, "%*c+ _gather_372[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmt _loop0_373"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_372[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_stmt _loop0_373"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_374: ',' expression
static void *
_tmp_374_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_374[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' expression"));
        Token * _literal;
        expr_ty c;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (c = expression_rule(p))  // expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_374[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' expression"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_374[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_375: ',' star_expression
static void *
_tmp_375_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' star_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_375[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' star_expression"));
        Token * _literal;
        expr_ty c;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (c = star_expression_rule(p))  // star_expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_375[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' star_expression"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_375[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' star_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_376: 'or' conjunction
static void *
_tmp_376_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'or' conjunction
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_376[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'or' conjunction"));
        Token * _keyword;
        expr_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 677))  // token='or'
            &&
            (c = conjunction_rule(p))  // conjunction
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_376[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'or' conjunction"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_376[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'or' conjunction"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_377: 'and' inversion
static void *
_tmp_377_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'and' inversion
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_377[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'and' inversion"));
        Token * _keyword;
        expr_ty c;
        if (
            (_keyword = _PyPegen_expect_token(p, 678))  // token='and'
            &&
            (c = inversion_rule(p))  // inversion
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_377[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'and' inversion"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_377[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'and' inversion"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_378: slice | starred_expression
static void *
_tmp_378_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // slice
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_378[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slice"));
        expr_ty slice_var;
        if (
            (slice_var = slice_rule(p))  // slice
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_378[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "slice"));
            _res = slice_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_378[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "slice"));
    }
    { // starred_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_378[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "starred_expression"));
        expr_ty starred_expression_var;
        if (
            (starred_expression_var = starred_expression_rule(p))  // starred_expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_378[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "starred_expression"));
            _res = starred_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_378[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "starred_expression"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_379: "def" | '@' | 'async'
static void *
_tmp_379_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // "def"
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_379[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\""));
        expr_ty _keyword;
        if (
            (_keyword = _PyPegen_expect_soft_keyword(p, "def"))  // soft_keyword='"def"'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_379[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "\"def\""));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_379[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "\"def\""));
    }
    { // '@'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_379[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 49))  // token='@'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_379[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_379[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'@'"));
    }
    { // 'async'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_379[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 784))  // token='async'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_379[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'async'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_379[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'async'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_380: 'class' | '@'
static void *
_tmp_380_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'class'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_380[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class'"));
        Token * _keyword;
        if (
            (_keyword = _PyPegen_expect_token(p, 786))  // token='class'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_380[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'class'"));
            _res = _keyword;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_380[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'class'"));
    }
    { // '@'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_380[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 49))  // token='@'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_380[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'@'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_380[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'@'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_381: fstring | string
static void *
_tmp_381_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // fstring
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_381[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "fstring"));
        expr_ty fstring_var;
        if (
            (fstring_var = fstring_rule(p))  // fstring
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_381[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "fstring"));
            _res = fstring_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_381[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "fstring"));
    }
    { // string
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_381[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "string"));
        expr_ty string_var;
        if (
            (string_var = string_rule(p))  // string
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_381[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "string"));
            _res = string_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_381[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "string"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_382: 'if' disjunction
static void *
_tmp_382_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'if' disjunction
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_382[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' disjunction"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (z = disjunction_rule(p))  // disjunction
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_382[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' disjunction"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_382[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'if' disjunction"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_383: 'if' disjunction
static void *
_tmp_383_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'if' disjunction
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_383[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' disjunction"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (z = disjunction_rule(p))  // disjunction
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_383[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' disjunction"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_383[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'if' disjunction"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_384: 'if' disjunction
static void *
_tmp_384_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'if' disjunction
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_384[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' disjunction"));
        Token * _keyword;
        expr_ty z;
        if (
            (_keyword = _PyPegen_expect_token(p, 772))  // token='if'
            &&
            (z = disjunction_rule(p))  // disjunction
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_384[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'if' disjunction"));
            _res = z;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_384[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'if' disjunction"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_385:
//     | starred_expression
//     | simple_slice
//     | (assignment_expression | expression !':=') !'='
static void *
_tmp_385_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // starred_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_385[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "starred_expression"));
        expr_ty starred_expression_var;
        if (
            (starred_expression_var = starred_expression_rule(p))  // starred_expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_385[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "starred_expression"));
            _res = starred_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_385[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "starred_expression"));
    }
    { // simple_slice
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_385[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
        expr_ty simple_slice_var;
        if (
            (simple_slice_var = simple_slice_rule(p))  // simple_slice
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_385[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_slice"));
            _res = simple_slice_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_385[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_slice"));
    }
    { // (assignment_expression | expression !':=') !'='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_385[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(assignment_expression | expression !':=') !'='"));
        void *_tmp_401_var;
        if (
            (_tmp_401_var = _tmp_401_rule(p))  // assignment_expression | expression !':='
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 22)  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_385[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "(assignment_expression | expression !':=') !'='"));
            _res = _tmp_401_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_385[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "(assignment_expression | expression !':=') !'='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_386: ',' star_target
static void *
_tmp_386_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_386[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' star_target"));
        Token * _literal;
        expr_ty c;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (c = star_target_rule(p))  // star_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_386[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' star_target"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_386[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' star_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_387: ',' star_target
static void *
_tmp_387_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ',' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_387[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' star_target"));
        Token * _literal;
        expr_ty c;
        if (
            (_literal = _PyPegen_expect_token(p, 12))  // token=','
            &&
            (c = star_target_rule(p))  // star_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_387[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "',' star_target"));
            _res = c;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                p->level--;
                return NULL;
            }
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_387[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "',' star_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_388: star_targets '='
static void *
_tmp_388_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // star_targets '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_388[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_targets '='"));
        Token * _literal;
        expr_ty star_targets_var;
        if (
            (star_targets_var = star_targets_rule(p))  // star_targets
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_388[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_targets '='"));
            _res = _PyPegen_dummy_name(p, star_targets_var, _literal);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_388[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_targets '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_389: star_targets '='
static void *
_tmp_389_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // star_targets '='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_389[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_targets '='"));
        Token * _literal;
        expr_ty star_targets_var;
        if (
            (star_targets_var = star_targets_rule(p))  // star_targets
            &&
            (_literal = _PyPegen_expect_token(p, 22))  // token='='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_389[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "star_targets '='"));
            _res = _PyPegen_dummy_name(p, star_targets_var, _literal);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_389[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "star_targets '='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_390: ')' | '**'
static void *
_tmp_390_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ')'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_390[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 8))  // token=')'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_390[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "')'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_390[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "')'"));
    }
    { // '**'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_390[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_390[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_390[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_391: ':' | '**'
static void *
_tmp_391_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // ':'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_391[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 11))  // token=':'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_391[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "':'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_391[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "':'"));
    }
    { // '**'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_391[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_391[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_391[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_392: '|' | '**'
static void *
_tmp_392_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // '|'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_392[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 18))  // token='|'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_392[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'|'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_392[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'|'"));
    }
    { // '**'
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_392[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**'"));
        Token * _literal;
        if (
            (_literal = _PyPegen_expect_token(p, 35))  // token='**'
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_392[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'**'"));
            _res = _literal;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_392[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'**'"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_393: expression ['as' star_target]
static void *
_tmp_393_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // expression ['as' star_target]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_393[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ['as' star_target]"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (_opt_var = _tmp_402_rule(p), !p->error_indicator)  // ['as' star_target]
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_393[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ['as' star_target]"));
            _res = _PyPegen_dummy_name(p, expression_var, _opt_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_393[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ['as' star_target]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_394: expressions ['as' star_target]
static void *
_tmp_394_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // expressions ['as' star_target]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_394[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expressions ['as' star_target]"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty expressions_var;
        if (
            (expressions_var = expressions_rule(p))  // expressions
            &&
            (_opt_var = _tmp_403_rule(p), !p->error_indicator)  // ['as' star_target]
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_394[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expressions ['as' star_target]"));
            _res = _PyPegen_dummy_name(p, expressions_var, _opt_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_394[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expressions ['as' star_target]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_395: expression ['as' star_target]
static void *
_tmp_395_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // expression ['as' star_target]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_395[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ['as' star_target]"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            (_opt_var = _tmp_404_rule(p), !p->error_indicator)  // ['as' star_target]
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_395[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression ['as' star_target]"));
            _res = _PyPegen_dummy_name(p, expression_var, _opt_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_395[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression ['as' star_target]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_396: expressions ['as' star_target]
static void *
_tmp_396_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // expressions ['as' star_target]
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_396[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expressions ['as' star_target]"));
        void *_opt_var;
        UNUSED(_opt_var); // Silence compiler warnings
        expr_ty expressions_var;
        if (
            (expressions_var = expressions_rule(p))  // expressions
            &&
            (_opt_var = _tmp_405_rule(p), !p->error_indicator)  // ['as' star_target]
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_396[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expressions ['as' star_target]"));
            _res = _PyPegen_dummy_name(p, expressions_var, _opt_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_396[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expressions ['as' star_target]"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_397: 'as' NAME
static void *
_tmp_397_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_397[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty name_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_397[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = _PyPegen_dummy_name(p, _keyword, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_397[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_398: 'as' NAME
static void *
_tmp_398_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' NAME
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_398[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
        Token * _keyword;
        expr_ty name_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (name_var = _PyPegen_name_token(p))  // NAME
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_398[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' NAME"));
            _res = _PyPegen_dummy_name(p, _keyword, name_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_398[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' NAME"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _loop0_400: ';' simple_stmt
static asdl_seq *
_loop0_400_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void *_res = NULL;
    int _mark = p->mark;
    void **_children = PyMem_Malloc(sizeof(void *));
    if (!_children) {
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    Py_ssize_t _children_capacity = 1;
    Py_ssize_t _n = 0;
    { // ';' simple_stmt
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _loop0_400[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "';' simple_stmt"));
        Token * _literal;
        stmt_ty elem;
        while (
            (_literal = _PyPegen_expect_token(p, 13))  // token=';'
            &&
            (elem = simple_stmt_rule(p))  // simple_stmt
        )
        {
            _res = elem;
            if (_res == NULL && PyErr_Occurred()) {
                p->error_indicator = 1;
                PyMem_Free(_children);
                p->level--;
                return NULL;
            }
            if (_n == _children_capacity) {
                _children_capacity *= 2;
                void **_new_children = PyMem_Realloc(_children, _children_capacity*sizeof(void *));
                if (!_new_children) {
                    PyMem_Free(_children);
                    p->error_indicator = 1;
                    PyErr_NoMemory();
                    p->level--;
                    return NULL;
                }
                _children = _new_children;
            }
            _children[_n++] = _res;
            _mark = p->mark;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _loop0_400[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "';' simple_stmt"));
    }
    asdl_seq *_seq = (asdl_seq*)_Py_asdl_generic_seq_new(_n, p->arena);
    if (!_seq) {
        PyMem_Free(_children);
        p->error_indicator = 1;
        PyErr_NoMemory();
        p->level--;
        return NULL;
    }
    for (int i = 0; i < _n; i++) asdl_seq_SET_UNTYPED(_seq, i, _children[i]);
    PyMem_Free(_children);
    p->level--;
    return _seq;
}

// _gather_399: simple_stmt _loop0_400
static asdl_seq *
_gather_399_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    asdl_seq * _res = NULL;
    int _mark = p->mark;
    { // simple_stmt _loop0_400
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _gather_399[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmt _loop0_400"));
        stmt_ty elem;
        asdl_seq * seq;
        if (
            (elem = simple_stmt_rule(p))  // simple_stmt
            &&
            (seq = _loop0_400_rule(p))  // _loop0_400
        )
        {
            D(fprintf(stderr, "%*c+ _gather_399[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "simple_stmt _loop0_400"));
            _res = _PyPegen_seq_insert_in_front(p, elem, seq);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _gather_399[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "simple_stmt _loop0_400"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_401: assignment_expression | expression !':='
static void *
_tmp_401_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // assignment_expression
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_401[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_expression"));
        expr_ty assignment_expression_var;
        if (
            (assignment_expression_var = assignment_expression_rule(p))  // assignment_expression
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_401[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "assignment_expression"));
            _res = assignment_expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_401[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "assignment_expression"));
    }
    { // expression !':='
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_401[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression !':='"));
        expr_ty expression_var;
        if (
            (expression_var = expression_rule(p))  // expression
            &&
            _PyPegen_lookahead_with_int(0, _PyPegen_expect_token, p, 53)  // token=':='
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_401[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "expression !':='"));
            _res = expression_var;
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_401[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "expression !':='"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_402: 'as' star_target
static void *
_tmp_402_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_402[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' star_target"));
        Token * _keyword;
        expr_ty star_target_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (star_target_var = star_target_rule(p))  // star_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_402[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' star_target"));
            _res = _PyPegen_dummy_name(p, _keyword, star_target_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_402[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' star_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_403: 'as' star_target
static void *
_tmp_403_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_403[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' star_target"));
        Token * _keyword;
        expr_ty star_target_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (star_target_var = star_target_rule(p))  // star_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_403[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' star_target"));
            _res = _PyPegen_dummy_name(p, _keyword, star_target_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_403[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' star_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_404: 'as' star_target
static void *
_tmp_404_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_404[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' star_target"));
        Token * _keyword;
        expr_ty star_target_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (star_target_var = star_target_rule(p))  // star_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_404[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' star_target"));
            _res = _PyPegen_dummy_name(p, _keyword, star_target_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_404[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' star_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

// _tmp_405: 'as' star_target
static void *
_tmp_405_rule(Parser *p)
{
    if (p->level++ == MAXSTACK) {
        p->error_indicator = 1;
        PyErr_NoMemory();
    }
    if (p->error_indicator) {
        p->level--;
        return NULL;
    }
    void * _res = NULL;
    int _mark = p->mark;
    { // 'as' star_target
        if (p->error_indicator) {
            p->level--;
            return NULL;
        }
        D(fprintf(stderr, "%*c> _tmp_405[%d-%d L%d]: %s\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' star_target"));
        Token * _keyword;
        expr_ty star_target_var;
        if (
            (_keyword = _PyPegen_expect_token(p, 770))  // token='as'
            &&
            (star_target_var = star_target_rule(p))  // star_target
        )
        {
            D(fprintf(stderr, "%*c+ _tmp_405[%d-%d L%d]: %s succeeded!\n", p->level, ' ', _mark, p->mark, p->tok->lineno, "'as' star_target"));
            _res = _PyPegen_dummy_name(p, _keyword, star_target_var);
            goto done;
        }
        p->mark = _mark;
        D(fprintf(stderr, "%*c%s _tmp_405[%d-%d L%d]: %s failed!\n", p->level, ' ',
                  p->error_indicator ? "ERROR!" : "-", _mark, p->mark, p->tok->lineno, "'as' star_target"));
    }
    _res = NULL;
  done:
    p->level--;
    return _res;
}

void *
_PyPegen_parse(Parser *p)
{
    // Initialize keywords
    p->keywords = reserved_keywords;
    p->n_keyword_lists = n_keyword_lists;
    p->soft_keywords = soft_keywords;

    // Run parser
    void *result = NULL;
    if (p->start_rule == Py_file_input) {
        result = file_rule(p);
    } else if (p->start_rule == Py_single_input) {
        result = interactive_rule(p);
    } else if (p->start_rule == Py_eval_input) {
        result = eval_rule(p);
    } else if (p->start_rule == Py_func_type_input) {
        result = func_type_rule(p);
    } else if (p->start_rule == Py_fstring_input) {
        result = fstring_rule(p);
    }

    return result;
}
